/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var bundle;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./grammar/eberban.js":
/*!****************************!*\
  !*** ./grammar/eberban.js ***!
  \****************************/
/***/ ((module) => {

eval("var camxes = (function() {\n  /*\n   * Generated by PEG.js 0.8.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function SyntaxError(message, expected, found, offset, line, column) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.offset   = offset;\n    this.line     = line;\n    this.column   = column;\n\n    this.name     = \"SyntaxError\";\n  }\n\n  peg$subclass(SyntaxError, Error);\n\n  function parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { text: peg$parsetext },\n        peg$startRuleFunction  = peg$parsetext,\n\n        peg$c0 = peg$FAILED,\n        peg$c1 = [],\n        peg$c2 = null,\n        peg$c3 = function(expr) {return _node(\"text\", expr);},\n        peg$c4 = void 0,\n        peg$c5 = function(expr) {return _node(\"paragraphs\", expr);},\n        peg$c6 = function(expr) {return _node(\"paragraph\", expr);},\n        peg$c7 = function(expr) {return _node(\"paragraph_unit_starter\", expr);},\n        peg$c8 = function(expr) {return _node(\"paragraph_unit\", expr);},\n        peg$c9 = function(expr) {return _node(\"paragraph_unit_erased\", expr);},\n        peg$c10 = function(expr) {return _node(\"paragraph_unit_1\", expr);},\n        peg$c11 = function(expr) {return _node(\"arguments_list\", expr);},\n        peg$c12 = function(expr) {return _node(\"defined\", expr);},\n        peg$c13 = function(expr) {return _node(\"definition\", expr);},\n        peg$c14 = function(expr) {return _node(\"sentence\", expr);},\n        peg$c15 = function(expr) {return _node(\"axiom\", expr);},\n        peg$c16 = function(expr) {return _node(\"scope\", expr);},\n        peg$c17 = function(expr) {return _node(\"scope_1\", expr);},\n        peg$c18 = function(expr) {return _node(\"scope_sequence\", expr);},\n        peg$c19 = function(expr) {return _node(\"scope_sequence_item\", expr);},\n        peg$c20 = function(expr) {return _node(\"scope_2\", expr);},\n        peg$c21 = function(expr) {return _node(\"chaining\", expr);},\n        peg$c22 = function(expr) {return _node(\"chaining_neg\", expr);},\n        peg$c23 = function(expr) {return _node(\"chaining_unit\", expr);},\n        peg$c24 = function(expr) {return _node(\"vi_scope\", expr);},\n        peg$c25 = function(expr) {return _node(\"vi_scope_first\", expr);},\n        peg$c26 = function(expr) {return _node(\"vi_scope_next\", expr);},\n        peg$c27 = function(expr) {return _node(\"predicate\", expr);},\n        peg$c28 = function(expr) {return _node(\"predicate_1\", expr);},\n        peg$c29 = function(expr) {return _node(\"predicate_2\", expr);},\n        peg$c30 = function(expr) {return _node(\"predicate_root\", expr);},\n        peg$c31 = function(expr) {return _node(\"predicate_number\", expr);},\n        peg$c32 = function(expr) {return _node(\"predicate_compound\", expr);},\n        peg$c33 = function(expr) {return _node(\"predicate_borrowing\", expr);},\n        peg$c34 = function(expr) {return _node(\"predicate_scope\", expr);},\n        peg$c35 = function(expr) {return _node(\"predicate_quote\", expr);},\n        peg$c36 = function(expr) {return _node(\"grammatical_quote\", expr);},\n        peg$c37 = function(expr) {return _node(\"one_word_quote\", expr);},\n        peg$c38 = function(expr) {return _node(\"foreign_quote\", expr);},\n        peg$c39 = function(expr) {return _node(\"foreign_quote_1\", expr);},\n        peg$c40 = { type: \"any\", description: \"any character\" },\n        peg$c41 = function(expr) { return [\"foreign_quote_content\", _join(expr)]; },\n        peg$c42 = function(expr) { _assign_foreign_quote_delim(expr); return _node(\"foreign_quote_open\", expr); },\n        peg$c43 = function(expr) {return _node(\"foreign_quote_word\", expr);},\n        peg$c44 = function(expr) { return _is_foreign_quote_delim(expr); },\n        peg$c45 = function(expr) { return _node(\"foreign_quote_close\", expr); },\n        peg$c46 = function(expr) {return _node(\"number\", expr);},\n        peg$c47 = function(expr) {return _node(\"number_1\", expr);},\n        peg$c48 = function(expr) {return _node(\"number_base\", expr);},\n        peg$c49 = function(expr) {return _node(\"number_fractional\", expr);},\n        peg$c50 = function(expr) {return _node(\"number_fractional_constraint\", expr);},\n        peg$c51 = function(expr) {return _node(\"number_repeat\", expr);},\n        peg$c52 = function(expr) {return _node(\"number_magnitude\", expr);},\n        peg$c53 = function(expr) {return _node(\"borrowing_group\", expr);},\n        peg$c54 = function(expr) {return _node(\"predicate_variable\", expr);},\n        peg$c55 = function(expr) {return _node(\"free_prefix\", expr);},\n        peg$c56 = function(expr) {return _node(\"free_metadata\", expr);},\n        peg$c57 = function(expr) {return _node(\"free_suffix\", expr);},\n        peg$c58 = function(expr) {return _node(\"free_interjection\", expr);},\n        peg$c59 = function(expr) {return _node(\"free_parenthetical\", expr);},\n        peg$c60 = function(expr) {return _node(\"BI_clause\", expr);},\n        peg$c61 = function(expr) {return _node(\"BE_clause\", expr);},\n        peg$c62 = function(expr) {return _node(\"BA_clause\", expr);},\n        peg$c63 = function(expr) {return _node(\"BO_clause\", expr);},\n        peg$c64 = function(expr) {return _node(\"BU_clause\", expr);},\n        peg$c65 = function(expr) {return _node(\"DI_clause\", expr);},\n        peg$c66 = function(expr) {return _node(\"DE_clause\", expr);},\n        peg$c67 = function(expr) {return _node(\"DA_clause\", expr);},\n        peg$c68 = function(expr) {return _node(\"DAI_clause\", expr);},\n        peg$c69 = function(expr) {return _node(\"DU_clause\", expr);},\n        peg$c70 = function(expr) {return _node(\"SI_clause\", expr);},\n        peg$c71 = function(expr) {return _node(\"ZI_clause\", expr);},\n        peg$c72 = function(expr) {return _node(\"VI_clause\", expr);},\n        peg$c73 = function(expr) {return _node(\"FI_clause\", expr);},\n        peg$c74 = function(expr) {return _node(\"VEI_clause\", expr);},\n        peg$c75 = function(expr) {return _node(\"GI_clause\", expr);},\n        peg$c76 = function(expr) {return _node(\"KI_clause\", expr);},\n        peg$c77 = function(expr) {return _node(\"MI_clause\", expr);},\n        peg$c78 = function(expr) {return _node(\"PE_clause\", expr);},\n        peg$c79 = function(expr) {return _node(\"PEI_clause\", expr);},\n        peg$c80 = function(expr) {return _node(\"PA_clause\", expr);},\n        peg$c81 = function(expr) {return _node(\"PO_clause\", expr);},\n        peg$c82 = function(expr) {return _node(\"PU_clause\", expr);},\n        peg$c83 = function(expr) {return _node(\"TI_clause\", expr);},\n        peg$c84 = function(expr) {return _node(\"JI_clause\", expr);},\n        peg$c85 = function(expr) {return _node(\"JE_clause\", expr);},\n        peg$c86 = function(expr) {return _node(\"JA_clause\", expr);},\n        peg$c87 = function(expr) {return _node(\"JO_clause\", expr);},\n        peg$c88 = function(expr) {return _node(\"JU_clause\", expr);},\n        peg$c89 = function(expr) {return _node(\"CA_clause\", expr);},\n        peg$c90 = function(expr) {return _node(\"CAI_clause\", expr);},\n        peg$c91 = function(expr) {return _node(\"CE_clause\", expr);},\n        peg$c92 = function(expr) {return _node(\"CO_clause\", expr);},\n        peg$c93 = function(expr) {return _node(\"COI_clause\", expr);},\n        peg$c94 = function(expr) {return _node(\"CU_clause\", expr);},\n        peg$c95 = function(expr) {return (expr == \"\" || !expr) ? [\"BE\"] : _node_empty(\"BE_clause_elidible\", expr);},\n        peg$c96 = function(expr) {return (expr == \"\" || !expr) ? [\"PA\"] : _node_empty(\"PA_clause_elidible\", expr);},\n        peg$c97 = function(expr) {return (expr == \"\" || !expr) ? [\"PEI\"] : _node_empty(\"PEI_clause_elidible\", expr);},\n        peg$c98 = function(expr) {return (expr == \"\" || !expr) ? [\"VEI\"] : _node_empty(\"VEI_clause_elidible\", expr);},\n        peg$c99 = function(expr) {return _node(\"BI\", expr);},\n        peg$c100 = function(expr) {return _node(\"BE\", expr);},\n        peg$c101 = function(expr) {return _node(\"BA\", expr);},\n        peg$c102 = function(expr) {return _node(\"BO\", expr);},\n        peg$c103 = function(expr) {return _node(\"BU\", expr);},\n        peg$c104 = function(expr) {return _node(\"CE\", expr);},\n        peg$c105 = function(expr) {return _node(\"CA\", expr);},\n        peg$c106 = function(expr) {return _node(\"CAI\", expr);},\n        peg$c107 = function(expr) {return _node(\"CO\", expr);},\n        peg$c108 = function(expr) {return _node(\"COI\", expr);},\n        peg$c109 = function(expr) {return _node(\"CU\", expr);},\n        peg$c110 = function(expr) {return _node(\"DI\", expr);},\n        peg$c111 = function(expr) {return _node(\"DE\", expr);},\n        peg$c112 = function(expr) {return _node(\"DA\", expr);},\n        peg$c113 = function(expr) {return _node(\"DAI\", expr);},\n        peg$c114 = function(expr) {return _node(\"DU\", expr);},\n        peg$c115 = function(expr) {return _node(\"FI\", expr);},\n        peg$c116 = function(expr) {return _node(\"GI\", expr);},\n        peg$c117 = function(expr) {return _node(\"JI\", expr);},\n        peg$c118 = function(expr) {return _node(\"JE\", expr);},\n        peg$c119 = function(expr) {return _node(\"JA\", expr);},\n        peg$c120 = function(expr) {return _node(\"JO\", expr);},\n        peg$c121 = function(expr) {return _node(\"JU\", expr);},\n        peg$c122 = function(expr) {return _node(\"KI\", expr);},\n        peg$c123 = function(expr) {return _node(\"MI\", expr);},\n        peg$c124 = function(expr) {return _node(\"PI\", expr);},\n        peg$c125 = function(expr) {return _node(\"PE\", expr);},\n        peg$c126 = function(expr) {return _node(\"PEI\", expr);},\n        peg$c127 = function(expr) {return _node(\"PA\", expr);},\n        peg$c128 = function(expr) {return _node(\"PO\", expr);},\n        peg$c129 = function(expr) {return _node(\"PU\", expr);},\n        peg$c130 = function(expr) {return _node(\"SI\", expr);},\n        peg$c131 = function(expr) {return _node(\"TI\", expr);},\n        peg$c132 = function(expr) {return _node(\"VI\", expr);},\n        peg$c133 = function(expr) {return _node(\"VEI\", expr);},\n        peg$c134 = function(expr) {return _node(\"ZI\", expr);},\n        peg$c135 = function(expr) {return _node(\"compound\", expr);},\n        peg$c136 = function(expr) {return _node(\"compound_2\", expr);},\n        peg$c137 = function(expr) {return _node(\"compound_3\", expr);},\n        peg$c138 = function(expr) {return _node(\"compound_n\", expr);},\n        peg$c139 = function(expr) {return _node(\"compound_n_end\", expr);},\n        peg$c140 = function(expr) {return _node(\"compound_word\", expr);},\n        peg$c141 = function(expr) {return _node(\"freeform_variable\", expr);},\n        peg$c142 = function(expr) {return _node(\"borrowing\", expr);},\n        peg$c143 = function(expr) {return _node(\"freeform_content\", expr);},\n        peg$c144 = function(expr) {return _node(\"freeform_initial\", expr);},\n        peg$c145 = function(expr) {return _node(\"freeform_end\", expr);},\n        peg$c146 = function(expr) {return _node(\"native_word\", expr);},\n        peg$c147 = function(expr) {return _node(\"native_form\", expr);},\n        peg$c148 = function(expr) {return _node(\"particle_word\", expr);},\n        peg$c149 = function(expr) {return _node(\"particle_form\", expr);},\n        peg$c150 = function(expr) {return _node(\"root_word\", expr);},\n        peg$c151 = function(expr) {return _node(\"root_form\", expr);},\n        peg$c152 = function(expr) {return _node(\"root_form_1\", expr);},\n        peg$c153 = function(expr) {return _node(\"root_form_2\", expr);},\n        peg$c154 = function(expr) {return _node(\"root_form_3\", expr);},\n        peg$c155 = function(expr) {return _node(\"hieaou\", expr);},\n        peg$c156 = function(expr) {return _node(\"ieaou\", expr);},\n        peg$c157 = function(expr) {return _node(\"consonant_triplet\", expr);},\n        peg$c158 = function(expr) {return _node(\"consonant_triplet_1\", expr);},\n        peg$c159 = function(expr) {return _node(\"consonant_triplet_2\", expr);},\n        peg$c160 = function(expr) {return _node(\"medial_pair\", expr);},\n        peg$c161 = function(expr) {return _node(\"medial_patterns\", expr);},\n        peg$c162 = function(expr) {return _node(\"medial_n\", expr);},\n        peg$c163 = function(expr) {return _node(\"medial_fv\", expr);},\n        peg$c164 = function(expr) {return _node(\"medial_plosive\", expr);},\n        peg$c165 = function(expr) {return _node(\"initial_pair\", expr);},\n        peg$c166 = function(expr) {return _node(\"initial\", expr);},\n        peg$c167 = function(expr) {return _node(\"other\", expr);},\n        peg$c168 = function(expr) {return _node(\"plosive\", expr);},\n        peg$c169 = function(expr) {return _node(\"sibilant\", expr);},\n        peg$c170 = function(expr) {return _node(\"sonorant\", expr);},\n        peg$c171 = function(expr) {return _node(\"consonant\", expr);},\n        peg$c172 = function(expr) {return _node(\"nasal\", expr);},\n        peg$c173 = function(expr) {return _node(\"liquid\", expr);},\n        peg$c174 = function(expr) {return _node(\"voiced\", expr);},\n        peg$c175 = function(expr) {return _node(\"unvoiced\", expr);},\n        peg$c176 = function(expr) {return _node(\"vowel\", expr);},\n        peg$c177 = /^[iI]/,\n        peg$c178 = { type: \"class\", value: \"[iI]\", description: \"[iI]\" },\n        peg$c179 = function(expr) {return [\"i\", \"i\"];},\n        peg$c180 = /^[eE]/,\n        peg$c181 = { type: \"class\", value: \"[eE]\", description: \"[eE]\" },\n        peg$c182 = function(expr) {return [\"e\", \"e\"];},\n        peg$c183 = /^[aA]/,\n        peg$c184 = { type: \"class\", value: \"[aA]\", description: \"[aA]\" },\n        peg$c185 = function(expr) {return [\"a\", \"a\"];},\n        peg$c186 = /^[oO]/,\n        peg$c187 = { type: \"class\", value: \"[oO]\", description: \"[oO]\" },\n        peg$c188 = function(expr) {return [\"o\", \"o\"];},\n        peg$c189 = /^[uU]/,\n        peg$c190 = { type: \"class\", value: \"[uU]\", description: \"[uU]\" },\n        peg$c191 = function(expr) {return [\"u\", \"u\"];},\n        peg$c192 = /^[hH]/,\n        peg$c193 = { type: \"class\", value: \"[hH]\", description: \"[hH]\" },\n        peg$c194 = function(expr) {return [\"h\", \"h\"];},\n        peg$c195 = /^[nN]/,\n        peg$c196 = { type: \"class\", value: \"[nN]\", description: \"[nN]\" },\n        peg$c197 = function(expr) {return [\"n\", \"n\"];},\n        peg$c198 = /^[rR]/,\n        peg$c199 = { type: \"class\", value: \"[rR]\", description: \"[rR]\" },\n        peg$c200 = function(expr) {return [\"r\", \"r\"];},\n        peg$c201 = /^[lL]/,\n        peg$c202 = { type: \"class\", value: \"[lL]\", description: \"[lL]\" },\n        peg$c203 = function(expr) {return [\"l\", \"l\"];},\n        peg$c204 = /^[mM]/,\n        peg$c205 = { type: \"class\", value: \"[mM]\", description: \"[mM]\" },\n        peg$c206 = function(expr) {return [\"m\", \"m\"];},\n        peg$c207 = /^[pP]/,\n        peg$c208 = { type: \"class\", value: \"[pP]\", description: \"[pP]\" },\n        peg$c209 = function(expr) {return [\"p\", \"p\"];},\n        peg$c210 = /^[bB]/,\n        peg$c211 = { type: \"class\", value: \"[bB]\", description: \"[bB]\" },\n        peg$c212 = function(expr) {return [\"b\", \"b\"];},\n        peg$c213 = /^[fF]/,\n        peg$c214 = { type: \"class\", value: \"[fF]\", description: \"[fF]\" },\n        peg$c215 = function(expr) {return [\"f\", \"f\"];},\n        peg$c216 = /^[vV]/,\n        peg$c217 = { type: \"class\", value: \"[vV]\", description: \"[vV]\" },\n        peg$c218 = function(expr) {return [\"v\", \"v\"];},\n        peg$c219 = /^[tT]/,\n        peg$c220 = { type: \"class\", value: \"[tT]\", description: \"[tT]\" },\n        peg$c221 = function(expr) {return [\"t\", \"t\"];},\n        peg$c222 = /^[dD]/,\n        peg$c223 = { type: \"class\", value: \"[dD]\", description: \"[dD]\" },\n        peg$c224 = function(expr) {return [\"d\", \"d\"];},\n        peg$c225 = /^[sS]/,\n        peg$c226 = { type: \"class\", value: \"[sS]\", description: \"[sS]\" },\n        peg$c227 = function(expr) {return [\"s\", \"s\"];},\n        peg$c228 = /^[zZ]/,\n        peg$c229 = { type: \"class\", value: \"[zZ]\", description: \"[zZ]\" },\n        peg$c230 = function(expr) {return [\"z\", \"z\"];},\n        peg$c231 = /^[cC]/,\n        peg$c232 = { type: \"class\", value: \"[cC]\", description: \"[cC]\" },\n        peg$c233 = function(expr) {return [\"c\", \"c\"];},\n        peg$c234 = /^[jJ]/,\n        peg$c235 = { type: \"class\", value: \"[jJ]\", description: \"[jJ]\" },\n        peg$c236 = function(expr) {return [\"j\", \"j\"];},\n        peg$c237 = /^[gG]/,\n        peg$c238 = { type: \"class\", value: \"[gG]\", description: \"[gG]\" },\n        peg$c239 = function(expr) {return [\"g\", \"g\"];},\n        peg$c240 = /^[kK]/,\n        peg$c241 = { type: \"class\", value: \"[kK]\", description: \"[kK]\" },\n        peg$c242 = function(expr) {return [\"k\", \"k\"];},\n        peg$c243 = /^[xX]/,\n        peg$c244 = { type: \"class\", value: \"[xX]\", description: \"[xX]\" },\n        peg$c245 = function(expr) {return [\"x\", \"x\"];},\n        peg$c246 = function(expr) {return _node(\"post_word\", expr);},\n        peg$c247 = function(expr) {return _node(\"spaces\", expr);},\n        peg$c248 = function(expr) {return _node(\"hesitation\", expr);},\n        peg$c249 = /^[\\n\\r]/,\n        peg$c250 = { type: \"class\", value: \"[\\\\n\\\\r]\", description: \"[\\\\n\\\\r]\" },\n        peg$c251 = function(expr) {return _node(\"hyphen\", expr);},\n        peg$c252 = /^[\\u2010\\u2014\\-]/,\n        peg$c253 = { type: \"class\", value: \"[\\\\u2010\\\\u2014\\\\-]\", description: \"[\\\\u2010\\\\u2014\\\\-]\" },\n        peg$c254 = function(expr) {return _node(\"hyphen_char\", expr);},\n        peg$c255 = function(expr) {return _node(\"single_pause_char\", expr);},\n        peg$c256 = /^['\\u2019`]/,\n        peg$c257 = { type: \"class\", value: \"['\\\\u2019`]\", description: \"['\\\\u2019`]\" },\n        peg$c258 = function(expr) {return _node(\"pause_char\", expr);},\n        peg$c259 = /^[a-zA-Z]/,\n        peg$c260 = { type: \"class\", value: \"[a-zA-Z]\", description: \"[a-zA-Z]\" },\n        peg$c261 = function(expr) {return _join(expr);},\n        peg$c262 = /^[0-9]/,\n        peg$c263 = { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n        peg$c264 = function(expr) {return [\"digit\", expr];},\n        peg$c265 = function(expr) {return _node(\"EOF\", expr);},\n\n        peg$currPos          = 0,\n        peg$reportedPos      = 0,\n        peg$cachedPos        = 0,\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$cache = {},\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$reportedPos, peg$currPos);\n    }\n\n    function offset() {\n      return peg$reportedPos;\n    }\n\n    function line() {\n      return peg$computePosDetails(peg$reportedPos).line;\n    }\n\n    function column() {\n      return peg$computePosDetails(peg$reportedPos).column;\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        peg$reportedPos\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, peg$reportedPos);\n    }\n\n    function peg$computePosDetails(pos) {\n      function advance(details, startPos, endPos) {\n        var p, ch;\n\n        for (p = startPos; p < endPos; p++) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n        }\n      }\n\n      if (peg$cachedPos !== pos) {\n        if (peg$cachedPos > pos) {\n          peg$cachedPos = 0;\n          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n        }\n        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n        peg$cachedPos = pos;\n      }\n\n      return peg$cachedPosDetails;\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, pos) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      var posDetails = peg$computePosDetails(pos),\n          found      = pos < input.length ? input.charAt(pos) : null;\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        pos,\n        posDetails.line,\n        posDetails.column\n      );\n    }\n\n    function peg$parsetext() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 204 + 0,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_interjection();\n      if (s3 === peg$FAILED) {\n        s3 = peg$parsefree_parenthetical();\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_interjection();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsefree_parenthetical();\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseparagraphs();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsespaces();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c2;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseEOF();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c2;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c3(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparagraphs() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 1,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseparagraph();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$currPos;\n        peg$silentFails++;\n        s6 = peg$parseDU_clause();\n        peg$silentFails--;\n        if (s6 !== peg$FAILED) {\n          peg$currPos = s5;\n          s5 = peg$c4;\n        } else {\n          s5 = peg$c0;\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parseparagraph();\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$currPos;\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseDU_clause();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseparagraph();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c5(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparagraph() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 204 + 2,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseDU_clause();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseparagraph_unit();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parseparagraph_unit_starter();\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = peg$c4;\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parseparagraph_unit();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parseparagraph_unit_starter();\n            peg$silentFails--;\n            if (s7 !== peg$FAILED) {\n              peg$currPos = s6;\n              s6 = peg$c4;\n            } else {\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseparagraph_unit();\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c6(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparagraph_unit_starter() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 3,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsePA_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsePO_clause();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsePU_clause();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c7(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparagraph_unit() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 4,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseparagraph_unit_erased();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseparagraph_unit_1();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c8(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparagraph_unit_erased() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 5,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseparagraph_unit_1();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseCU_clause();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c9(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparagraph_unit_1() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 6,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsedefinition();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseaxiom();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsesentence();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c10(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsearguments_list() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 7,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parseKI_clause();\n      if (s3 === peg$FAILED) {\n        s3 = peg$parseGI_clause();\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseKI_clause();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseGI_clause();\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseBE_clause();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c11(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedefined() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 8,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseGI_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = [];\n        s3 = peg$parsefree_prefix();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsefree_prefix();\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsespaces();\n          if (s3 === peg$FAILED) {\n            s3 = peg$c2;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsefreeform_variable();\n            if (s4 !== peg$FAILED) {\n              s2 = [s2, s3, s4];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsepredicate_compound();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsepredicate_root();\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c12(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedefinition() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 9,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsePO_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsedefined();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsescope();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c13(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesentence() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 10,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsePA_clause_elidible();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsescope();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c14(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseaxiom() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 11,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsePU_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsedefined();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c15(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 12,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsearguments_list();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsescope_1();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c16(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope_1() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 13,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsescope_sequence();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsescope_2();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c17(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope_sequence() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 204 + 14,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsescope_sequence_item();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseBU_clause();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$c0;\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parsescope_sequence_item();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseBU_clause();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsescope_sequence_item();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c18(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope_sequence_item() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 15,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsescope_2();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c19(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope_2() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 16,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsechaining();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c20(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsechaining() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 204 + 17,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsechaining_neg();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsechaining_unit();\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsechaining_neg();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsechaining_unit();\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c21(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsechaining_neg() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 18,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseBI_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsechaining();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c22(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsechaining_unit() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 19,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsepredicate();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsevi_scope();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsevi_scope();\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c23(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevi_scope() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 20,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsevi_scope_first();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsevi_scope_next();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsevi_scope_next();\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseVEI_clause_elidible();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c24(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevi_scope_first() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 21,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseBI_clause();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseVI_clause();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsescope();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c25(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevi_scope_next() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 22,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseBI_clause();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseFI_clause();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsescope();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c26(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 23,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsepredicate_1();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsefree_suffix();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsefree_suffix();\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c27(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_1() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 24,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parseSI_clause();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$currPos;\n        peg$silentFails++;\n        s6 = peg$parseSI_clause();\n        peg$silentFails--;\n        if (s6 === peg$FAILED) {\n          s5 = peg$c4;\n        } else {\n          peg$currPos = s5;\n          s5 = peg$c0;\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$c0;\n      }\n      if (s3 === peg$FAILED) {\n        s3 = peg$parseZI_clause();\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parseSI_clause();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseSI_clause();\n          peg$silentFails--;\n          if (s6 === peg$FAILED) {\n            s5 = peg$c4;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseZI_clause();\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsepredicate_2();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c28(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_2() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 25,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseBA_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseMI_clause();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsepredicate_quote();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsepredicate_variable();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parsepredicate_scope();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parsepredicate_borrowing();\n                if (s1 === peg$FAILED) {\n                  s1 = peg$parsepredicate_root();\n                  if (s1 === peg$FAILED) {\n                    s1 = peg$parsepredicate_number();\n                    if (s1 === peg$FAILED) {\n                      s1 = peg$parsepredicate_compound();\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c29(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_root() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 26,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseroot_word();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c30(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_number() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 27,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsenumber();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c31(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_compound() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 28,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecompound();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c32(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_borrowing() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 29,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseborrowing_group();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c33(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_scope() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 30,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsePE_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsescope();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePEI_clause_elidible();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c34(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_quote() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 31,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsegrammatical_quote();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseone_word_quote();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseforeign_quote();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c35(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsegrammatical_quote() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 32,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseCA_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsetext();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseCAI_clause();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c36(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseone_word_quote() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 33,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseCE_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsenative_word();\n          if (s4 === peg$FAILED) {\n            s4 = peg$parsecompound();\n            if (s4 === peg$FAILED) {\n              s4 = peg$parseborrowing();\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c37(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 34,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseCOI_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseforeign_quote_1();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c38(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote_1() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      var key    = peg$currPos * 204 + 35,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseCO_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseforeign_quote_open();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsepause_char();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseforeign_quote_content();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsesingle_pause_char();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parseforeign_quote_close();\n                  if (s8 !== peg$FAILED) {\n                    s2 = [s2, s3, s4, s5, s6, s7, s8];\n                    s1 = s2;\n                  } else {\n                    peg$currPos = s1;\n                    s1 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s1;\n                  s1 = peg$c0;\n                }\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c39(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote_content() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 36,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      peg$silentFails++;\n      s4 = peg$currPos;\n      s5 = peg$parsesingle_pause_char();\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parseforeign_quote_close();\n        if (s6 !== peg$FAILED) {\n          s5 = [s5, s6];\n          s4 = s5;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n      } else {\n        peg$currPos = s4;\n        s4 = peg$c0;\n      }\n      peg$silentFails--;\n      if (s4 === peg$FAILED) {\n        s3 = peg$c4;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$c0;\n      }\n      if (s3 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c40); }\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$currPos;\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$currPos;\n        s5 = peg$parsesingle_pause_char();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parseforeign_quote_close();\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c40); }\n          }\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c0;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c41(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote_open() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 37,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsenative_form();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c42(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote_word() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 38,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      peg$silentFails++;\n      s4 = peg$parsesingle_pause_char();\n      peg$silentFails--;\n      if (s4 === peg$FAILED) {\n        s3 = peg$c4;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$c0;\n      }\n      if (s3 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c40); }\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$currPos;\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parsesingle_pause_char();\n          peg$silentFails--;\n          if (s4 === peg$FAILED) {\n            s3 = peg$c4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n          if (s3 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c40); }\n            }\n            if (s4 !== peg$FAILED) {\n              s3 = [s3, s4];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c0;\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c43(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote_close() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 204 + 39,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsenative_word();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = peg$currPos;\n        s2 = peg$c44(s1);\n        if (s2) {\n          s2 = peg$c4;\n        } else {\n          s2 = peg$c0;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c45(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenumber() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 204 + 40,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsenumber_base();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsenumber_1();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsenumber_fractional();\n          if (s5 === peg$FAILED) {\n            s5 = peg$c2;\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$parsenumber_1();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c2;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsenumber_fractional();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsenumber_magnitude();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c2;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseJI_clause();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c2;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c46(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenumber_1() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 204 + 41,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseTI_clause();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseTI_clause();\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c47(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenumber_base() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 42,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseTI_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseJU_clause();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c48(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenumber_fractional() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 43,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseJO_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenumber_1();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsenumber_repeat();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c2;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsenumber_fractional_constraint();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c4;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c49(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenumber_fractional_constraint() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 44,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsenumber_magnitude();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsej();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsei();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseh();\n              if (s6 === peg$FAILED) {\n                s6 = peg$parseieaou();\n              }\n              if (s6 !== peg$FAILED) {\n                s2 = [s2, s3, s4, s5, s6];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c50(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenumber_repeat() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 45,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseJA_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenumber_1();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c51(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenumber_magnitude() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 46,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseJE_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenumber_1();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c52(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseborrowing_group() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 204 + 47,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsespaces();\n      if (s4 === peg$FAILED) {\n        s4 = peg$c2;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseborrowing();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$c0;\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parsespaces();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c2;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseborrowing();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseBE_clause_elidible();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c53(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepredicate_variable() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 48,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseBO_clause();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseKI_clause();\n          if (s4 === peg$FAILED) {\n            s4 = peg$parsedefined();\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c54(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefree_prefix() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 49,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsefree_metadata();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c55(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefree_metadata() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 50,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseDI_clause();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c56(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefree_suffix() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 51,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsefree_parenthetical();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsefree_interjection();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c57(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefree_interjection() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 52,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseDE_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsepredicate_1();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c58(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefree_parenthetical() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 53,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseDA_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsetext();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseDAI_clause();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c59(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBI_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 54,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseBI();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_suffix();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_suffix();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c60(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBE_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 55,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseBE();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c61(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBA_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 56,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseBA();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c62(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBO_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 57,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseBO();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c63(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBU_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 58,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseBU();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c64(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 59,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseDI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c65(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDE_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 60,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseDE();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c66(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDA_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 61,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseDA();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c67(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDAI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 62,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseDAI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c68(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDU_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 63,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseDU();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c69(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseSI_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 64,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseSI();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c70(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseZI_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 65,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseZI();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c71(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseVI_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 66,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseVI();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_suffix();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_suffix();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c72(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseFI_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 67,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseFI();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_suffix();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_suffix();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c73(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseVEI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 68,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseVEI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c74(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseGI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 69,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseGI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c75(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseKI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 70,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseKI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c76(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseMI_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 71,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseMI();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c77(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePE_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 72,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePE();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_suffix();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_suffix();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c78(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePEI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 73,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsePEI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c79(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePA_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 74,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePA();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_suffix();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_suffix();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c80(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePO_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 75,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePO();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_suffix();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_suffix();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c81(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePU_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 76,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsePU();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c82(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseTI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 77,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseTI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c83(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 78,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseJI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c84(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJE_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 79,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseJE();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c85(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJA_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 80,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseJA();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c86(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJO_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 81,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseJO();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c87(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJU_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 82,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseJU();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c88(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCA_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 83,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseCA();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c89(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCAI_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 84,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseCAI();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c90(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCE_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 85,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseCE();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c91(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCO_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 86,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseCO();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c92(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCOI_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 87,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseCOI();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c93(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCU_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 88,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseCU();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c94(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBE_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 89,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseBE_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c95(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePA_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 90,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsePA_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c96(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePEI_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 91,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsePEI_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c97(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseVEI_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 92,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseVEI_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c98(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 93,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseb();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsei();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c99(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBE() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 94,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseb();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsee();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c100(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBA() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 95,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseb();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsea();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c101(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBO() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 96,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseb();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseo();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c102(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBU() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 97,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseb();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseu();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c103(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCE() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 98,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsec();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsee();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c104(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCA() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 204 + 99,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$currPos;\n        s5 = peg$parseCAI();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = peg$c4;\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsec();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parsea();\n            peg$silentFails--;\n            if (s7 !== peg$FAILED) {\n              peg$currPos = s6;\n              s6 = peg$c4;\n            } else {\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehieaou();\n              if (s7 !== peg$FAILED) {\n                s5 = [s5, s6, s7];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsepost_word();\n            peg$silentFails--;\n            if (s6 !== peg$FAILED) {\n              peg$currPos = s5;\n              s5 = peg$c4;\n            } else {\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c105(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCAI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 100,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsec();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsea();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c106(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCO() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 204 + 101,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$currPos;\n        s5 = peg$parseCOI();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = peg$c4;\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsec();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parseo();\n            peg$silentFails--;\n            if (s7 !== peg$FAILED) {\n              peg$currPos = s6;\n              s6 = peg$c4;\n            } else {\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehieaou();\n              if (s7 !== peg$FAILED) {\n                s5 = [s5, s6, s7];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsepost_word();\n            peg$silentFails--;\n            if (s6 !== peg$FAILED) {\n              peg$currPos = s5;\n              s5 = peg$c4;\n            } else {\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c107(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCOI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 102,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsec();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseo();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c108(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCU() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 103,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsec();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseu();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c109(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 104,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsed();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsei();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c110(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDE() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 105,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsed();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsee();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c111(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDA() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 204 + 106,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$currPos;\n        s5 = peg$parseDAI();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = peg$c4;\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsed();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parsea();\n            peg$silentFails--;\n            if (s7 !== peg$FAILED) {\n              peg$currPos = s6;\n              s6 = peg$c4;\n            } else {\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehieaou();\n              if (s7 !== peg$FAILED) {\n                s5 = [s5, s6, s7];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsepost_word();\n            peg$silentFails--;\n            if (s6 !== peg$FAILED) {\n              peg$currPos = s5;\n              s5 = peg$c4;\n            } else {\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c112(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDAI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 107,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsed();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsea();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c113(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDU() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 108,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsed();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseu();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c114(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseFI() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 204 + 109,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsef();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehieaou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c115(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseGI() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 204 + 110,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseg();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehieaou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c116(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 111,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsej();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsei();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c117(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJE() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 112,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsej();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsee();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c118(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJA() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 113,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsej();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsea();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c119(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJO() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 114,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsej();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseo();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c120(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJU() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 115,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsej();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseu();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c121(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseKI() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 204 + 116,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsek();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehieaou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c122(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseMI() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 204 + 117,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsem();\n        if (s4 === peg$FAILED) {\n          s4 = peg$parsex();\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehieaou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c123(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 118,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsei();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c124(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePE() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 119,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsee();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c125(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePEI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 120,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsee();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c126(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePA() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 121,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsea();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c127(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePO() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 122,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseo();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c128(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePU() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 123,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseu();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c129(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseSI() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 204 + 124,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parses();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehieaou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c130(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseTI() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 204 + 125,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parset();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehieaou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsedigit();\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c131(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseVI() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 204 + 126,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$currPos;\n        s5 = peg$parseVEI();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = peg$c4;\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsev();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehieaou();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsepost_word();\n            peg$silentFails--;\n            if (s6 !== peg$FAILED) {\n              peg$currPos = s5;\n              s5 = peg$c4;\n            } else {\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c132(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseVEI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 127,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsev();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsee();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c133(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseZI() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 204 + 128,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle_word();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsez();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehieaou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c4;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c134(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 129,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsecompound_2();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsecompound_3();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsecompound_n();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c135(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_2() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 204 + 130,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsee();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsei();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecompound_word();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecompound_word();\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c136(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_3() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 131,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsea();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsei();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecompound_word();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecompound_word();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsecompound_word();\n              if (s6 !== peg$FAILED) {\n                s2 = [s2, s3, s4, s5, s6];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c137(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_n() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 204 + 132,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseo();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsei();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsecompound_n_end();\n          peg$silentFails--;\n          if (s7 === peg$FAILED) {\n            s6 = peg$c4;\n          } else {\n            peg$currPos = s6;\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsecompound_word();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$currPos;\n              s6 = peg$currPos;\n              peg$silentFails++;\n              s7 = peg$parsecompound_n_end();\n              peg$silentFails--;\n              if (s7 === peg$FAILED) {\n                s6 = peg$c4;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$c0;\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsecompound_word();\n                if (s7 !== peg$FAILED) {\n                  s6 = [s6, s7];\n                  s5 = s6;\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$c0;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            }\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecompound_n_end();\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c138(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_n_end() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 133,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseo();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsespaces();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c139(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_word() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 134,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseborrowing();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsenative_word();\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c140(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefreeform_variable() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 135,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsei();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsespaces();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsei();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$parsehyphen();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsei();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c4;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsefreeform_content();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsefreeform_end();\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c141(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseborrowing() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 136,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseu();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsespaces();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseu();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c4;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$parsehyphen();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parseu();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c4;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsefreeform_content();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsefreeform_end();\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c142(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefreeform_content() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 204 + 137,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsefreeform_initial();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c2;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehieaou();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$parseconsonant_triplet();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsehieaou();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = peg$parseconsonant_triplet();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehieaou();\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseconsonant();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c2;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c143(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefreeform_initial() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 138,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseconsonant_triplet();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsemedial_pair();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseinitial_pair();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parseconsonant();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parseh();\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c144(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefreeform_end() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 139,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsesingle_pause_char();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsespace_char();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseEOF();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c145(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenative_word() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 140,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseroot_word();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseparticle_word();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c146(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenative_form() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 141,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseroot_form();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseparticle_form();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c147(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparticle_word() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 142,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseparticle_form();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsepost_word();\n        peg$silentFails--;\n        if (s4 !== peg$FAILED) {\n          peg$currPos = s3;\n          s3 = peg$c4;\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c148(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparticle_form() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 143,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parsesonorant();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = peg$c4;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseconsonant();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsehieaou();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsemedial_pair();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c4;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c149(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseroot_word() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 144,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseroot_form();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsepost_word();\n        peg$silentFails--;\n        if (s4 !== peg$FAILED) {\n          peg$currPos = s3;\n          s3 = peg$c4;\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c150(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseroot_form() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 145,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parsesonorant();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = peg$c4;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseroot_form_1();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseroot_form_2();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parseroot_form_3();\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c151(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseroot_form_1() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      var key    = peg$currPos * 204 + 146,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseconsonant();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehieaou();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$parsemedial_pair();\n          if (s6 === peg$FAILED) {\n            s6 = peg$currPos;\n            s7 = peg$parsehyphen();\n            if (s7 !== peg$FAILED) {\n              s8 = peg$parsesonorant();\n              if (s8 !== peg$FAILED) {\n                s7 = [s7, s8];\n                s6 = s7;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$c0;\n              }\n            } else {\n              peg$currPos = s6;\n              s6 = peg$c0;\n            }\n          }\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsehieaou();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$currPos;\n              s6 = peg$parsemedial_pair();\n              if (s6 === peg$FAILED) {\n                s6 = peg$currPos;\n                s7 = peg$parsehyphen();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsesonorant();\n                  if (s8 !== peg$FAILED) {\n                    s7 = [s7, s8];\n                    s6 = s7;\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$c0;\n                }\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsehieaou();\n                if (s7 !== peg$FAILED) {\n                  s6 = [s6, s7];\n                  s5 = s6;\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$c0;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            }\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesonorant();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c2;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c152(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseroot_form_2() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 147,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseconsonant();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehieaou();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesonorant();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c153(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseroot_form_3() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      var key    = peg$currPos * 204 + 148,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseinitial_pair();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehieaou();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$parsemedial_pair();\n          if (s6 === peg$FAILED) {\n            s6 = peg$currPos;\n            s7 = peg$parsehyphen();\n            if (s7 !== peg$FAILED) {\n              s8 = peg$parsesonorant();\n              if (s8 !== peg$FAILED) {\n                s7 = [s7, s8];\n                s6 = s7;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$c0;\n              }\n            } else {\n              peg$currPos = s6;\n              s6 = peg$c0;\n            }\n          }\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsehieaou();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = peg$parsemedial_pair();\n            if (s6 === peg$FAILED) {\n              s6 = peg$currPos;\n              s7 = peg$parsehyphen();\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parsesonorant();\n                if (s8 !== peg$FAILED) {\n                  s7 = [s7, s8];\n                  s6 = s7;\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$c0;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$c0;\n              }\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehieaou();\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesonorant();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c2;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c154(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehieaou() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 204 + 149,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseieaou();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$parsehyphen();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parseh();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parseieaou();\n            if (s7 !== peg$FAILED) {\n              s5 = [s5, s6, s7];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$currPos;\n          s5 = peg$parsehyphen();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseh();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseieaou();\n              if (s7 !== peg$FAILED) {\n                s5 = [s5, s6, s7];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c155(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseieaou() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 150,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsevowel();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$parsehyphen();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsevowel();\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$currPos;\n          s5 = peg$parsehyphen();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsevowel();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c156(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseconsonant_triplet() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 151,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseconsonant_triplet_1();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseconsonant_triplet_2();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseconsonant();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c157(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseconsonant_triplet_1() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 152,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parsemedial_pair();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsesonorant();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseconsonant();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsehyphen();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseinitial_pair();\n              if (s6 !== peg$FAILED) {\n                s2 = [s2, s3, s4, s5, s6];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c158(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseconsonant_triplet_2() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 153,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsemedial_pair();\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parsesonorant();\n        if (s2 === peg$FAILED) {\n          s2 = peg$c2;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsehyphen();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseinitial_pair();\n            if (s4 === peg$FAILED) {\n              s4 = peg$currPos;\n              s5 = peg$currPos;\n              peg$silentFails++;\n              s6 = peg$parsesonorant();\n              peg$silentFails--;\n              if (s6 === peg$FAILED) {\n                s5 = peg$c4;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseconsonant();\n                if (s6 !== peg$FAILED) {\n                  s5 = [s5, s6];\n                  s4 = s5;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$c0;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              s2 = [s2, s3, s4];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          s2 = peg$parsesonorant();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsehyphen();\n            if (s3 !== peg$FAILED) {\n              s2 = [s2, s3];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c159(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsemedial_pair() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 154,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseinitial();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = peg$c4;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsemedial_patterns();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c160(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsemedial_patterns() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 155,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsemedial_n();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsemedial_fv();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsemedial_plosive();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c161(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsemedial_n() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 156,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsem();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseliquid();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehyphen();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsen();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parsen();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsehyphen();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseliquid();\n            if (s4 !== peg$FAILED) {\n              s2 = [s2, s3, s4];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c162(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsemedial_fv() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 157,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsef();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsev();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehyphen();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseplosive();\n          if (s4 === peg$FAILED) {\n            s4 = peg$parsesibilant();\n            if (s4 === peg$FAILED) {\n              s4 = peg$parsem();\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c163(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsemedial_plosive() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 158,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseplosive();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehyphen();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsef();\n          if (s4 === peg$FAILED) {\n            s4 = peg$parsev();\n            if (s4 === peg$FAILED) {\n              s4 = peg$parseplosive();\n              if (s4 === peg$FAILED) {\n                s4 = peg$parsem();\n              }\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c164(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseinitial_pair() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 204 + 159,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseinitial();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c4;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseconsonant();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseconsonant();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parseconsonant();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c4;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c165(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseinitial() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 160,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseplosive();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsef();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsev();\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehyphen();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesibilant();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parsesibilant();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsehyphen();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseother();\n            if (s4 !== peg$FAILED) {\n              s2 = [s2, s3, s4];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          s2 = peg$parsesibilant();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsehyphen();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parsesonorant();\n              if (s4 !== peg$FAILED) {\n                s2 = [s2, s3, s4];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n          if (s1 === peg$FAILED) {\n            s1 = peg$currPos;\n            s2 = peg$parseother();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsehyphen();\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parsesonorant();\n                if (s4 !== peg$FAILED) {\n                  s2 = [s2, s3, s4];\n                  s1 = s2;\n                } else {\n                  peg$currPos = s1;\n                  s1 = peg$c0;\n                }\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c166(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseother() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 204 + 161,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsep();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseb();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsen();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parset();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsed();\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parsen();\n          peg$silentFails--;\n          if (s4 === peg$FAILED) {\n            s3 = peg$c4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            peg$silentFails++;\n            s5 = peg$parsel();\n            peg$silentFails--;\n            if (s5 === peg$FAILED) {\n              s4 = peg$c4;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n            if (s4 !== peg$FAILED) {\n              s2 = [s2, s3, s4];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsev();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsef();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parsek();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parseg();\n                if (s1 === peg$FAILED) {\n                  s1 = peg$parsem();\n                  if (s1 === peg$FAILED) {\n                    s1 = peg$currPos;\n                    s2 = peg$parsen();\n                    if (s2 !== peg$FAILED) {\n                      s3 = peg$currPos;\n                      peg$silentFails++;\n                      s4 = peg$parseliquid();\n                      peg$silentFails--;\n                      if (s4 === peg$FAILED) {\n                        s3 = peg$c4;\n                      } else {\n                        peg$currPos = s3;\n                        s3 = peg$c0;\n                      }\n                      if (s3 !== peg$FAILED) {\n                        s2 = [s2, s3];\n                        s1 = s2;\n                      } else {\n                        peg$currPos = s1;\n                        s1 = peg$c0;\n                      }\n                    } else {\n                      peg$currPos = s1;\n                      s1 = peg$c0;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c167(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseplosive() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 162,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parset();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsed();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsek();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parseg();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parsep();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parseb();\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c168(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesibilant() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 163,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsec();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parses();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsej();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsez();\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c169(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesonorant() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 164,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsen();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parser();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsel();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c170(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseconsonant() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 165,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsevoiced();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseunvoiced();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseliquid();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsenasal();\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c171(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenasal() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 166,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsem();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsen();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsex();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c172(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseliquid() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 167,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsel();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parser();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c173(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevoiced() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 168,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseb();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsed();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseg();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsev();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parsez();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parsej();\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c174(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseunvoiced() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 169,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsep();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parset();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsek();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsef();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parses();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parsec();\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c175(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevowel() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 170,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsei();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsee();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsea();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parseo();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parseu();\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c176(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsei() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 204 + 171,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c177.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c178); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c177.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c178); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c179(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsee() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 204 + 172,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c180.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c181); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c180.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c181); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c182(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsea() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 204 + 173,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c183.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c184); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c183.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c184); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c185(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseo() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 204 + 174,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c186.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c187); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c186.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c187); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c188(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseu() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 204 + 175,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c189.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c190); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c189.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c190); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c191(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseh() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 204 + 176,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c192.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c193); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c192.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c193); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c194(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsen() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 204 + 177,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c195.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c196); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c195.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c196); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c197(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parser() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 204 + 178,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c198.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c199); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c198.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c199); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c200(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsel() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 204 + 179,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c201.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c202); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c201.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c202); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c203(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsem() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 204 + 180,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c204.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c205); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c204.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c205); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c206(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsep() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 181,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c207.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c208); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c207.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c208); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsevoiced();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c209(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseb() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 182,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c210.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c211); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c210.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c211); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseunvoiced();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c212(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsef() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 183,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c213.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c214); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c213.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c214); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsevoiced();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c215(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsev() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 184,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c216.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c217); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c216.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c217); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseunvoiced();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c218(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parset() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 185,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c219.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c220); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c219.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c220); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsevoiced();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c221(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsed() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 186,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c222.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c223); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c222.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c223); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseunvoiced();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c224(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parses() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 204 + 187,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c225.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c226); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c225.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c226); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsec();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsevoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c227(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsez() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 204 + 188,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c228.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c229); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c228.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c229); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsej();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseunvoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c230(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsec() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 204 + 189,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c231.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c232); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c231.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c232); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parses();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsevoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c233(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsej() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 204 + 190,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c234.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c235); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c234.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c235); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsez();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseunvoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c4;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c236(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseg() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 191,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c237.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c238); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c237.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c238); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseunvoiced();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c239(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsek() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 192,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c240.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c241); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c240.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c241); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsevoiced();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c242(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsex() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 193,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c243.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c244); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c243.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c244); }\n          }\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsevoiced();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c245(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepost_word() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 194,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsesingle_pause_char();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsevowel();\n        peg$silentFails--;\n        if (s4 !== peg$FAILED) {\n          peg$currPos = s3;\n          s3 = peg$c4;\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$currPos;\n        peg$silentFails++;\n        s3 = peg$parsesonorant();\n        peg$silentFails--;\n        if (s3 === peg$FAILED) {\n          s2 = peg$c4;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parseconsonant();\n          peg$silentFails--;\n          if (s4 !== peg$FAILED) {\n            peg$currPos = s3;\n            s3 = peg$c4;\n          } else {\n            s3 = peg$c0;\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsespaces();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c246(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsespaces() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 204 + 195,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsespace_char();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsespace_char();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehesitation();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c2;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsesingle_pause_char();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parsevowel();\n            peg$silentFails--;\n            if (s7 !== peg$FAILED) {\n              peg$currPos = s6;\n              s6 = peg$c4;\n            } else {\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 === peg$FAILED) {\n            s4 = peg$c2;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parsesingle_pause_char();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parsevowel();\n          peg$silentFails--;\n          if (s4 !== peg$FAILED) {\n            peg$currPos = s3;\n            s3 = peg$c4;\n          } else {\n            s3 = peg$c0;\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseEOF();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c247(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehesitation() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 204 + 196,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$parsen();\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsespace_char();\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsespace_char();\n          }\n        } else {\n          s4 = peg$c0;\n        }\n        if (s4 === peg$FAILED) {\n          s4 = peg$parseEOF();\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$currPos;\n          s3 = peg$parsen();\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$parsespace_char();\n            if (s5 !== peg$FAILED) {\n              while (s5 !== peg$FAILED) {\n                s4.push(s5);\n                s5 = peg$parsespace_char();\n              }\n            } else {\n              s4 = peg$c0;\n            }\n            if (s4 === peg$FAILED) {\n              s4 = peg$parseEOF();\n            }\n            if (s4 !== peg$FAILED) {\n              s3 = [s3, s4];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c0;\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c248(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehyphen() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 197,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsehyphen_char();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        if (peg$c249.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c250); }\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          if (peg$c249.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c250); }\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$c2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c251(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehyphen_char() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 198,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (peg$c252.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c253); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c254(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesingle_pause_char() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 204 + 199,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsepause_char();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsepause_char();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c255(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepause_char() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 200,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (peg$c256.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c257); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c258(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsespace_char() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 204 + 201,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parsesingle_pause_char();\n      if (s3 === peg$FAILED) {\n        s3 = peg$parsedigit();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsehyphen_char();\n          if (s3 === peg$FAILED) {\n            if (peg$c259.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c260); }\n            }\n          }\n        }\n      }\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = peg$c4;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c40); }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c261(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedigit() {\n      var s0, s1;\n\n      var key    = peg$currPos * 204 + 202,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (peg$c262.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c263); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c264(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseEOF() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 204 + 203,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      peg$silentFails++;\n      if (input.length > peg$currPos) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c40); }\n      }\n      peg$silentFails--;\n      if (s2 === peg$FAILED) {\n        s1 = peg$c4;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c265(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n\n      var _g_foreign_quote_delim;\n\n      function _join(arg) {\n        if (typeof(arg) == \"string\")\n          return arg;\n        else if (arg) {\n          var ret = \"\";\n          for (var v in arg) { if (arg[v]) ret += _join(arg[v]); }\n          return ret;\n        }\n      }\n\n      function _node_empty(label, arg) {\n        var ret = [];\n        if (label) ret.push(label);\n        if (arg && typeof arg == \"object\" && typeof arg[0] == \"string\" && arg[0]) {\n          ret.push( arg );\n          return ret;\n        }\n        if (!arg)\n        {\n          return ret;\n        }\n        return _node_int(label, arg);\n      }\n\n      function _node_int(label, arg) {\n        if (typeof arg == \"string\")\n          return arg;\n        if (!arg) arg = [];\n        var ret = [];\n        if (label) ret.push(label);\n        for (var v in arg) {\n          if (arg[v] && arg[v].length != 0)\n            ret.push( _node_int( null, arg[v] ) );\n        }\n        return ret;\n      }\n\n      function _node2(label, arg1, arg2) {\n        return [label].concat(_node_empty(arg1)).concat(_node_empty(arg2));\n      }\n\n      function _node(label, arg) {\n        var _n = _node_empty(label, arg);\n        return (_n.length == 1 && label) ? [] : _n;\n      }\n      var _node_nonempty = _node;\n\n      // === Functions for faking left recursion === //\n\n      function _flatten_node(a) {\n        // Flatten nameless nodes\n        // e.g. [Name1, [[Name2, X], [Name3, Y]]] --> [Name1, [Name2, X], [Name3, Y]]\n        if (is_array(a)) {\n          var i = 0;\n          while (i < a.length) {\n            if (!is_array(a[i])) i++;\n            else if (a[i].length === 0) // Removing []s\n              a = a.slice(0, i).concat(a.slice(i + 1));\n            else if (is_array(a[i][0]))\n              a = a.slice(0, i).concat(a[i], a.slice(i + 1));\n            else i++;\n          }\n        }\n        return a;\n      }\n\n      function _group_leftwise(arr) {\n        if (!is_array(arr)) return [];\n        else if (arr.length <= 2) return arr;\n        else return [_group_leftwise(arr.slice(0, -1)), arr[arr.length - 1]];\n      }\n\n      // \"_lg\" for \"Leftwise Grouping\".\n      function _node_lg(label, arg) {\n        return _node(label, _group_leftwise(_flatten_node(arg)));\n      }\n\n      function _node_lg2(label, arg) {\n        if (is_array(arg) && arg.length == 2)\n          arg = arg[0].concat(arg[1]);\n        return _node(label, _group_leftwise(arg));\n      }\n\n      // === Foreign words functions === //\n\n      function _assign_foreign_quote_delim(w) {\n        if (is_array(w)) w = join_expr(w);\n        else if (!is_string(w)) throw \"ERROR: foreign_quote word is of type \" + typeof w;\n        w = w.toLowerCase().replace(/,/gm,\"\").replace(/h/g, \"'\");\n        _g_foreign_quote_delim = w;\n        return;\n      }\n\n      function _is_foreign_quote_delim(w) {\n        if (is_array(w)) w = join_expr(w);\n        else if (!is_string(w)) throw \"ERROR: foreign_quote word is of type \" + typeof w;\n        /* Keeping spaces in the parse tree seems to result in the absorbtion of\n           spaces into the closing delimiter candidate, so we'll remove any space\n           character from our input. */\n        w = w.replace(/[.\\t\\n\\r?!\\u0020]/g, \"\");\n        w = w.toLowerCase().replace(/,/gm,\"\").replace(/h/g, \"'\");\n        return w === _g_foreign_quote_delim;\n      }\n\n      function join_expr(n) {\n        if (!is_array(n) || n.length < 1) return \"\";\n        var s = \"\";\n        var i = is_array(n[0]) ? 0 : 1;\n        while (i < n.length) {\n          s += is_string(n[i]) ? n[i] : join_expr(n[i]);\n          i++;\n        }\n        return s;\n      }\n\n      function is_string(v) {\n        // return $.type(v) === \"string\";\n        return Object.prototype.toString.call(v) === '[object String]';\n      }\n\n      function is_array(v) {\n        // return $.type(v) === \"array\";\n        return Object.prototype.toString.call(v) === '[object Array]';\n      }\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n    }\n  }\n\n  return {\n    SyntaxError: SyntaxError,\n    parse:       parse\n  };\n})()\nmodule.exports.camxes = camxes;\n\n\n//# sourceURL=webpack://bundle/./grammar/eberban.js?");

/***/ }),

/***/ "../dictionary/en.yaml":
/*!*****************************!*\
  !*** ../dictionary/en.yaml ***!
  \*****************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"0\":{\"id\":\"xlftdvdomw\",\"family\":\"TI\",\"gloss\":\"ti\",\"tags\":[\"number\",\"digit\",\"informal\"],\"short\":\"Digit 0\"},\"1\":{\"id\":\"hexrlbhzns\",\"family\":\"TI\",\"gloss\":\"te\",\"tags\":[\"number\",\"digit\",\"informal\"],\"short\":\"Digit 1\"},\"2\":{\"id\":\"vhdoiu4y7b\",\"family\":\"TI\",\"gloss\":\"ta\",\"tags\":[\"number\",\"digit\",\"informal\"],\"short\":\"Digit 2\"},\"3\":{\"id\":\"ht2vpalcxn\",\"family\":\"TI\",\"gloss\":\"to\",\"tags\":[\"number\",\"digit\",\"informal\"],\"short\":\"Digit 3\"},\"4\":{\"id\":\"v6z63bfmfc\",\"family\":\"TI\",\"gloss\":\"tu\",\"tags\":[\"number\",\"digit\",\"informal\"],\"short\":\"Digit 4\"},\"5\":{\"id\":\"jxgthvv20z\",\"family\":\"TI\",\"gloss\":\"tie\",\"tags\":[\"number\",\"digit\",\"informal\"],\"short\":\"Digit 5\"},\"6\":{\"id\":\"clpqjeyf1b\",\"family\":\"TI\",\"gloss\":\"tia\",\"tags\":[\"number\",\"digit\",\"informal\"],\"short\":\"Digit 6\"},\"7\":{\"id\":\"nftvzwfter\",\"family\":\"TI\",\"gloss\":\"tio\",\"tags\":[\"number\",\"digit\",\"informal\"],\"short\":\"Digit 7\"},\"8\":{\"id\":\"fm5zmy6i6s\",\"family\":\"TI\",\"gloss\":\"tiu\",\"tags\":[\"number\",\"digit\",\"informal\"],\"short\":\"Digit 8\"},\"9\":{\"id\":\"xfkrzesgc0\",\"family\":\"TI\",\"gloss\":\"tei\",\"tags\":[\"number\",\"digit\",\"informal\"],\"short\":\"Digit 9\"},\"ma\":{\"id\":\"uiwim2580z\",\"family\":\"MI\",\"gloss\":\"atom\",\"tags\":[\"core\"],\"short\":\"[E:ma] is an atom (grammar)\",\"definition\":\"𝜆c 𝜆e is-atom(e)\",\"notes\":\"Simplest non-predicate type. All more complex non-predicate types are\\\\natoms that must additionally satisfy some properties.\\\\n\\\\nThere are an infinite amount of atoms which have no intrinsic meaning.\\\\nInstead we can declare that they are connected in some way using\\\\ndefinitions.\\\\n\\\\nCan also be used alone for tautology (always true), since there exist at\\\\nleast one atom.\\\\n\"},\"mai\":{\"id\":\"uwjxg46v4h\",\"family\":\"MI\",\"gloss\":\"exists\",\"tags\":[\"core\"],\"short\":\"[E:a] exists.\",\"definition\":\"𝜆c 𝜆e ⊤\",\"notes\":\"Binding the [E] place multiple time allows to express equality/equivalence.\\\\nCan also be used alone for tautology (always true).\"},\"mae\":{\"id\":\"cvf5umqddb\",\"family\":\"MI\",\"gloss\":\"forall\",\"tags\":[\"core\"],\"short\":\"[E:(a)] is true for any argument (of the correct type).\",\"definition\":\"𝜆c 𝜆E ∀x E(c,x)\"},\"mao\":{\"id\":\"qzpxweephx\",\"family\":\"MI\",\"gloss\":\"nary-imply\",\"tags\":[\"core\"],\"short\":\"Every tuple of arguments that satisfy predicate [E:a] also satisfy [A:a].\",\"definition\":\"𝜆c 𝜆E 𝜆A ∀x ∀y ... E(c,x,y,...) ⇒ A(c,x,y,...)\",\"notes\":\"[E] can be used to represent tuples or arguments that satisfy [A].\\\\nThis can be used to express indirect questions, with [A] being a predicate\\\\nacting as a question and [E] representing the indirect\\\\nquestion/answer to the question.\\\\n\"},\"mui\":{\"id\":\"yftgrzjtiw\",\"family\":\"MI\",\"gloss\":\"unknown\",\"tags\":[\"core\"],\"short\":\"True if [E:()] have an unknown truth value.\",\"definition\":\"𝜆c 𝜆E is-unknown(E)\",\"notes\":\"All predicates return a trivalent truth value which is either true, false\\\\nor undefined. \\\\n\"},\"mue\":{\"id\":\"asdzumonex\",\"family\":\"MI\",\"gloss\":\"context-extract\",\"tags\":[\"core\"],\"short\":\"True if property [E:(ma)] is true with the context provided as argument.\\\\n\",\"definition\":\"𝜆c 𝜆E E(c,c)\",\"notes\":\"Exposes the context, an implicit/hidden argument to every predicate, as\\\\nan explicit parameter. Allows to handle the context like any other argument.\\\\n\"},\"mua\":{\"id\":\"t98puegdx0\",\"family\":\"MI\",\"gloss\":\"context-apply\",\"tags\":[\"core\"],\"short\":\"True if context [E:ma] makes [A:()] true.\",\"definition\":\"𝜆c 𝜆e 𝜆A A(e)\",\"transitive\":true,\"notes\":\"Evaluate a proposition with a provided context instead of the implicit\\\\nforwarded context.\\\\n\"},\"ba\":{\"id\":\"v47til8m74\",\"family\":\"BA\",\"gloss\":\"#inline-arg-generic\",\"tags\":[\"core\"],\"short\":\"Inline atom/generic argument marker.\"},\"bai\":{\"id\":\"vnuzs4uzpz\",\"family\":\"BA\",\"gloss\":\"#inline-arg-transitive\",\"tags\":[\"core\"],\"short\":\"Inline transitive predicate argument marker.\"},\"bae\":{\"id\":\"c8bgs5yx9k\",\"family\":\"BA\",\"gloss\":\"#inline-arg-intransitive\",\"tags\":[\"core\"],\"short\":\"Inline intransitive predicate argument marker.\"},\"vei\":{\"id\":\"dgx3rzqk2s\",\"family\":\"VEI\",\"gloss\":\"]\",\"tags\":[\"core\",\"terminator\",\"elidable\"],\"short\":\"Close the latest unclosed VI/FI.\"},\"vi\":{\"id\":\"f29bns2aei\",\"family\":\"VI\",\"gloss\":\"&[\",\"tags\":[\"core\"],\"short\":\"State the following 0-ary predicate chain, unrelated to any place.\"},\"ve\":{\"id\":\"jbhdi1yp6a\",\"family\":\"VI\",\"gloss\":\"E[\",\"tags\":[\"core\"],\"short\":\"The E place of the suffixed predicate is shared with the following predicate\\\\nchain.\\\\n\",\"notes\":\"The following predicate chain is a property over the variable used in the\\\\nsuffixed predicate E place.\\\\n\"},\"va\":{\"id\":\"zflv7yegal\",\"family\":\"VI\",\"gloss\":\"A[\",\"tags\":[\"core\"],\"short\":\"The A place of the suffixed predicate is shared with the following predicate\\\\nchain.\\\\n\",\"notes\":\"The following predicate chain is a property over the variable used in the\\\\nsuffixed predicate A place.\\\\n\"},\"vo\":{\"id\":\"iwknbmwwuw\",\"family\":\"VI\",\"gloss\":\"O[\",\"tags\":[\"core\"],\"short\":\"The O place of the suffixed predicate is shared with the following predicate\\\\nchain.\\\\n\",\"notes\":\"The following predicate chain is a property over the variable used in the\\\\nsuffixed predicate O place.\\\\n\"},\"vu\":{\"id\":\"bfqny28gid\",\"family\":\"VI\",\"gloss\":\"U[\",\"tags\":[\"core\"],\"short\":\"The U place of the suffixed predicate is shared with the following predicate\\\\nchain.\\\\n\",\"notes\":\"The following predicate chain is a property over the variable used in the\\\\nsuffixed predicate U place.\\\\n\"},\"vie\":{\"id\":\"f5qpoxyo34\",\"family\":\"VI\",\"gloss\":\"E=[\",\"tags\":[\"core\"],\"short\":\"The E place of the suffixed predicate is equivalent to the following\\\\npredicate chain.\\\\n\",\"notes\":\"The following predicate chain have the same type as the E place and is\\\\nequivalent. The E place must be a predicate place.\\\\n\"},\"via\":{\"id\":\"yq567wlm2t\",\"family\":\"VI\",\"gloss\":\"A=[\",\"tags\":[\"core\"],\"short\":\"The A place of the suffixed predicate is equivalent to the following\\\\npredicate chain.\\\\n\",\"notes\":\"The following predicate chain have the same type as the A place and is\\\\nequivalent. The A place must be a predicate place.\\\\n\"},\"vio\":{\"id\":\"glcyqfkkoq\",\"family\":\"VI\",\"gloss\":\"O=[\",\"tags\":[\"core\"],\"short\":\"The O place of the suffixed predicate is equivalent to the following\\\\npredicate chain.\\\\n\",\"notes\":\"The following predicate chain have the same type as the O place and is\\\\nequivalent. The O place must be a predicate place.\\\\n\"},\"viu\":{\"id\":\"ce345k1ke4\",\"family\":\"VI\",\"gloss\":\"U=[\",\"tags\":[\"core\"],\"short\":\"The U place of the suffixed predicate is equivalent to the following\\\\npredicate chain.\\\\n\",\"notes\":\"The following predicate chain have the same type as the U place and is\\\\nequivalent. The U place must be a predicate place.\\\\n\"},\"fi\":{\"id\":\"kd9qbtxtq0\",\"family\":\"FI\",\"gloss\":\"]&[\",\"short\":\"State the following predicate chain, unrelated to any place.\"},\"fe\":{\"id\":\"vyrnf5aysv\",\"family\":\"FI\",\"gloss\":\"]E[\",\"tags\":[\"core\"],\"short\":\"The E place of the predicate suffixed with latest non-closed VI is shared\\\\nwith the following predicate chain.\\\\n\",\"notes\":\"The following predicate chain is a property over the variable used in the\\\\nsuffixed predicate E place.\\\\n\"},\"fa\":{\"id\":\"qxgljpgy5n\",\"family\":\"FI\",\"gloss\":\"]A[\",\"tags\":[\"core\"],\"short\":\"The A place of the predicate suffixed with latest non-closed VI is shared\\\\nwith the following predicate chain.\\\\n\",\"notes\":\"The following predicate chain is a property over the variable used in the\\\\nsuffixed predicate A place.\\\\n\"},\"fo\":{\"id\":\"ioz2vm2anw\",\"family\":\"FI\",\"gloss\":\"]O[\",\"tags\":[\"core\"],\"short\":\"The O place of the predicate suffixed with latest non-closed VI is shared\\\\nwith the following predicate chain.\\\\n\",\"notes\":\"The following predicate chain is a property over the variable used in the\\\\nsuffixed predicate O place.\\\\n\"},\"fu\":{\"id\":\"ydlpoaeiyz\",\"family\":\"FI\",\"gloss\":\"]U[\",\"tags\":[\"core\"],\"short\":\"The U place of the predicate suffixed with latest non-closed VI is shared\\\\nwith the following predicate chain.\\\\n\",\"notes\":\"The following predicate chain is a property over the variable used in the\\\\nsuffixed predicate U place.\\\\n\"},\"fie\":{\"id\":\"yth6gftm5i\",\"family\":\"FI\",\"gloss\":\"]E=[\",\"tags\":[\"core\"],\"short\":\"The E place of the predicate suffixed with latest non-closed VI is equivalent\\\\nto the following predicate chain.\\\\n\",\"notes\":\"The following predicate chain have the same type as the E place and is\\\\nequivalent. The E place must be a predicate place.\\\\n\"},\"fia\":{\"id\":\"0uktfjuhwa\",\"family\":\"FI\",\"gloss\":\"]A=[\",\"tags\":[\"core\"],\"short\":\"The A place of the predicate suffixed with latest non-closed VI is equivalent\\\\nto the following predicate chain.\\\\n\",\"notes\":\"The following predicate chain have the same type as the A place and is\\\\nequivalent. The A place must be a predicate place.\\\\n\"},\"fio\":{\"id\":\"oasxkhx46g\",\"family\":\"FI\",\"gloss\":\"]O=[\",\"tags\":[\"core\"],\"short\":\"The O place of the predicate suffixed with latest non-closed VI is equivalent\\\\nto the following predicate chain.\\\\n\",\"notes\":\"The following predicate chain have the same type as the O place and is\\\\nequivalent. The O place must be a predicate place.\\\\n\"},\"fiu\":{\"id\":\"ggbu5esdez\",\"family\":\"FI\",\"gloss\":\"]U=[\",\"tags\":[\"core\"],\"short\":\"The U place of the predicate suffixed with latest non-closed VI is equivalent\\\\nto the following predicate chain.\\\\n\",\"notes\":\"The following predicate chain have the same type as the U place and is\\\\nequivalent. The U place must be a predicate place.\\\\n\"},\"se\":{\"id\":\"qgxn2xhcit\",\"family\":\"SI\",\"gloss\":\"<EE>\",\"tags\":[\"core\"],\"short\":\"Bind E place and disable chaining.\"},\"sa\":{\"id\":\"oricdbjcuk\",\"family\":\"SI\",\"gloss\":\"<AA>\",\"tags\":[\"core\"],\"short\":\"Bind A place and disable chaining.\"},\"so\":{\"id\":\"1veohtfe08\",\"family\":\"SI\",\"gloss\":\"<OO>\",\"tags\":[\"core\"],\"short\":\"Bind O place and disable chaining.\"},\"su\":{\"id\":\"kkao3xh8vs\",\"family\":\"SI\",\"gloss\":\"<II>\",\"tags\":[\"core\"],\"short\":\"Bind U place and disable chaining.\"},\"sea\":{\"id\":\"xdpcwhenkp\",\"family\":\"SI\",\"gloss\":\"<EA>\",\"tags\":[\"core\"],\"short\":\"Bind E place and chains the A place.\"},\"seo\":{\"id\":\"vxhg5a1wzo\",\"family\":\"SI\",\"gloss\":\"<EO>\",\"tags\":[\"core\"],\"short\":\"Bind E place and chains the O place.\"},\"seu\":{\"id\":\"z4ugiojfqh\",\"family\":\"SI\",\"gloss\":\"<EU>\",\"tags\":[\"core\"],\"short\":\"Bind E place and chains the U place.\"},\"sae\":{\"id\":\"rnwr8famzy\",\"family\":\"SI\",\"gloss\":\"<AE>\",\"tags\":[\"core\"],\"short\":\"Bind A place and chains the E place.\"},\"sao\":{\"id\":\"xoapimitmx\",\"family\":\"SI\",\"gloss\":\"<AO>\",\"tags\":[\"core\"],\"short\":\"Bind A place and chains the O place.\"},\"sau\":{\"id\":\"iqjs2euswn\",\"family\":\"SI\",\"gloss\":\"<AU>\",\"tags\":[\"core\"],\"short\":\"Bind A place and chains the U place.\"},\"soe\":{\"id\":\"zje1rsx4uk\",\"family\":\"SI\",\"gloss\":\"<OE>\",\"tags\":[\"core\"],\"short\":\"Bind O place and chains the E place.\"},\"soa\":{\"id\":\"rythxb2fce\",\"family\":\"SI\",\"gloss\":\"<OA>\",\"tags\":[\"core\"],\"short\":\"Bind O place and chains the A place.\"},\"sou\":{\"id\":\"s7zufvudfl\",\"family\":\"SI\",\"gloss\":\"<OU>\",\"tags\":[\"core\"],\"short\":\"Bind O place and chains the U place.\"},\"sue\":{\"id\":\"pyvknqecpo\",\"family\":\"SI\",\"gloss\":\"<UE>\",\"tags\":[\"core\"],\"short\":\"Bind U place and chains the E place.\"},\"sua\":{\"id\":\"tqdbdmjidp\",\"family\":\"SI\",\"gloss\":\"<UA>\",\"tags\":[\"core\"],\"short\":\"Bind U place and chains the A place.\"},\"suo\":{\"id\":\"gewbwhd3d4\",\"family\":\"SI\",\"gloss\":\"<UO>\",\"tags\":[\"core\"],\"short\":\"Bind U place and chains the O place.\"},\"ze\":{\"id\":\"hq8iez19yn\",\"family\":\"ZI\",\"gloss\":\"#reuse\",\"tags\":[\"core\"],\"short\":\"Use the latest instance and variables of the predicate word instead of creating new ones.\"},\"zei\":{\"id\":\"sryho6kcbc\",\"family\":\"ZI\",\"gloss\":\"#reuse-compound\",\"tags\":[\"core\"],\"short\":\"Use the latest instance and variables of a compound containing this word\\\\ninstead of creating new ones.\\\\n\"},\"zi\":{\"id\":\"drzw8dig76\",\"family\":\"ZI\",\"gloss\":\"#short-neg\",\"tags\":[\"core\",\"negation\"],\"short\":\"Narrow-scope negation : negates the predicate unit but not the existential variables it creates.\\\\nThere exist e, a,... such that unit(e, a, ...) is false.\\\\n\"},\"zoie\":{\"id\":\"uhlxkvwwa7\",\"family\":\"ZI\",\"gloss\":\"#get-default-E\",\"tags\":[\"core\",\"default\"],\"short\":\"Satisfy the default bound of the E place of [predicate] (set with {poie}).\\\\n\"},\"zoia\":{\"id\":\"pnlxz4xwki\",\"family\":\"ZI\",\"gloss\":\"#get-default-A\",\"tags\":[\"core\",\"default\"],\"short\":\"Satisfy the default bound of the A place of [predicate] (set with {poia}).\\\\n\"},\"zoio\":{\"id\":\"ypral6pdfc\",\"family\":\"ZI\",\"gloss\":\"#get-default-O\",\"tags\":[\"core\",\"default\"],\"short\":\"Satisfy the default bound of the O place of [predicate] (set with {poio}).\\\\n\"},\"zoiu\":{\"id\":\"eylcna75du\",\"family\":\"ZI\",\"gloss\":\"#get-default-U\",\"tags\":[\"core\",\"default\"],\"short\":\"Satisfy the default bound of the U place of [predicate] (set with {poiu}).\\\\n\"},\"zu\":{\"id\":\"khqauhadzn\",\"family\":\"ZI\",\"gloss\":\"#instanciate-transitive\",\"tags\":[\"core\"],\"transitive\":true,\"short\":\"Instanciate the E predicate place of the prefixed predicate. Place can be\\\\nselected by a following SI. This predicate is transitive.\\\\n\",\"notes\":\"Is necessary to use a predicate stored in a KI variable (which have a\\\\n[E:(...)] place) with arguments provided with VI/FI. It can however be\\\\nused more broadly, for exemple with predicates that \\\\\"transforms\\\\\" a\\\\npredicate into another one.\\\\n\\\\nUsing a transitive GI variable can be seen as if it was some KI variable\\\\nwhich was then instanciated with {zu KI}.\\\\n\"},\"zui\":{\"id\":\"34z5pisibi\",\"family\":\"ZI\",\"gloss\":\"#instanciate-intransitive\",\"tags\":[\"core\"],\"transitive\":true,\"short\":\"Instanciate the E predicate place of the prefixed predicate. Place can be\\\\nselected by a following SI. This predicate is intransitive.\\\\n\",\"notes\":\"Is necessary to use a predicate stored in a KI variable (which have a\\\\n[E:(...)] place) with arguments provided with VI/FI. It can however be\\\\nused more broadly, for exemple with predicates that \\\\\"transforms\\\\\" a\\\\npredicate into another one.\\\\n\\\\nUsing an instransitive GI variable can be seen as if it was some KI variable\\\\nwhich was then instanciated with {zui KI}.\\\\n\"},\"zue\":{\"id\":\"qrpqjlbxo6\",\"family\":\"ZI\",\"gloss\":\"#()-to-(a)\",\"tags\":[\"core\"],\"short\":\"Transform an [A:()] place into an [A:(a)] place, which is provided the\\\\ncontent of the [E:a] place.  \\\\nThe resulting predicate is transitive.\\\\n\\\\nWhile a SE before {i} can still override the chaining behavior, a SE after\\\\n{zue} allow to select which places to use for the transformation.\\\\n\\\\nFor 2-vowels SE variants \\\\\"sXY\\\\\", X select the entity place, while Y select\\\\nthe proposition place. Not using a SE thus is equivalent to an implicit\\\\n{sea}.\\\\n\\\\nFor 1-vowel SE variants \\\\\"sY\\\\\", it is equivalent to \\\\\"SeY\\\\\". Since it doesn\\'t\\\\nmake sense to use the same places for both sides, {se} is nonsensical.\\\\n\\\\nThe selected proposition place will be the one being transitioned to in\\\\nchaining (unless overwritten by a SE placed before {zue}).\\\\n\"},\"poie\":{\"id\":\"kcj6ptjgvi\",\"family\":\"PO\",\"gloss\":\"#set-default-E\",\"tags\":[\"core\",\"default\"],\"short\":\"Set the default constraint for the E place of the following predicate word.\\\\n\"},\"poia\":{\"id\":\"tbu1ntupmq\",\"family\":\"PO\",\"gloss\":\"#set-default-A\",\"tags\":[\"core\",\"default\"],\"short\":\"Set the default constraint for the A place of the following predicate word.\\\\n\"},\"poio\":{\"id\":\"hokid2gzwm\",\"family\":\"PO\",\"gloss\":\"#set-default-O\",\"tags\":[\"core\",\"default\"],\"short\":\"Set the default constraint for the O place of the following predicate word.\\\\n\"},\"poiu\":{\"id\":\"87acytzfsn\",\"family\":\"PO\",\"gloss\":\"#set-default-U\",\"tags\":[\"core\",\"default\"],\"short\":\"Set the default constraint for the U place of the following predicate word.\\\\n\"},\"po\":{\"id\":\"mkilbshz7v\",\"family\":\"PO\",\"gloss\":\"#def\",\"tags\":[\"core\"],\"short\":\"Start a predicate definition.\"},\"poe\":{\"id\":\"c0kwgmhcwy\",\"family\":\"PO\",\"gloss\":\"#def-capture\",\"tags\":[\"core\"],\"short\":\"Start a predicate definition which captures the current context.\"},\"pahi\":{\"id\":\"nxtau0gqfz\",\"family\":\"PA\",\"gloss\":\"#sentence-wrapper\",\"tags\":[\"core\"],\"short\":\"Registers a sentence wrapper, such that any sentence [E:()] expressed with\\\\n{pa} is wrapped by this registered predicate.\\\\n\"},\"pae\":{\"id\":\"zkukmnzdxs\",\"family\":\"PA\",\"gloss\":\"#update-context\",\"tags\":[\"core\",\"context\"],\"short\":\"Starts a context switching sentence, such that [E:ma] will be the context\\\\nprovided to any following sentences.\\\\n\"},\"pahe\":{\"id\":\"utl5b5flgt\",\"family\":\"PA\",\"gloss\":\"#context-updater\",\"tags\":[\"core\",\"context\"],\"short\":\"Registers a context-switching sentence, that will be applied automatically\\\\nbetween each sentences as if it was used with {pae}.\\\\n\"},\"pe\":{\"id\":\"c9njzictfu\",\"family\":\"PE\",\"gloss\":\"[\",\"tags\":[\"core\"],\"short\":\"Inline scope starter.\"},\"pei\":{\"id\":\"cou785jhzz\",\"family\":\"PEI\",\"gloss\":\"]\",\"tags\":[\"core\",\"terminator\",\"elidable\"],\"short\":\"Inline scope elidible terminator.\"},\"pu\":{\"id\":\"em8adaqgg3\",\"family\":\"PU\",\"gloss\":\"#axiom-on\",\"tags\":[\"core\"],\"short\":\"Enable axiomatic predicate.\"},\"pui\":{\"id\":\"jlotxmhwg4\",\"family\":\"PU\",\"gloss\":\"#axiom-off\",\"tags\":[\"core\"],\"short\":\"Disable axiomatic predicate.\"},\"be\":{\"id\":\"0hikwjp7eh\",\"family\":\"BE\",\"gloss\":\"#argument-list\",\"tags\":[\"core\",\"terminator\",\"elidable\"],\"short\":\"Borrowing and arguments list terminator.\"},\"bi\":{\"id\":\"iqamwz7uhd\",\"family\":\"BI\",\"gloss\":\"#wide-neg\",\"tags\":[\"core\",\"negation\"],\"short\":\"Wide scope negation ranging over existential variables and predicates.\"},\"bo\":{\"id\":\"9eludeaq4v\",\"family\":\"BO\",\"gloss\":\"#new-var-atom\",\"short\":\"Create a new atom predicate variable and discard previous value if any.\",\"notes\":\"Creates a predicate stating the argument is some specific and fixed atom or\\\\ngeneric value. The predicate thus have type (a).\\\\n\\\\nUsing it before words other than KI make them behave like KI variables. It\\\\ncan thus be used to define freeform predicate variables (i-) to refer to\\\\nan atom.\\\\n\"},\"boi\":{\"id\":\"aeguxusum3\",\"family\":\"BO\",\"gloss\":\"#new-var-pred\",\"short\":\"Create a new general predicate variable and discard previous value if any.\",\"notes\":\"This predicate can have arbitrary arguments, which will be constrainted by\\\\nthe rest of the sentence.\\\\n\\\\nWhen used before KI, have the same meaning as {bo} as all KI are expected\\\\nto have type (a).\\\\n\"},\"mi\":{\"id\":\"unfcuerxgm\",\"family\":\"MI\",\"short\":\"[E:tce* man] is I/me/a speaker/author.\",\"gloss\":\"me\"},\"mo\":{\"id\":\"zjytqy23pq\",\"family\":\"MI\",\"short\":\"[E:tce* man] is you, a listener.\",\"gloss\":\"you\"},\"mio\":{\"id\":\"itsqhv9xao\",\"family\":\"MI\",\"short\":\"Every member of [E:tco* man] is either I/a speaker/author; or you, a listener; and\\\\ncontains at least one of each.\\\\n\",\"gloss\":\"inclusive-we\"},\"mie\":{\"id\":\"9swjxu2mjz\",\"family\":\"MI\",\"short\":\"Every member of [E:tco* man] is either I/a speaker/author; or something that\\\\nis neither a speaker or listener; and contains at least one of each.\\\\n\",\"gloss\":\"exclusive-we\"},\"me\":{\"id\":\"ahgbyzu6xy\",\"family\":\"MI\",\"gloss\":\"the\",\"short\":\"[E:ma] is something that the speaker particularily have in mind.\\\\n\"},\"ji\":{\"id\":\"uqb3n5070a\",\"family\":\"JI\",\"gloss\":\"#cardinal\",\"tags\":[\"terminator\",\"number\",\"set\"],\"transitive\":true,\"short\":\"Cardinal number terminator. The preceding number have definition:\\\\\\\\\\\\n[E:tce* a] is (a group of) [number] things satisfying [A:(tca a)].\\\\\\\\\\\\nThe number must be a natural number (non zero positive integer).\\\\n\"},\"jie\":{\"id\":\"uvvfj77x9f\",\"family\":\"JI\",\"gloss\":\"#abstract-number\",\"tags\":[\"terminator\",\"number\",\"elidable\"],\"transitive\":true,\"short\":\"Abstract number terminator. The preceding number have definition:\\\\\\\\\\\\n[E:tce gan] is the number [number] times [A:tce gan] (default: 1).\\\\n\"},\"jia\":{\"id\":\"dnj7gskeg7\",\"family\":\"JI\",\"gloss\":\"#raw-cardinal\",\"tags\":[\"terminator\",\"number\",\"set\"],\"transitive\":true,\"short\":\"Raw cardinal number terminator. The preceding number have definition:\\\\\\\\\\\\n[E:tce* a] is (a group of) [number] things satisfying [A:(a)].\\\\\\\\\\\\nThe number must be a natural number (non zero positive integer).\\\\n\"},\"jio\":{\"id\":\"83fvb9onn2\",\"family\":\"JI\",\"gloss\":\"#universal-cardinal\",\"tags\":[\"terminator\",\"number\",\"set\"],\"transitive\":true,\"short\":\"Universal cardinal number terminator. The preceding number have definition:\\\\\\\\\\\\n[E:tce* a] is (a group of) the only [number] things satisfying [A:(tca a)].\\\\\\\\\\\\nThe number must be a natural number (non zero positive integer).\\\\n\"},\"jioa\":{\"id\":\"hvmxrbwgxx\",\"family\":\"JI\",\"gloss\":\"#raw-universal-cardinal\",\"tags\":[\"terminator\",\"number\",\"set\"],\"transitive\":true,\"short\":\"Raw universal cardinal number terminator. The preceding number have definition:\\\\\\\\\\\\n[E:tce* a] is (a group of) the only [number] things satisfying [A:(a)].\\\\\\\\\\\\nThe number must be a natural number (non zero positive integer).\\\\n\"},\"jiu\":{\"id\":\"xtles9edl2\",\"family\":\"JI\",\"gloss\":\"#ordinal\",\"tags\":[\"terminator\",\"number\",\"list\"],\"transitive\":true,\"short\":\"Ordinal number terminator. The preceding number have definition:\\\\\\\\\\\\n[E:tca a] is the [number]th member of sequence [A:blu a].\\\\\\\\\\\\nThe number must be a natural number (non zero positive integer).\\\\n\"},\"ju\":{\"id\":\"pasttlpzrh\",\"family\":\"JO\",\"gloss\":\"#base\",\"tags\":[\"number\",\"separator\"],\"short\":\"Base separator. Base is defined using the last allowed digit.\"},\"jo\":{\"id\":\"1hqmjyuznz\",\"family\":\"JO\",\"gloss\":\"#frac-sep\",\"tags\":[\"number\",\"separator\"],\"short\":\"Fractional part separator. Separate the integer part from the excess beyond\\\\nthe integer part.\\\\n\"},\"joi\":{\"id\":\"hop8n6mgoa\",\"family\":\"JO\",\"gloss\":\"#frac-sep-neg\",\"tags\":[\"number\",\"separator\"],\"short\":\"Negative fractional part separator. Separate the integer part from the excess beyond\\\\nthe integer part, and indicates that the number is negative.\\\\n\"},\"ja\":{\"id\":\"asckk59auo\",\"family\":\"JA\",\"gloss\":\"#repeating\",\"tags\":[\"number\",\"separator\"],\"short\":\"Repeating part separator. Inside a fractional part starts a string of\\\\ndigits that repeat infinitely.\\\\n\"},\"je\":{\"id\":\"lxvv3shd2h\",\"family\":\"JE\",\"gloss\":\"#magnitude\",\"tags\":[\"number\",\"separator\"],\"short\":\"Magnitude part separator. Number is multiplied by base^magnitude.\\\\n\"},\"jei\":{\"id\":\"fkgaal9xfc\",\"family\":\"JE\",\"gloss\":\"#magnitude-neg\",\"tags\":[\"number\",\"separator\"],\"short\":\"Negative magnitude part separator. Number is multiplied by base^(-magnitude).\\\\n\"},\"ti\":{\"id\":\"ivcpysqf4j\",\"family\":\"TI\",\"short\":\"Digit 0\",\"gloss\":\"0\",\"tags\":[\"digit\",\"number\"]},\"te\":{\"id\":\"2oobzn2l6h\",\"family\":\"TI\",\"short\":\"Digit 1\",\"gloss\":\"1\",\"tags\":[\"digit\",\"number\"]},\"ta\":{\"id\":\"byl153scbe\",\"family\":\"TI\",\"short\":\"Digit 2\",\"gloss\":\"2\",\"tags\":[\"digit\",\"number\"]},\"to\":{\"id\":\"ahfrldpv68\",\"family\":\"TI\",\"short\":\"Digit 3\",\"gloss\":\"3\",\"tags\":[\"digit\",\"number\"]},\"tu\":{\"id\":\"p7eyosrgae\",\"family\":\"TI\",\"short\":\"Digit 4\",\"gloss\":\"4\",\"tags\":[\"digit\",\"number\"]},\"tia\":{\"id\":\"hwnppc9ghm\",\"family\":\"TI\",\"short\":\"Digit 5\",\"gloss\":\"5\",\"tags\":[\"digit\",\"number\"]},\"tie\":{\"id\":\"mgrqxslqve\",\"family\":\"TI\",\"short\":\"Digit 6\",\"gloss\":\"6\",\"tags\":[\"digit\",\"number\"]},\"tio\":{\"id\":\"1mqghjrvry\",\"family\":\"TI\",\"short\":\"Digit 7\",\"gloss\":\"7\",\"tags\":[\"digit\",\"number\"]},\"tiu\":{\"id\":\"ghcbnijzcv\",\"family\":\"TI\",\"short\":\"Digit 8\",\"gloss\":\"8\",\"tags\":[\"digit\",\"number\"]},\"tei\":{\"id\":\"shcfpcezrg\",\"family\":\"TI\",\"short\":\"Digit 9\",\"gloss\":\"9\",\"tags\":[\"digit\",\"number\"]},\"tea\":{\"id\":\"wde3jzgicf\",\"family\":\"TI\",\"short\":\"Digit A\",\"gloss\":\"A\",\"tags\":[\"digit\",\"number\"]},\"teo\":{\"id\":\"7ik9nhaqhb\",\"family\":\"TI\",\"short\":\"Digit B\",\"gloss\":\"B\",\"tags\":[\"digit\",\"number\"]},\"teu\":{\"id\":\"fykhc8yfxl\",\"family\":\"TI\",\"short\":\"Digit C\",\"gloss\":\"C\",\"tags\":[\"digit\",\"number\"]},\"tai\":{\"id\":\"xqnikwdrx3\",\"family\":\"TI\",\"short\":\"Digit D\",\"gloss\":\"D\",\"tags\":[\"digit\",\"number\"]},\"tae\":{\"id\":\"tcdujabqlx\",\"family\":\"TI\",\"short\":\"Digit E\",\"gloss\":\"E\",\"tags\":[\"digit\",\"number\"]},\"tao\":{\"id\":\"rvtqoqug7a\",\"family\":\"TI\",\"short\":\"Digit F\",\"gloss\":\"F\",\"tags\":[\"digit\",\"number\"]},\"ca\":{\"id\":\"qgitj7lmtu\",\"family\":\"CA\",\"short\":\"Starts grammatically correct eberban quote. [E:tca skan] is text [quote].\",\"gloss\":\"#quote-start\"},\"cai\":{\"id\":\"m2tk0zmvgh\",\"family\":\"CAI\",\"short\":\"Ends grammatically correct eberban quote.\",\"gloss\":\"#quote-end\",\"tags\":[\"terminator\"]},\"ce\":{\"id\":\"qd380clfxd\",\"family\":\"CE\",\"short\":\"Quote next word. [E:tca skan] is word [word].\",\"gloss\":\"#word-quote\"},\"cei\":{\"id\":\"acauojxxsk\",\"family\":\"CE\",\"short\":\"[E:tca man] is the family of word [word].\",\"gloss\":\"#family-quote\",\"nodes\":\"TODO: Add predicates to manipulate language concepts.\\\\n\"},\"co\":{\"id\":\"upxio5nkc0\",\"family\":\"CO\",\"short\":\"[E:tca skan] is a quote of an arbitrary string.\",\"gloss\":\"#foreign-quote\"},\"coi\":{\"id\":\"j6cqu8p0dd\",\"family\":\"COI\",\"short\":\"[E:tca skan] is a quote of an arbitrary string which is skipped by the speaker/author.\",\"gloss\":\"#skipped-foreign-quote\"},\"cu\":{\"id\":\"spjmtjh1al\",\"family\":\"CU\",\"gloss\":\"#erase\",\"short\":\"Erase the currently sentence/defintion.\\\\nUsed when a mistake is made to redo the sentence/definition.\\\\\"\\\\n\"},\"za\":{\"id\":\"4hiwgkyaqe\",\"family\":\"ZI\",\"gloss\":\"#named\",\"short\":\"[E:tce a] is named after the E place of the following predicate.\",\"notes\":\"Another place can be selected by adding a SE particle between {za} and the\\\\npredicate.\\\\n\"},\"zai\":{\"id\":\"bzmsfmniyb\",\"family\":\"ZI\",\"gloss\":\"#ident\",\"short\":\"[E:ma] is the atom representing the E place of the following predicate.\",\"note\":\"Another place can be selected by adding a SE particle between {zai} and the\\\\npredicate. Using {zai} before a specific predicate will always yield the\\\\nsame unique atom.\\\\n\\\\nIt is mainly used to create identifiers used as map keys (see {kce}).\\\\n\"},\"pa\":{\"id\":\"awzbv8iu8c\",\"family\":\"PA\",\"gloss\":\"#assert\",\"short\":\"Starts an assertive sentence, that the speaker asserts is true.\"},\"pahu\":{\"id\":\"x6uy2h6mvl\",\"family\":\"PA\",\"gloss\":\"#import\",\"short\":\"Import another text represented by the [E:tce* skan] place of this scope.\\\\nImports allows to make texts defining non-standard vocabulary about a subject,\\\\nso that it can be used anytime someone wants to talk about this subject.\\\\nSuch subjects are advanced physics, chemistry or maths for example.\\\\n\",\"notes\":\"TODO: Define how the represented text is resolved.\"},\"poi\":{\"id\":\"ici1wrui6g\",\"family\":\"PO\",\"gloss\":\"#question\",\"short\":\"Start a question definition, the arguments being the unknown informations.\"},\"di\":{\"id\":\"my7irg3svn\",\"family\":\"DI\",\"gloss\":\"#attention-focus\",\"short\":\"Attention focus: the listener should be extra attentive to the following word.\\\\nMaybe it would be especially prone to confusion?\\\\n\"},\"die\":{\"id\":\"qoterl6gxk\",\"family\":\"DI\",\"gloss\":\"#contrastive-focus\",\"short\":\"Contrastive focus: It\\'s that thing and not something else that was expected.\\\\n\"},\"dia\":{\"id\":\"safkce8biy\",\"family\":\"DI\",\"gloss\":\"#newsworthiness focus\",\"short\":\"Newsworthiness focus: Marks the part of the sentence containing the most\\\\nimportant new information.\\\\n\"},\"de\":{\"id\":\"np9l6evbth\",\"family\":\"DE\",\"gloss\":\"#interjection\",\"short\":\"Attach a single predicate that acts as an interjection.\"},\"dei\":{\"id\":\"fbxzqmrleb\",\"family\":\"DE\",\"gloss\":\"#metadata\",\"short\":\"Attached word is a metadata tag / hashtag.\"},\"da\":{\"id\":\"1us2czwmre\",\"family\":\"DA\",\"gloss\":\"(\",\"short\":\"Starts parenthetical note.\"},\"dai\":{\"id\":\"cie8dryois\",\"family\":\"DAI\",\"gloss\":\")\",\"tags\":[\"terminator\"],\"short\":\"Ends parenthetical note.\"},\"du\":{\"id\":\"jjo3ibjqoy\",\"family\":\"DU\",\"gloss\":\"#paragraph\",\"short\":\"Marks a new paragraph/section/change of subject.\"},\"bu\":{\"id\":\"pyzvhbntb5\",\"family\":\"BU\",\"gloss\":\"#list-separator\",\"tags\":[\"list\"],\"short\":\"List separator.\"},\"buhu\":{\"id\":\"iquyczidl4\",\"family\":\"BU\",\"gloss\":\"#list-erased\",\"tags\":[\"list\"],\"short\":\"Erase the current list item.\"},\"vari\":{\"id\":\"ffdtxzmfbd\",\"family\":\"R\",\"gloss\":\"and\",\"tags\":[\"connective\"],\"short\":\"True if both [E:()] and [A:()] are true.\",\"notes\":\"It is often simpler to use {vi/fi}.\\\\n\",\"definition\":\"po vari ge ga be\\\\nge vi ga\\\\n\"},\"vare\":{\"id\":\"ysh546fklz\",\"family\":\"R\",\"gloss\":\"or\",\"tags\":[\"connective\"],\"short\":\"True if [E:()] or [A:()] or both is true.\",\"definition\":\"po vare ge ga be\\\\nbi ma\\\\n  vi bi ge\\\\n  fi bi ga\\\\n\"},\"varu\":{\"id\":\"eczhmrmkqd\",\"family\":\"R\",\"gloss\":\"if\",\"tags\":[\"connective\"],\"short\":\"If [E:()] is then [A:()] (default: true) is true, otherwise [O:()]\\\\n(default: true) is true.\\\\n\",\"definition\":\"po varu ge ga be\\\\nvare\\\\n  va vari\\\\n    ve ge\\\\n    fa ga\\\\n    vei\\\\n  fe vari\\\\n    ve bi ge\\\\n    fa go\\\\npoia varu mai\\\\npoio varu mai\\\\n\"},\"kidvo\":{\"id\":\"3sqq5pyzms\",\"family\":\"R\",\"gloss\":\"transitive-rel\",\"short\":\"[E:a] and [A:a] satisfy relation [O:(a,a)] transitively.\\\\n\",\"definition\":\"po kidvo ke ka go be\\\\nvare\\\\n  vie ke go ka\\\\n  fia bo ki\\\\n    vi ke go ki\\\\n    fi ki kidvo\\\\n      va ka\\\\n      fio go\\\\n\"},\"tcui\":{\"id\":\"g3quw0kqyl\",\"family\":\"R\",\"gloss\":\"set-all-raw\",\"tags\":[\"set\",\"axiom\"],\"short\":\"[E:ma] is the (non-empty) set of all things that individualy satisfy [A:(a)].\\\\n\",\"definition\":\"po e tcui pi be\\\\nma\\\\n  vi boi tcui\\\\n  fi boi tcie\\\\n  fi mae\\\\n    ve gi be varu\\\\n      vie gi mai\\\\n      fia mae\\\\n        ve ki be varu\\\\n          vie ki ma\\\\n          fie ki mua\\\\n            ma\\\\n            vi bo ke tcui gi\\\\n            fi mae\\\\n              ve ka be mai\\\\n                vie ka tcie ke\\\\n                fie ka gi\\\\npi e tcui pi\\\\n\"},\"tcie\":{\"id\":\"rcpkbwycm6\",\"family\":\"R\",\"gloss\":\"set-member-raw\",\"tags\":[\"set\",\"axiom\"],\"short\":\"[E:a] is a member of set [A:tcui a].\\\\n\",\"definition\":\"See definition of tcui.\"},\"tcia\":{\"id\":\"p8mdb3rcqw\",\"family\":\"R\",\"gloss\":\"subset\",\"tags\":[\"set\"],\"short\":\"[E:tcui a] is a subset of [A:tcui a].\\\\n\",\"definition\":\"po tcia ke ka be\\\\nmae\\\\n  ve ki be varu \\\\n    vie ki tcie ke\\\\n    fia ki tcie ka\\\\n\"},\"tcei\":{\"id\":\"pwfckqjpdu\",\"family\":\"R\",\"gloss\":\"set-some-raw\",\"tags\":[\"set\"],\"short\":\"[E:tcui a] is a (non-empty) set of some things that individualy satisfy [A:(a)].\\\\n\",\"definition\":\"po tcie ke gia be\\\\nke tcia tcui gia\\\\n\"},\"tcai\":{\"id\":\"xemhvhqiom\",\"family\":\"R\",\"gloss\":\"set-one-raw\",\"tags\":[\"set\"],\"short\":\"[E:tcui a] is a set containing exactly one member which satisfy [A:(a)].\\\\n\",\"definition\":\"po tcia ke gia be\\\\nma\\\\n  vi ke tcei gia\\\\n  fi bi ma\\\\n    vi bo ka tcie ke\\\\n    fi bo ko bi ka\\\\n    fi ko tcie ke\\\\n\"},\"tcoi\":{\"id\":\"zlgjmfoqtb\",\"family\":\"R\",\"gloss\":\"set-many-raw\",\"tags\":[\"set\"],\"short\":\"[E:tcui a] is a set of at least 2 things that individualy satisfy [A:(a)].\\\\n\",\"definition\":\"po tcia ke gia be\\\\nma\\\\n  vi ke tcei gia\\\\n  fi bo ka tcie ke\\\\n  fi bo ko bi ka\\\\n  fi ko tcie ke  \\\\n\"},\"tca\":{\"id\":\"8w1jwffzur\",\"family\":\"R\",\"gloss\":\"set-one\",\"tags\":[\"set\"],\"short\":\"[E:tcai a] is a set containing exactly one member, and satisfy [A:(tcai a)].\\\\n\",\"definition\":\"po tca ke gia be\\\\nke se tcai gia\\\\n\"},\"tcu\":{\"id\":\"pvhoor5xeb\",\"family\":\"R\",\"gloss\":\"set-all\",\"tags\":[\"set\"],\"short\":\"[E:tcui a] is the (non-empty) set of all things that individualy satisfy [A:(tca a)].\\\\n\",\"definition\":\"po tcu ke gia be\\\\nke tcui\\\\n  via be ba tcie tca gia\\\\n\"},\"tce\":{\"id\":\"tqlnlqxzsn\",\"family\":\"R\",\"gloss\":\"set-some\",\"tags\":[\"set\"],\"short\":\"[E:tcei a] is a (non-empty) set of some things that individualy satisfy [A:(tca a)].\\\\n\",\"definition\":\"po tce ke gia be\\\\nke tcei\\\\n  via be ba tcie tca gia\\\\n\"},\"tco\":{\"id\":\"sjmnh7xxpc\",\"family\":\"R\",\"gloss\":\"set-many\",\"tags\":[\"set\"],\"short\":\"[E:tcoi a] is a set of at least 2 things that individualy satisfy [A:(tca a)].\\\\n\",\"definition\":\"po tco ke gia be\\\\nke tcoi\\\\n  via be ba tcie tca gia\\\\n\"},\"tci\":{\"id\":\"fnw0vvx5ii\",\"family\":\"R\",\"gloss\":\"set-member\",\"tags\":[\"set\"],\"short\":\"[E:tca a] is a member of set [A:tce a].\",\"definition\":\"po tci ke ka be\\\\nke tca tcie ka\\\\n\"},\"dji\":{\"id\":\"ryx470pn2x\",\"family\":\"R\",\"gloss\":\"set-union\",\"tags\":[\"set\"],\"short\":\"[E:tce a] is the union of sets [A:tce a] and [O:tce a].\",\"definition\":\"po dji ke ka ko be\\\\nke tcu\\\\n  va ki be vare\\\\n    ve ki tci ka\\\\n    fa ki tci ko\\\\n\"},\"dje\":{\"id\":\"2yen5k9sgq\",\"family\":\"R\",\"gloss\":\"set-intersection\",\"tags\":[\"set\"],\"short\":\"[E:tce a] is the intersection of sets [A:tce a] and [O:tce a].\",\"definition\":\"po dje ke ka ko be\\\\nke tcu\\\\n  va ki be vari\\\\n    ve ki tci ka\\\\n    fa ki tci ko\\\\n\"},\"dja\":{\"id\":\"fna9x09it8\",\"family\":\"R\",\"gloss\":\"set-diff\",\"tags\":[\"set\"],\"short\":\"[E:tce a] is the difference between sets [A:tce a] and [O:tce a].\",\"definition\":\"po dja ke ka ko be\\\\nke tcu\\\\n  va ki be vari\\\\n    ve ki tci ka\\\\n    fa bi ki tci ko\\\\n\"},\"djo\":{\"id\":\"zkzu7uyhit\",\"family\":\"R\",\"gloss\":\"set-local-max\",\"tags\":[\"set\"],\"short\":\"[E:tce a] is the locally largest set that satisfy [A:(tce a)].\",\"definition\":\"po djo ke gia be\\\\nma\\\\n  vi ke gia\\\\n  fi bi bo ka\\\\n    vi ka bi ke\\\\n    fi ka gia\\\\n    fi ke tcia ka\\\\n\"},\"dju\":{\"id\":\"jw7zewcwos\",\"family\":\"R\",\"gloss\":\"set-local-min\",\"tags\":[\"set\"],\"short\":\"[E:tce a] is the locally smallest set that satisfy [A:(tce a)].\",\"definition\":\"po djo ke gia be\\\\nma\\\\n  vi ke gia\\\\n  fi bi bo ka\\\\n    vi ka bi ke\\\\n    fi ka gia\\\\n    fi ka tcia ke\\\\n\"},\"kin\":{\"id\":\"hypka57wfp\",\"family\":\"R\",\"gloss\":\"par\",\"short\":\"[E:ma] is a pair made of left component [A:a] and right component [O:o].\\\\n\",\"definition\":\"po e kin pi be\\\\nma\\\\n  vi boi kin\\\\n  fi mae\\\\n    ve ka be mae \\\\n      ve ko be\\\\n      ma\\\\n       vi ki be ki ma kin \\\\n         va ka\\\\n         fo ko\\\\n         fi bi ma\\\\n           ve bi ki\\\\n           fe kin\\\\n             va ka\\\\n             fo ko\\\\npi e kin pi\\\\n\"},\"e zai pe\":{\"id\":\"hgqsgbly3t\",\"family\":\"C2\",\"gloss\":\"ident\",\"short\":\"[E:ma] is an identifier/name made from property [A:(a)].\\\\n\",\"definition\":\"po ezaipe ke gi be\\\\nma\\\\n  vi ke kin \\\\n    va ezaipe ezaipe\\\\n    fo gi vi\\\\n    fi vare\\\\n      vie gi mai\\\\n      fie bi gi mai\\\\n\"},\"blur\":{\"id\":\"nro51pm4q2\",\"family\":\"R\",\"gloss\":\"empty-list\",\"tags\":[\"list\"],\"short\":\"[E:ma] is the empty list.\\\\n\"},\"blu\":{\"id\":\"4tuaiv3x0b\",\"family\":\"R\",\"gloss\":\"list\",\"tags\":[\"list\"],\"short\":\"[E:blun] is a list of things all satisfying [A:(a)].\\\\n\",\"notes\":\"{bu} is syntaxic sugar to make lists.\\\\n\"},\"bla\":{\"id\":\"6oxelxxwxd\",\"family\":\"R\",\"gloss\":\"list-lfold\",\"tags\":[\"list\"],\"short\":\"Left folds list [E:blu a] with initial [A:b] and final [O:b] carries by\\\\napplying predicate [U:(b,b,a)] in first to last order.\\\\n\"},\"blai\":{\"id\":\"zblktnj4an\",\"family\":\"R\",\"gloss\":\"list-rfold\",\"tags\":[\"list\"],\"short\":\"Right folds list [E:blu a] with initial [A:b] and final [O:b] carries by\\\\napplying predicate [U:(b,b,a)] in last to first order.\\\\n\"},\"ble\":{\"id\":\"ghp1rirgb6\",\"family\":\"R\",\"gloss\":\"list-concat\",\"tags\":[\"list\"],\"short\":\"[E:blu a] is the concatenation of lists [A:blu a] and [O:blu a].\\\\n\"},\"blo\":{\"id\":\"zp415dp0q0\",\"family\":\"R\",\"gloss\":\"list-set-raw\",\"tags\":[\"list\",\"set\"],\"short\":\"[E:tce a] is the set of all the elements in list [A:blu a].\\\\n\"},\"bli\":{\"id\":\"t4oc9rx6i4\",\"family\":\"R\",\"gloss\":\"list-set\",\"tags\":[\"list\",\"set\"],\"short\":\"[E:tce a] is the union of all sets in list [A:blu tce a].\\\\n\"},\"kcin\":{\"id\":\"wuklqbdxyk\",\"family\":\"R\",\"gloss\":\"map\",\"tags\":[\"map\"],\"short\":\"[E:ma] is a map.\\\\n\"},\"kcil\":{\"id\":\"4wxxlvhj9q\",\"family\":\"R\",\"gloss\":\"empty-map\",\"tags\":[\"map\"],\"short\":\"[E:kcin] is the empty map.\\\\n\"},\"kce\":{\"id\":\"ynv5inth7z\",\"family\":\"R\",\"gloss\":\"map-entry\",\"tags\":[\"map\"],\"short\":\"[E:a] is the value in map [A:kcin] for key [O:ma].\\\\n\"},\"kcei\":{\"id\":\"wveaovosbk\",\"family\":\"R\",\"gloss\":\"context-map-entry\",\"tags\":[\"map\",\"context\"],\"short\":\"[E:a] is the value in the context map for key [A:ma].\\\\n\"},\"kcani\":{\"id\":\"pl5agvbnwb\",\"family\":\"R\",\"gloss\":\"map-remove\",\"tags\":[\"map\"],\"short\":\"[E:kcin] is obtained from [A:kcin] by removing the entry with key [O:ma].\\\\nIf [A] don\\'t have entry with key [O] then [E] = [A].\\\\n\"},\"kcoi\":{\"id\":\"f3la0vnq2j\",\"family\":\"R\",\"gloss\":\"map-insert\",\"tags\":[\"map\"],\"short\":\"[E:kcin] is obtained from [A:kcin] by inserting an entry with key [O:ma] and\\\\nvalue [U:ma]. If [A] have an entry with key [O] then it is removed to insert\\\\nthe entry with key [O] and value [U].\\\\n\"},\"kcui\":{\"id\":\"dolbat4p3o\",\"family\":\"R\",\"gloss\":\"map-update\",\"tags\":[\"map\"],\"short\":\"[E:kcin] is obtained from [A:kcin] by transforming the value of entry with\\\\nkey [O:ma] using relation [U:(a,a)]. It implies that [A] must have an entry\\\\nwith key [O].\\\\n\"},\"kca\":{\"id\":\"onzg415avk\",\"family\":\"R\",\"gloss\":\"map-list-wrapper\",\"tags\":[\"map\",\"list\"],\"short\":\"[E:kcin] represents a map that can be optained from [A:kcin] by applying the\\\\nlist of transformations [O:blu ()].\\\\n\"},\"kcan\":{\"id\":\"eogkr6aqeg\",\"family\":\"R\",\"gloss\":\"map-list-remove\",\"tags\":[\"map\",\"list\"],\"short\":\"{kca} operation: remove entry with key [E:ma].\\\\n\"},\"kco\":{\"id\":\"obhtxxk03b\",\"family\":\"R\",\"gloss\":\"map-list-insert\",\"tags\":[\"map\",\"list\"],\"short\":\"{kca} operation: insert entry with key [E:ma] and value [A:a].\\\\n\"},\"kcu\":{\"id\":\"oyk8ho9c8a\",\"family\":\"R\",\"gloss\":\"map-list-update\",\"tags\":[\"map\",\"list\"],\"short\":\"{kca} operation: transform entry with key [E:ma] with value relation\\\\n(old,new) [A:(a,a)].\\\\n\"},\"kcar\":{\"id\":\"uqfvqmic1a\",\"family\":\"R\",\"gloss\":\"context-map-list-wrapper\",\"tags\":[\"map\",\"list\",\"context\"],\"short\":\"Transformations [E:blu ()] are applied on the context before it is used to evaluate [A:()].\\\\n\"},\"din\":{\"id\":\"nibp9gygau\",\"family\":\"R\",\"gloss\":\"instant\",\"tags\":[\"time\"],\"short\":\"[E:ma] is an instant (digraph node).\\\\n\"},\"dini\":{\"id\":\"3qex7khuq6\",\"family\":\"R\",\"gloss\":\"time-arc\",\"tags\":[\"time\"],\"short\":\"[E:ma] is an instant (digraph node).\\\\n\"},\"dinu\":{\"id\":\"y7adb2kwfz\",\"family\":\"R\",\"gloss\":\"time-span\",\"tags\":[\"time\"],\"short\":\"There exist an path/span [O:blu din] from node [E:din] to node [A:din].\\\\n\"},\"den\":{\"id\":\"dc8ilrq3mf\",\"family\":\"R\",\"gloss\":\"update-present\",\"tags\":[\"time\"],\"short\":\"[E:()] is evaluated with a more recent present.\\\\n\"},\"pane\":{\"id\":\"vimwo5soyj\",\"family\":\"R\",\"gloss\":\"inner-context\",\"tags\":[\"context\"],\"short\":\"[E:ma] is the context exposed to a predicate when it evaluated by [A:(())].\\\\n\"},\"del\":{\"id\":\"umuuampnqb\",\"family\":\"R\",\"gloss\":\"present-span\",\"tags\":[\"time\"],\"short\":\"[E:dinu] is the present time span.\\\\n\"},\"zvi\":{\"id\":\"uulyqjxb0p\",\"family\":\"R\",\"gloss\":\"event-span\",\"tags\":[\"time\"],\"short\":\"[E:dinu] is a time span shared by all events of [A:()].\\\\n\"},\"zvin\":{\"id\":\"axofygrppp\",\"family\":\"R\",\"gloss\":\"event-apply\",\"tags\":[\"time\"],\"short\":\"Time span [E:dinu] contains context time span.\\\\n\"},\"zvil\":{\"id\":\"gnr18x6ohk\",\"family\":\"R\",\"gloss\":\"context-span\",\"tags\":[\"time\",\"context\"],\"short\":\"[E:dinu] is the context time span.\\\\n\"},\"zvan\":{\"id\":\"dv3jdkkpcp\",\"family\":\"R\",\"gloss\":\"necessary-helper\",\"tags\":[\"time\"],\"short\":\"For all time span x that contains time span [A:dinu] (default: context time span), either:\\\\n- [E:(dinu)] evaluated with x is true\\\\n- [E] is true if evaluated with a time span containing x\\\\n\"},\"sel\":{\"id\":\"vqajm3pj2j\",\"family\":\"R\",\"gloss\":\"possible-meets\",\"tags\":[\"time\"],\"short\":\"It is possible that [E:()] meets time span [A:dinu] (default: context time span).\\\\n\"},\"sen\":{\"id\":\"budfwlwobc\",\"family\":\"R\",\"gloss\":\"necessary-meets\",\"tags\":[\"time\"],\"short\":\"It is necessary that [E:()] meets time span [A:dinu] (default: context time span).\\\\n\"},\"sal\":{\"id\":\"bwjgs2afh9\",\"family\":\"R\",\"gloss\":\"possible-starts\",\"tags\":[\"time\"],\"short\":\"It is possible that [E:()] starts time span [A:dinu] (default: context time span).\\\\n\"},\"san\":{\"id\":\"g2nigdhlup\",\"family\":\"R\",\"gloss\":\"necessary-starts\",\"tags\":[\"time\"],\"short\":\"It is necessary that [E:()] starts time span [A:dinu] (default: context time span).\\\\n\"},\"sol\":{\"id\":\"zjxjllllah\",\"family\":\"R\",\"gloss\":\"possible-finishes\",\"tags\":[\"time\"],\"short\":\"It is possible that [E:()] finishes time span [A:dinu] (default: context time span).\\\\n\"},\"son\":{\"id\":\"lv8no7q8p9\",\"family\":\"R\",\"gloss\":\"necessary-finishes\",\"tags\":[\"time\"],\"short\":\"It is necessary that [E:()] finishes time span [A:dinu] (default: context time span).\\\\n\"},\"sul\":{\"id\":\"axtm6ugdmg\",\"family\":\"R\",\"gloss\":\"possible-met-by\",\"tags\":[\"time\"],\"short\":\"It is possible that [E:()] is met by time span [A:dinu] (default: context time span).\\\\n\"},\"sun\":{\"id\":\"zzddsvsokx\",\"family\":\"R\",\"gloss\":\"necessary-met-by\",\"tags\":[\"time\"],\"short\":\"It is necessary that [E:()] is met by time span [A:dinu] (default: context time span).\\\\n\"},\"siel\":{\"id\":\"lutdquie7v\",\"family\":\"R\",\"gloss\":\"possible-before\",\"tags\":[\"time\"],\"short\":\"It is possible that [E:()] is before time span [A:dinu] (default: context time span).\\\\n\"},\"sien\":{\"id\":\"l4idmhyhtm\",\"family\":\"R\",\"gloss\":\"necessary-before\",\"tags\":[\"time\"],\"short\":\"It is necessary that [E:()] is before time span [A:dinu] (default: context time span).\\\\n\"},\"sial\":{\"id\":\"kv6dcgd35e\",\"family\":\"R\",\"gloss\":\"possible-contains\",\"tags\":[\"time\"],\"short\":\"It is possible that [E:()] contains time span [A:dinu] (default: context time span).\\\\n\"},\"sian\":{\"id\":\"4pwutfyqus\",\"family\":\"R\",\"gloss\":\"necessary-contains\",\"tags\":[\"time\"],\"short\":\"It is necessary that [E:()] contains time span [A:dinu] (default: context time span).\\\\n\"},\"siol\":{\"id\":\"q3d47lpfvg\",\"family\":\"R\",\"gloss\":\"possible-is-contained\",\"tags\":[\"time\"],\"short\":\"It is possible that [E:()] is contained by time span [A:dinu] (default: context time span).\\\\n\",\"notes\":\"Is equivalent to {sion}, as since E is contained in the context span\\\\nthen there is only one possible timeline. Thus it is both possible and\\\\nnecessary.\\\\n\"},\"sion\":{\"id\":\"nkyo9z7x2w\",\"family\":\"R\",\"gloss\":\"necessary-is-contained\",\"tags\":[\"time\"],\"short\":\"It is necessary that [E:()] is contained by time span [A:dinu] (default: context time span).\\\\n\",\"notes\":\"Is equivalent to {siol}, as since E is contained in the context span\\\\nthen there is only one possible timeline. Thus it is both possible and\\\\nnecessary.\\\\n\"},\"siul\":{\"id\":\"chyjdknlh3\",\"family\":\"R\",\"gloss\":\"possible-after\",\"tags\":[\"time\"],\"short\":\"It is possible that [E:()] is after time span [A:dinu] (default: context time span).\\\\n\"},\"siun\":{\"id\":\"dot0w2jln9\",\"family\":\"R\",\"gloss\":\"necessary-after\",\"tags\":[\"time\"],\"short\":\"It is necessary that [E:()] is after time span [A:dinu] (default: context time span).\\\\n\"},\"sil\":{\"id\":\"ggonkf8b9i\",\"family\":\"R\",\"gloss\":\"possible-overlaps\",\"tags\":[\"time\"],\"short\":\"It is possible that [E:()] overlaps with time span [A:dinu] (default: context time span).\\\\n\"},\"sin\":{\"id\":\"2nshmlkxd0\",\"family\":\"R\",\"gloss\":\"necessary-overlaps\",\"tags\":[\"time\"],\"short\":\"It is necessary that [E:()] overlaps with time span [A:dinu] (default: context time span).\\\\n\"},\"dan\":{\"id\":\"fkqgnv2hi2\",\"family\":\"R\",\"gloss\":\"occurs-presently\",\"tags\":[\"time\"],\"short\":\"[E:()] presently occurs.\\\\n\"},\"don\":{\"id\":\"0c5t0lkflg\",\"family\":\"R\",\"gloss\":\"occurs-anytime\",\"tags\":[\"time\"],\"short\":\"[E:()] occurs at some time (no constraint).\\\\n\"},\"doni\":{\"id\":\"qfxuso4eij\",\"family\":\"R\",\"gloss\":\"occurs-time-span\",\"tags\":[\"time\"],\"short\":\"[A:()] occurs in a time span that overlaps [E:dinu].\\\\n\"},\"pen\":{\"id\":\"rjami7df3u\",\"family\":\"R\",\"gloss\":\"physical\",\"tags\":[\"space\"],\"short\":\"[E:tca man] is a physical entity which occupies volume [A:tce man] at\\\\ninstant [O:dini].\\\\n\"},\"pan\":{\"id\":\"whi7bmezoy\",\"family\":\"R\",\"gloss\":\"context-physical\",\"tags\":[\"space\",\"context\"],\"short\":\"[E:tca man] is a physical entity which intersects with the context volume.\\\\n\"},\"peni\":{\"id\":\"7n2eqikobr\",\"family\":\"R\",\"gloss\":\"set-context-physical\",\"tags\":[\"space\"],\"short\":\"[E:tca pen] is used at the context volume to evaluate [A:()].\\\\n\"},\"penu\":{\"id\":\"5gzy2gu5a6\",\"family\":\"R\",\"gloss\":\"volume-overlap\",\"tags\":[\"space\"],\"short\":\"The volume of [E:tca pen] intersects with the volume of [A:tce pen].\\\\n\"},\"gin\":{\"id\":\"4uxuhdkbez\",\"family\":\"R\",\"gloss\":\"number-natural\",\"tags\":[\"math\",\"number\"],\"short\":\"[E:tce* man] is a natural number.\"},\"gini\":{\"id\":\"wxxmvr9zx2\",\"family\":\"R\",\"gloss\":\"succ\",\"tags\":[\"partial\",\"math\",\"number\"],\"short\":\"[E:tca ma] is the successor of [A:tca ma].\"},\"ginin\":{\"id\":\"w8gh1nggcn\",\"family\":\"R\",\"gloss\":\"zero\",\"tags\":[\"math\",\"number\"],\"short\":\"[E:tca gin] is zero.\"},\"gen\":{\"id\":\"syw83vo8hb\",\"family\":\"R\",\"gloss\":\"number-real\",\"tags\":[\"math\",\"number\"],\"short\":\"[E:tce* man] is a real number.\"},\"gan\":{\"id\":\"fwg6wbeotx\",\"family\":\"R\",\"gloss\":\"number\",\"tags\":[\"math\",\"number\"],\"short\":\"[E:tce* man] is a general purpose number.\",\"notes\":\"{gan} numbers are an extension field of {gen} (real numbers) that supports\\\\nunits like length, mass, etc.\\\\n\"},\"skan\":{\"id\":\"4u8h1cwf6p\",\"family\":\"R\",\"gloss\":\"string\",\"tags\":[\"struct\",\"string\"],\"short\":\"[E:tce* man] is a string of data.\",\"notes\":\"TODO: Improve definition and add oither predicates to interact with it.\\\\n\\\\nIt\\'s goal is to be able to manipulate both native and foreign quotes (which\\\\ncan be speakable, embeded file, etc).\\\\n\"},\"cna\":{\"id\":\"mlqkhowtl0\",\"family\":\"R\",\"gloss\":\"AND-S\",\"tags\":[\"sequence\",\"connective\"],\"short\":\"This proposition is true if all atoms in sequence [E:blu ma] satisfies property [A:(ma)].\"},\"cne\":{\"id\":\"val5msurqc\",\"family\":\"R\",\"gloss\":\"OR-S\",\"tags\":[\"sequence\",\"connective\"],\"short\":\"This proposition is true if at least one atoms in sequence [E:blu ma] satisfies property [A:(ma)].\"},\"cni\":{\"id\":\"nax6hot9qu\",\"family\":\"R\",\"gloss\":\"XOR-S\",\"tags\":[\"sequence\",\"connective\"],\"short\":\"This proposition is true if exactly [E:gin] (default: 1) atoms in sequence [E:blu ma] satisfies property [A:(ma)].\"},\"cena\":{\"id\":\"qsivboraps\",\"family\":\"R\",\"gloss\":\"AND-P0\",\"tags\":[\"sequence\",\"connective\"],\"short\":\"This proposition is true if all propositions in sequence [E:blu ()] are true.\"},\"cene\":{\"id\":\"d9fzfk4r83\",\"family\":\"R\",\"gloss\":\"OR-P0\",\"tags\":[\"sequence\",\"connective\"],\"short\":\"This proposition is true if at least one proposition in sequence [E:blu ()] is true.\"},\"ceni\":{\"id\":\"f5t4czvnac\",\"family\":\"R\",\"gloss\":\"XOR-P0\",\"tags\":[\"sequence\",\"connective\"],\"short\":\"This proposition is true if exactly [E:gin] (default: 1) proposition(s) in sequence [E:blu ()] is true.\"},\"cana\":{\"id\":\"ovzzfajdlw\",\"family\":\"R\",\"gloss\":\"AND-P1\",\"tags\":[\"sequence\",\"connective\"],\"short\":\"This proposition is true if [E:ma] satisfies all properties in sequence [A:blu (ma)].\"},\"cane\":{\"id\":\"6ksleotknl\",\"family\":\"R\",\"gloss\":\"OR-P1\",\"tags\":[\"sequence\",\"connective\"],\"short\":\"This proposition is true if [E:ma] satisfies at least one property in sequence [A:blu (ma)].\"},\"cani\":{\"id\":\"kog0cgvvza\",\"family\":\"R\",\"gloss\":\"XOR-P1\",\"tags\":[\"sequence\",\"connective\"],\"short\":\"This proposition is true if [E:ma] satisfies exactly [O:gin] (default: 1) proposition(s) in sequence [A:blu (ma)].\"},\"cona\":{\"id\":\"4aamcwbbmi\",\"family\":\"R\",\"gloss\":\"AND-P2\",\"tags\":[\"sequence\",\"connective\"],\"short\":\"This proposition is true if [E:ma] and [A:ma] satisfies all relations in sequence [O:blu (ma,ma)].\"},\"cone\":{\"id\":\"y8teg1w87d\",\"family\":\"R\",\"gloss\":\"OR-P2\",\"tags\":[\"sequence\",\"connective\"],\"short\":\"This proposition is true if [E:ma] and [A:ma] satisfies at least one relation in sequence [O:blu (ma,ma)].\"},\"coni\":{\"id\":\"6xyrpofoby\",\"family\":\"R\",\"gloss\":\"XOR-P2\",\"tags\":[\"sequence\",\"connective\"],\"short\":\"This proposition is true if [E:ma] and [A:ma] satisfies exactly [U:gin] (default: 1) relation(s) in sequence [O:blu (ma,ma)].\"},\"mone\":{\"id\":\"qt6yew5oof\",\"family\":\"R\",\"gloss\":\"<\",\"tags\":[\"maths\",\"ordering\"],\"short\":\"[E:tce* gan] is less than [A:tce* gan].\",\"notes\":\"Operate on sets of numbers. True only if all members of [E] are less than all\\\\nmembers of [A].\\\\n\"},\"mona\":{\"id\":\"ennpp99pjl\",\"family\":\"R\",\"gloss\":\">\",\"tags\":[\"maths\",\"ordering\"],\"short\":\"[E:tce* gan] is greater than [A:tce* gan].\",\"notes\":\"Operate on sets of numbers. True only if all members of [E] are less than all\\\\nmembers of [A].\\\\n\"},\"fule\":{\"id\":\"86guwrqjob\",\"family\":\"R\",\"gloss\":\"knows\",\"short\":\"[E:tce* pan] knows fact [A:()] from source [O:tce man].\"},\"dona\":{\"id\":\"iffa5o0qnw\",\"family\":\"R\",\"gloss\":\"likes\",\"tags\":[\"emotion\"],\"short\":\"[E:tce* pan] likes [A:tce* man].\"},\"jveo\":{\"id\":\"4lhxmspat4\",\"family\":\"R\",\"gloss\":\"friend\",\"tags\":[\"emotion\"],\"short\":\"[E:tce* pan] is a friend of [A:tce* pan].\"},\"kli\":{\"id\":\"wsihly4n1c\",\"family\":\"R\",\"gloss\":\"thanks\",\"tags\":[\"emotion\"],\"short\":\"[E:tce* pan] (default: speaker) thanks/is thankful to [A:tce* man]\\\\n(defaults: listener) about [O:()] being true.\\\\n\"},\"kre\":{\"id\":\"wb1zm07d82\",\"family\":\"R\",\"gloss\":\"helps\",\"short\":\"[E:tce pan] helps [A:tce ma] to satisfy property [O:(tce ma)].  \\\\n[A] is the one satisfying [O], and [E] doesn\\'t need to satisfy [O].\\\\n\"},\"vahul\":{\"id\":\"svndl4hkmc\",\"family\":\"R\",\"gloss\":\"milk\",\"short\":\"[E:tce* pan] is milk.\"},\"mian\":{\"id\":\"vgeqteao1c\",\"family\":\"R\",\"gloss\":\"cat\",\"tags\":[\"animal\"],\"short\":\"[E:tce* pan] is a cat/felid/member of family Felidae.\"},\"gla\":{\"id\":\"kmycfjjnv4\",\"family\":\"R\",\"gloss\":\"tool\",\"short\":\"[E:tce* ma] [tool] is used to make [A:()] [purpose] true.\"},\"kali\":{\"id\":\"egsqs45rsj\",\"family\":\"R\",\"gloss\":\"drinks\",\"short\":\"[E:tce* pan] drinks [E:tce* pan].\"},\"buri\":{\"id\":\"fp326p16jr\",\"family\":\"R\",\"gloss\":\"eats\",\"short\":\"[E:tce* pan] eats [A:tce* pan].\"},\"zin\":{\"id\":\"jct2wcsuqa\",\"family\":\"R\",\"gloss\":\"woman\",\"short\":\"[E:tce* pan] is a girl/woman/female (gender).\"},\"zun\":{\"id\":\"fdju08ghm9\",\"family\":\"R\",\"gloss\":\"man\",\"short\":\"[E:tce* pan] is a boy/man/male (gender).\"},\"tsae\":{\"id\":\"4w27tty2ds\",\"family\":\"R\",\"gloss\":\"creates\",\"short\":\"[E:tce pan] invents/creates/authors [A:tce* ma].\"},\"zuna\":{\"id\":\"yhzwpengy5\",\"family\":\"R\",\"gloss\":\"inspired\",\"short\":\"[E:tce* pan] is inspired by [A:tce* ma]. [A] is a source of inspiration for [A].\"},\"zvia\":{\"id\":\"pcbyhpj1jy\",\"family\":\"R\",\"gloss\":\"purpose\",\"short\":\"[E:tce pan] has goal/purpose/aims to satisfy [A:(tce pan)].\"},\"skal\":{\"id\":\"fx1mnfjs7i\",\"family\":\"R\",\"gloss\":\"computer\",\"short\":\"[E:tce* pan] is a computer.\"},\"sni\":{\"id\":\"nj03wvtsbv\",\"family\":\"R\",\"gloss\":\"greets\",\"short\":\"[E:tce* pan] (default: speaker) says hello to/greets [A:tce* pan] (default: listener).\"},\"sne\":{\"id\":\"knhmussoxm\",\"family\":\"R\",\"gloss\":\"goodbye\",\"short\":\"[E:tce* pan] (default: speaker) says goodbye to [A:tce* pan] (default: listener).\"},\"sna\":{\"id\":\"blzblpa7fo\",\"family\":\"R\",\"gloss\":\"welcomes\",\"short\":\"[E:tce* pan] (default: speaker) welcomes [A:tce* pan] (default: listener) to place [O:tce* pan].\"},\"spi\":{\"id\":\"wlkwneqcyu\",\"family\":\"R\",\"gloss\":\"says\",\"short\":\"[E:tce pan] says [A:tce* skan] to [O:tce* ma].\"},\"spua\":{\"id\":\"qwnwymrscy\",\"family\":\"R\",\"gloss\":\"home\",\"short\":\"[E:tce* pan] is a home/house/nest for [A:tce* pan].\"},\"zaro\":{\"id\":\"rzmceyzcgr\",\"family\":\"R\",\"gloss\":\"agrees\",\"short\":\"[E:tce* pan] agrees with [A:tce* pan] that [O:()] is true.\"},\"vani\":{\"id\":\"meuqg48faw\",\"family\":\"R\",\"gloss\":\"moves\",\"short\":\"[E:tce* pan] moves/goes to [A:tce* pan] from [O:tce* pan].\"},\"gza\":{\"id\":\"3qi3tvpegs\",\"family\":\"R\",\"gloss\":\"agentive cause\",\"short\":\"[E:tce* pan] is an agentive cause of [A:()] being true.\"},\"kini\":{\"id\":\"macaegnams\",\"family\":\"R\",\"gloss\":\"learns\",\"short\":\"[E:tce* pan] learns/studies fact [A:()].\"},\"seru\":{\"id\":\"0pi0sos7qt\",\"family\":\"R\",\"gloss\":\"about\",\"short\":\"[E:()] is about subject [A:tce* man].\",\"notes\":\"Predicates inside [E] can register subjects using {serun}.\\\\n\"},\"serun\":{\"id\":\"dxlam79kma\",\"family\":\"R\",\"gloss\":\"register-subject\",\"short\":\"Register subject [E:tce* man] in the context.\",\"tags\":[\"context\"],\"notes\":\"Goes in pair with {seru}. If context contains an entry with key {zai serun},\\\\nthis predicate states that [E] is a subset of the value of this entry. If\\\\nthe context don\\'t contain such entry then nothing is stated.\\\\n\\\\nWrapping with {seru} will setup this entry in the context it provides to its\\\\nE place and find a \\\\\"smallest\\\\\" set that makes E true, and check that its A\\\\nplace is a subset of it.\\\\n\"},\"snai\":{\"id\":\"q0vx1idoej\",\"family\":\"R\",\"gloss\":\"works\",\"short\":\"[E:tce pan] labors/works by satisfying property [A:(tce pan)].\"},\"ber\":{\"id\":\"vz1h8ccnmh\",\"family\":\"R\",\"gloss\":\"eberbanic\",\"short\":\"[E:tce* man] reflects this language (eberban).\"},\"pre\":{\"id\":\"nzls6wh1l5\",\"family\":\"R\",\"gloss\":\"person\",\"short\":\"[E:tce* pan] is a person.\"},\"pra\":{\"id\":\"scjlbqkhj0\",\"family\":\"R\",\"gloss\":\"loves\",\"tags\":[\"emotion\"],\"short\":\"[E:tce* pan] loves [A:tce* man].\"},\"vire\":{\"id\":\"wii5ktrkfq\",\"family\":\"R\",\"gloss\":\"visits\",\"short\":\"[E:tce* pan] visits [E:tce* pan].\"},\"peol\":{\"id\":\"zw3nafu6xr\",\"family\":\"R\",\"gloss\":\"city\",\"short\":\"[E:tce* pan] is a town/city.\"},\"zdir\":{\"id\":\"nqrmfwpnrs\",\"family\":\"R\",\"short\":\"[E:tce man] is amusing/entertaining/fun according to [A:tce* pan] (default: speaker)\\\\nin property [O:(tce man)].\\\\n\",\"gloss\":\"amusing\"},\"gli\":{\"id\":\"r7wbdwqgm0\",\"family\":\"R\",\"gloss\":\"happy\",\"short\":\"[E:tce* pan] is happy about [A:()] being true.\"},\"siro\":{\"id\":\"xgbqoobjvr\",\"family\":\"R\",\"gloss\":\"translation\",\"short\":\"[E:tce* skar] (source) has translation [A:tce* skar] (result).\"},\"tcuin\":{\"id\":\"w85kmshrmv\",\"family\":\"R\",\"short\":\"[E:tce* pan] is a tree.\",\"gloss\":\"tree\"},\"jnaor\":{\"id\":\"7i380kaavf\",\"family\":\"R\",\"gloss\":\"wild\",\"short\":\"[E:tce* pan] is wild/untamed.\"},\"jine\":{\"id\":\"isleimajzc\",\"family\":\"R\",\"gloss\":\"want\",\"short\":\"[E:tce* pan] desires/wants/wishes [A:()].\"},\"jali\":{\"id\":\"ch2b852dq7\",\"family\":\"R\",\"gloss\":\"intends\",\"short\":\"[E:tce pan] intends to satisfy [A:(tce pan)].\"},\"fuher\":{\"id\":\"odaizkibaq\",\"family\":\"R\",\"gloss\":\"fly\",\"short\":\"[E:tce* pan] flies (in air/space).\"},\"folin\":{\"id\":\"ueqbcavbvq\",\"family\":\"R\",\"gloss\":\"airplane\",\"short\":\"[E:tce* pan] is an airplane.\"},\"jleo\":{\"id\":\"l2gx6yauc8\",\"family\":\"R\",\"gloss\":\"motivated\",\"short\":\"[E:tce* pan] is motivated to make [A:()] true by [O:tce* man] (motivation).\",\"notes\":\"TODO: Define what a motivation is. someone else? propositions?\\\\n\"},\"zuan\":{\"id\":\"bayilnplg2\",\"family\":\"R\",\"gloss\":\"walks\",\"short\":\"[E:tce* pan] walks.\"},\"vune\":{\"id\":\"x2x2xeye5x\",\"family\":\"R\",\"gloss\":\"enjoyable\",\"short\":\"[E:tce* man] is enjoyable/great/nice for [A:tce* pan].\"},\"jvin\":{\"id\":\"ooyvglzn7l\",\"family\":\"R\",\"gloss\":\"dances\",\"short\":\"[E:tce* pan] dances.\"},\"blan\":{\"id\":\"7qni8huxuw\",\"family\":\"R\",\"short\":\"[E:tce* man] is beautiful.\",\"gloss\":\"beautiful\",\"notes\":\"TODO: According to which standard/observer ?\\\\n\"},\"pcien\":{\"id\":\"0uujkotag5\",\"family\":\"R\",\"gloss\":\"bread\",\"short\":\"[E:tce* pan] is bread.\"},\"ban\":{\"id\":\"pwmxutektw\",\"family\":\"R\",\"short\":\"[E:tce* man] is a language.\",\"gloss\":\"language\"},\"banu\":{\"id\":\"cvbgy6pdjn\",\"family\":\"R\",\"short\":\"[E:tce* skar] is expressed in language [A:tce* ban].\",\"gloss\":\"language\"},\"vli\":{\"id\":\"wlbcggayj6\",\"family\":\"R\",\"short\":\"[E:tce* skar] is written/inscribed on display/storage medium [A:tce* pan].\",\"gloss\":\"written\"},\"soane\":{\"id\":\"rmpkifsf0c\",\"family\":\"R\",\"gloss\":\"stolen\",\"short\":\"[E:tce* pan] is stolen from [A:tce* pan].\",\"notes\":\"Use with {gza} to express who/what steals (E-Xd).\\\\n\"},\"tri\":{\"id\":\"dzrpftevt6\",\"family\":\"R\",\"gloss\":\"attemps\",\"short\":\"[E:tce* pan] tries/attemps to do/bring about [A:()].\\\\nSuccess is neither implied or disimplied.\\\\n\"},\"tuli\":{\"id\":\"yla5j5nzda\",\"family\":\"R\",\"gloss\":\"needs\",\"short\":\"[E:tce* man] requires/needs [A:()] to being true. [A] is a necessity for [E].\"},\"miun\":{\"id\":\"mu4oshpucp\",\"family\":\"R\",\"gloss\":\"sleeps\",\"short\":\"[E:tce* pan] sleeps.\"},\"juni\":{\"id\":\"fkb8ogaewe\",\"family\":\"R\",\"gloss\":\"good\",\"short\":\"[E:tce* man] is good.\",\"notes\":\"TODO: According to which standard/observer ?\\\\n\"},\"junu\":{\"id\":\"ske4u4gwyx\",\"family\":\"R\",\"gloss\":\"bad\",\"short\":\"[E:tce* man] is bad.\",\"notes\":\"TODO: According to which standard/observer ?\\\\n\"},\"kunu\":{\"id\":\"6runpjljp0\",\"family\":\"R\",\"gloss\":\"feels\",\"short\":\"[E:tce* pan] feels sentiment/emotion/sensation [A:tce* man].\",\"notes\":\"TODO: Define sentiment/emotion/sensation.\\\\n\"},\"viru\":{\"id\":\"r9jofkaowc\",\"family\":\"R\",\"gloss\":\"sees\",\"short\":\"[E:tce* pan] sees [A:tce* pan].\"},\"pure\":{\"id\":\"uj342f9oaw\",\"family\":\"R\",\"gloss\":\"hears\",\"short\":\"[E:tce* pan] hears/listen to [A:tce* man].\"},\"cen\":{\"id\":\"oqk7vz0ubt\",\"family\":\"R\",\"gloss\":\"word\",\"short\":\"[E:tce* man] is a word.\",\"notes\":\"TODO: See {cei} notes.\\\\n\"},\"vain\":{\"id\":\"ndedgziytg\",\"family\":\"R\",\"gloss\":\"alive\",\"short\":\"[E:tce* pan] is alive.\"},\"vaun\":{\"id\":\"647zwucgf3\",\"family\":\"R\",\"gloss\":\"dead\",\"short\":\"[E:tce* pan] is dead.\"},\"cfin\":{\"id\":\"r3ghqjwt6v\",\"family\":\"R\",\"gloss\":\"solid\",\"tags\":[\"matter\"],\"short\":\"[E:tce* pan] is a solid (state of matter).\"},\"cfen\":{\"id\":\"6rko2uu7va\",\"family\":\"R\",\"gloss\":\"liquid\",\"tags\":[\"matter\"],\"short\":\"[E:tce* pan] is a liquid (state of matter).\"},\"cfan\":{\"id\":\"mfalhp75eo\",\"family\":\"R\",\"gloss\":\"gas\",\"tags\":[\"matter\"],\"short\":\"[E:tce* pan] is a gas (state of matter).\"},\"jeon\":{\"id\":\"xzllyv1sx1\",\"family\":\"R\",\"gloss\":\"water\",\"tags\":[\"matter\"],\"short\":\"[E:tce* pan] is water.\"},\"gour\":{\"id\":\"ilftg4btmc\",\"family\":\"R\",\"gloss\":\"dog\",\"tags\":[\"animal\"],\"short\":\"[E:tce* pan] is a dog.\"},\"kanan\":{\"id\":\"edmwc8ujnr\",\"family\":\"R\",\"gloss\":\"wolf\",\"tags\":[\"animal\"],\"short\":\"[E:tce* pan] is a wolf.\"},\"kroan\":{\"id\":\"3ojsocuqre\",\"family\":\"R\",\"gloss\":\"frog\",\"tags\":[\"animal\"],\"short\":\"[E:tce* pan] is a frog.\"},\"toril\":{\"id\":\"qsevjdaur5\",\"family\":\"R\",\"gloss\":\"bird\",\"tags\":[\"animal\"],\"short\":\"[E:tce* pan] is a bird.\"},\"cein\":{\"id\":\"ju1aijntrb\",\"family\":\"R\",\"gloss\":\"room\",\"short\":\"[E:tce* pan] is a room.\"},\"caun\":{\"id\":\"kar7h43drl\",\"family\":\"R\",\"gloss\":\"animal\",\"tags\":[\"animal\"],\"short\":\"[E:tce* pan] is an animal.\"},\"flur\":{\"id\":\"hp3x2jerun\",\"family\":\"R\",\"gloss\":\"plant\",\"short\":\"[E:tce* pan] is a plant.\"},\"jveno\":{\"id\":\"5z3fg2p8rj\",\"family\":\"R\",\"gloss\":\"friendly\",\"short\":\"[E:tce* pan] is kind/behaves friendly towards [A:tce* man].\"},\"slari\":{\"id\":\"dulprqx3y8\",\"family\":\"R\",\"gloss\":\"rule\",\"short\":\"[E:tce* man] is a rule/law prescribing/mandating/requiring [A:()].\"},\"zire\":{\"id\":\"csb8qamcqg\",\"family\":\"R\",\"gloss\":\"respects\",\"short\":\"[E:tce* pan] respects [A:tce* man].\"},\"zbui\":{\"id\":\"fn8nachgm7\",\"family\":\"R\",\"gloss\":\"copulates\",\"short\":\"[E:tce* pan] have sex/sexual intercourse/copulates/mates with [A:tce* pan].\"},\"jiro\":{\"id\":\"qptdoaahae\",\"family\":\"R\",\"gloss\":\"shares\",\"short\":\"[E:tce* pan] shares [A:tce* man] with [O:tce* pan].\"},\"sier\":{\"id\":\"wyulrjphcd\",\"family\":\"R\",\"gloss\":\"internet\",\"short\":\"[E:tca man] is the Internet.\"},\"stini\":{\"id\":\"lf05kqsaiu\",\"family\":\"R\",\"gloss\":\"rigid\",\"short\":\"[E:tce* pan] is rigid/not bendable.\"},\"merue\":{\"id\":\"c84admq4vz\",\"family\":\"R\",\"gloss\":\"organism\",\"short\":\"[E:tce* pan] is an organism / form of life.\"},\"slane\":{\"id\":\"torlvzglzh\",\"family\":\"R\",\"gloss\":\"tied\",\"short\":\"[E:tce* pan] is tied/pinned to [A:tce* pan].\"},\"skien\":{\"id\":\"gpqertouzz\",\"family\":\"R\",\"gloss\":\"program\",\"short\":\"[E:tce* man] is a computer program.\"},\"zari\":{\"id\":\"y9cpaqtwg7\",\"family\":\"R\",\"gloss\":\"recipe\",\"short\":\"[E:tce* man] is a recipe, algorithm, procedure to achieve result [A:tce* man].\"},\"zeni\":{\"id\":\"yuesrkiajk\",\"family\":\"R\",\"gloss\":\"provided\",\"short\":\"[E:tce* pan] [supply/commodity] is provided to [A:tce* pan].\",\"notes\":\"Use with {gza} to express who/what provides [E].\\\\n\"},\"curo\":{\"id\":\"6fkztdm4xl\",\"family\":\"R\",\"gloss\":\"grammar\",\"short\":\"[E:tca man] is the grammar of [A:tca man].\",\"notes\":\"TODO: See {cei} notes.\\\\n\"},\"tsiu\":{\"id\":\"oowoy3auep\",\"family\":\"R\",\"gloss\":\"finds\",\"short\":\"[E:tce* pan] finds/discovers [A:tce* man].\"},\"bun\":{\"id\":\"ernf6oh1zg\",\"family\":\"R\",\"gloss\":\"text\",\"short\":\"[A:tce* man] is a text.\"},\"bino\":{\"id\":\"83sklgorvt\",\"family\":\"R\",\"gloss\":\"sick\",\"short\":\"[E:tce* pan] is ill/sick from disease [A:tce* man].\"},\"saul\":{\"id\":\"7hsf409fle\",\"family\":\"R\",\"gloss\":\"light\",\"short\":\"[E:tce* pan] is light [energy].\"},\"cmiri\":{\"id\":\"a0ngc6glp1\",\"family\":\"R\",\"gloss\":\"emits\",\"short\":\"[E:tce* pan] emits/produce [A:tce* pan].\"},\"cmiru\":{\"id\":\"stnikxm23l\",\"family\":\"R\",\"gloss\":\"receives\",\"short\":\"[E:tce* pan] receives/absorbs [A:tce* pan].\"},\"flun\":{\"id\":\"uu6cakexur\",\"family\":\"R\",\"gloss\":\"sound\",\"short\":\"[A:tce* man] is a sound.\"},\"fana\":{\"id\":\"ydafwz0dpc\",\"family\":\"R\",\"gloss\":\"social parent\",\"tags\":[\"kinship\",\"family\"],\"short\":\"[E:tce* pan] is a social parent of [A:tce* pan] (child). [E] raises [A].\"},\"vele\":{\"id\":\"qexvxnyxrj\",\"family\":\"R\",\"gloss\":\"genetic parent\",\"tags\":[\"kinship\",\"family\"],\"short\":\"[E:tce* pan] is a genetic direct parent of [A:tce* pan].\\\\n[E] directly contributes to the genetic makeup of [A].\\\\n\"},\"kana\":{\"id\":\"xrpthmvqzq\",\"family\":\"R\",\"gloss\":\"sibling\",\"tags\":[\"kinship\",\"family\"],\"short\":\"[E:tce* pan] is a sibling/brother/sister of [A:tce* pan].\"},\"kene\":{\"id\":\"dkmrgjgriv\",\"family\":\"R\",\"gloss\":\"nibling\",\"tags\":[\"kinship\",\"family\"],\"short\":\"[E:tce* pan] is a nibling/nephew/nice of [A:tce* pan] (uncle/aunt).\"},\"mana\":{\"id\":\"la6bqysk7n\",\"family\":\"R\",\"gloss\":\"mother\",\"tags\":[\"kinship\",\"family\"],\"short\":\"[E:tce* pan] is a (social) mother of [A:tce* pan].\",\"notes\":\"Equivalent to {zin fana}.\"},\"pana\":{\"id\":\"kfxorufmmw\",\"family\":\"R\",\"gloss\":\"father\",\"tags\":[\"kinship\",\"family\"],\"short\":\"[E:tce* pan] is a (social) father of [A:tce* pan].\",\"notes\":\"Equivalent to {zun fana}.\"},\"jnehu\":{\"id\":\"dmqfp5rpq1\",\"family\":\"R\",\"gloss\":\"takes care\",\"tags\":[\"kinship\",\"family\"],\"short\":\"[E:tce* pan] takes cares of [A:tce* pan].\\\\n[E] ensures that the needs of [A] are fulfulled.\\\\n\"},\"dzana\":{\"id\":\"xm9tse7cct\",\"family\":\"R\",\"gloss\":\"married\",\"tags\":[\"kinship\",\"family\"],\"short\":\"[E:tce* pan] is married to [A:tce* pan].\"},\"kineo\":{\"id\":\"96lvpzzkom\",\"family\":\"R\",\"gloss\":\"touches\",\"short\":\"[E:tce* pan] touches [A:tce* pan].\"},\"varin\":{\"id\":\"jgewshmmt3\",\"family\":\"R\",\"gloss\":\"strange\",\"short\":\"[E:tce* man] is strange/weird.\",\"notes\":\"TODO: According to who? Since it seems subjective, could it use a\\\\nsubjective \\\\\"actor\\\\\" in the context?\\\\n\"},\"zvaor\":{\"id\":\"lsnj8jjkmu\",\"family\":\"R\",\"gloss\":\"accident\",\"short\":\"[E:()] is an accident/unintentional.\"},\"teran\":{\"id\":\"i24b50cv0l\",\"family\":\"R\",\"gloss\":\"planet\",\"short\":\"[E:tce* pan] is a planet.\"},\"soran\":{\"id\":\"h9j1gg2cwz\",\"family\":\"R\",\"gloss\":\"star\",\"short\":\"[E:tce* pan] is a star.\"},\"zilan\":{\"id\":\"yfcj6sjbss\",\"family\":\"R\",\"gloss\":\"moon\",\"short\":\"[E:tce* pan] is a major natural satellite/moon.\"},\"kari\":{\"id\":\"w0aqh2uwhk\",\"family\":\"R\",\"gloss\":\"axiom\",\"short\":\"[E:tce* pan] has axiomatic belief that [A:()] is true.\",\"notes\":\"[A] is an axiom, is presupposed to be true and it\\'s truth value is never\\\\nput into doupt.\\\\n\"},\"kiru\":{\"id\":\"kxo9ztaycl\",\"family\":\"R\",\"gloss\":\"thinks\",\"short\":\"[E:tce* pan] thinks that [A:()] is true.\"},\"meon\":{\"id\":\"ym0o9kvaix\",\"family\":\"R\",\"gloss\":\"apple\",\"short\":\"[E:tce* pan] is an apple.\",\"tags\":[\"food\"]},\"kcaor\":{\"id\":\"xsvrcy3wof\",\"family\":\"R\",\"gloss\":\"table\",\"short\":\"[E:tce* pan] is a table.\"},\"stan\":{\"id\":\"bc0e4pcz9h\",\"family\":\"R\",\"gloss\":\"country\",\"short\":\"[E:tce* pan] is a country/territory.\"},\"drair\":{\"id\":\"uuwufiyz1v\",\"family\":\"R\",\"gloss\":\"god\",\"short\":\"[E:tce* man] is a god.\"},\"kroin\":{\"id\":\"biiaxhdwtb\",\"family\":\"R\",\"gloss\":\"leg\",\"short\":\"[E:tce* pan] is a leg.\"},\"kani\":{\"id\":\"puq4yi3rrf\",\"family\":\"R\",\"gloss\":\"infers from senses\",\"short\":\"[E:tce* pan] infers from their current sensorial experience that [A:()] is the case.\"},\"mara\":{\"id\":\"wdughdrr2i\",\"family\":\"R\",\"gloss\":\"remembers\",\"short\":\"[E:tce* pan] remembers the past experience of perceiving that [A:()] was the case.\"},\"zule\":{\"id\":\"xq83jvzd55\",\"family\":\"R\",\"gloss\":\"hearsay\",\"short\":\"[E:tce* pan] has got second-hand information or hearsay according to which [A:()] is the case.\"},\"muni\":{\"id\":\"wl8bgxuacj\",\"family\":\"R\",\"short\":\"[E:tce* pan] intuits that [A:()] is the case.\",\"gloss\":\"intuits\"},\"sana\":{\"id\":\"ettifc4jmj\",\"family\":\"R\",\"gloss\":\"cultural knowledge\",\"short\":\"[E:tce* pan] has cultural knowledge, collective wisdom according to which [A:()] is the case.\"},\"valo\":{\"id\":\"w14bplmcqv\",\"family\":\"R\",\"gloss\":\"infers from multiple sources\",\"short\":\"[E:tce* pan] infers (from several sources of information) that [A:()] is the case.\"},\"bale\":{\"id\":\"ktg311prdc\",\"family\":\"R\",\"gloss\":\"standing\",\"short\":\"[E:tce* pan] is standing on [A:tce* pan].\"},\"ctua\":{\"id\":\"lzwen9akg1\",\"family\":\"R\",\"gloss\":\"sit\",\"short\":\"[E:tce* pan] is sitting on [A:tce* pan].\"},\"proi\":{\"id\":\"p6vxsz77g5\",\"family\":\"R\",\"gloss\":\"lying down\",\"short\":\"[E:tce* pan] is lying down on [A:tce* pan].\"},\"gavgin\":{\"id\":\"clobthv9y6\",\"family\":\"R\",\"gloss\":\"crystal\",\"short\":\"[E:tce* pan] is a crystal/gem/mineral with orderly atomic structure [A:tca man].\"},\"jalan\":{\"id\":\"odewd63czr\",\"family\":\"R\",\"short\":\"[E:tce* pan] is awake.\",\"gloss\":\"awake\"},\"celia\":{\"id\":\"fdsj3ynb15\",\"family\":\"R\",\"gloss\":\"science\",\"short\":\"[E:tca man] is the science/study/body of knowledge about topic [A:tce* man].\",\"notes\":\"TODO: Define what a topic is.\\\\n\"},\"filu\":{\"id\":\"1deyt0qtei\",\"family\":\"R\",\"gloss\":\"gives birth\",\"short\":\"[E:tce* pan] gives birth to/begets [A:tce* pan].\"},\"sahar\":{\"id\":\"5f1kx0ktx8\",\"family\":\"R\",\"gloss\":\"flower\",\"short\":\"[E:tce* pan] is a flower.\"},\"kena\":{\"id\":\"q9fyy1qn9d\",\"family\":\"R\",\"gloss\":\"holds\",\"short\":\"[E:tce* pan] holds/grasps [A:tce* pan].\"},\"clo\":{\"id\":\"pfztommryn\",\"family\":\"R\",\"gloss\":\"purpose\",\"short\":\"[E:tce man] have purpose to satisfy property [A:(tce man)].\"},\"jara\":{\"id\":\"wwih32fwvc\",\"family\":\"R\",\"gloss\":\"paid work\",\"short\":\"[E:tce pan] has satisfying property [A:(tce pan)] as one of their jobs/occupations (paid work).\"},\"zera\":{\"id\":\"od2vvlzdn2\",\"family\":\"R\",\"short\":\"[E:tce pan] has satisfying property [A:(tce pan)] as a personality trait.\",\"gloss\":\"personality trait\"},\"blae\":{\"id\":\"xr7quk0nzy\",\"family\":\"R\",\"gloss\":\"owned\",\"short\":\"[E:tce* man] is owned by [E:tce pan].\"},\"tsu\":{\"id\":\"pmbpui1xxn\",\"family\":\"R\",\"gloss\":\"cardinality\",\"short\":\"[E:tca gin] is the cardinality/number of elements of [A:tce a].\"},\"dzui\":{\"id\":\"zwvj8ibmcc\",\"family\":\"R\",\"gloss\":\"able\",\"short\":\"[E:tce pan] is able to satisfy property [A:(tce pan)].\"},\"benal\":{\"id\":\"cvvwmrotg2\",\"family\":\"R\",\"gloss\":\"healthy\",\"short\":\"[E:tce* pan] is healthy/fit/well/in good health.\"},\"jogmal\":{\"id\":\"zc08tmqeum\",\"family\":\"R\",\"gloss\":\"wound\",\"short\":\"[E:tce* pan] is a wound.\"},\"meul\":{\"id\":\"afkl3d764n\",\"family\":\"R\",\"short\":\"[E:tce* pan] (default: water) is raining.\",\"gloss\":\"rain\"},\"znir\":{\"id\":\"bbmaoqi9r0\",\"family\":\"R\",\"gloss\":\"obligated\",\"short\":\"[E:()] is obligated to be performed under authority [A:tce* pan]. [E] is a duty.\\\\n\\\\nExamples: praying (in some religions), voting (in some countries), parents\\\\ntaking care of their children is societally obligated\\\\n\"},\"zner\":{\"id\":\"katsvpqhmr\",\"family\":\"R\",\"gloss\":\"encouraged\",\"short\":\"[E:()] is encouraged to be performed under authority [A:tce* pan]. \\\\n[E] is a virtuous/upstanding behavior.\\\\n\\\\nExamples: charity, volunteer work, being polite\\\\n\"},\"znar\":{\"id\":\"juramnwmey\",\"family\":\"R\",\"gloss\":\"tolerated\",\"short\":\"[E:()] is neither encouraged nor discouraged (i.e. permitted) by authority [A:tce* pan].\\\\n[E] is tolerated.  \\\\n\\\\nExamples: basically most actions are {sena}, there are so many examples\\\\n-- the act of breathing is sena\\\\n\"},\"znor\":{\"id\":\"2uij97w56c\",\"family\":\"R\",\"gloss\":\"discouraged\",\"short\":\"[E:()] is discouraged to be performed under authority [A:tce* pan]; [E] is reprehensible.\\\\n\\\\nExamples: lying (not under oath), crimes with are technically illegal but\\\\nnot prosecuted, laughing at a funeral, breaking certain religious laws\\\\n\"},\"znur\":{\"id\":\"wtc0sbwiwj\",\"family\":\"R\",\"gloss\":\"forbidden\",\"short\":\"[E:()] is forbidden to be done by authority [A:tce* pan].\\\\n\\\\nExamples: for many religions speaking badly of their deity is forbidden,\\\\ncrimes which are prosecuted, cheating on your partner in a monogamous relationship\\\\n\"},\"molai\":{\"id\":\"td2lg6faki\",\"family\":\"R\",\"gloss\":\"reward/punishment\",\"short\":\"[E:tce pan] is made to satisfy [A:(tce pan)] as a reward/punishment.  \\\\n(E) is awarded/punished, with result that they satisfy [A].\\\\n\"},\"krehu\":{\"id\":\"giuwxgdlvl\",\"family\":\"R\",\"gloss\":\"meat\",\"short\":\"[E:tce* pan] is meat from animal/source [A:tce* pan].\"},\"drie\":{\"id\":\"034abxcqau\",\"family\":\"R\",\"gloss\":\"buys\",\"short\":\"[E:tce pan] buys [A:tce pan] for price/in exchange for [O:tce pan] (where success is implied).\"},\"dria\":{\"id\":\"f6na2jopyj\",\"family\":\"R\",\"gloss\":\"offers\",\"short\":\"[E:tce pan] offers/intends to sell [A:tce pan] for price/in exchange for [O:tce pan] (where success is not implied).\"},\"pubdel\":{\"id\":\"falmva70zj\",\"family\":\"R\",\"gloss\":\"soil\",\"short\":\"[E:tce* pan] is soil/dirt/pebbles/silt/clay (soil of all types).\"},\"baluor\":{\"id\":\"wn6yzmye8r\",\"family\":\"R\",\"gloss\":\"stone\",\"short\":\"[E:tce* pan] is a stone/rock/boulder (unified unbroken mass).\"},\"boiur\":{\"id\":\"ttvo8lgox4\",\"family\":\"R\",\"gloss\":\"dry land\",\"short\":\"[E:tce* pan] is dry land (not watery, can be stepped on).\",\"notes\":\"antonyms: {suier}, {gzeon}\"},\"suier\":{\"id\":\"wl3qaptjzv\",\"family\":\"R\",\"gloss\":\"sea\",\"short\":\"[E:tce* pan] is a sea/ocean/lake (relatively large non-flowing body of water).\"},\"gzeon\":{\"id\":\"bvejlt10si\",\"family\":\"R\",\"gloss\":\"river\",\"short\":\"[E:tce* pan] is a river/stream/brook (relatively large flowing body of water).\"},\"saelo\":{\"id\":\"84wqipbpce\",\"family\":\"R\",\"gloss\":\"air\",\"short\":\"[E:tce* pan] is air/breathable atmosphere/gas at correct pressure for [A:tce* pan] (default: {flan}/humans).\"},\"soeon\":{\"id\":\"atojlgas61\",\"family\":\"R\",\"gloss\":\"sky\",\"short\":\"[E:tce* pan] is is the sky (high troposphere and above).\"},\"cnue\":{\"id\":\"kx3walxiid\",\"family\":\"R\",\"short\":\"[E:tce* pan] is a piece/portion/part of [A:tce pan].\",\"gloss\":\"portion\"},\"duna\":{\"id\":\"pcq9zoejuv\",\"family\":\"R\",\"short\":\"[E:tce pan] gives [A:tce* pan] to [O:tce pan].\",\"gloss\":\"gives\",\"notes\":\"[E] no longer has legal or incidental ownership over [A].\\\\nNow, [O] has legal or incidental ownership over [A].\\\\nTo specify whether it\\'s legal or incidental, use\\\\n(TODO: Add words for legal/incidental ownership)\\\\n\\\\n[E] does not accept payment or expect reciprocation from [O].\\\\n\"},\"skar\":{\"id\":\"vdlcqmqkoi\",\"family\":\"R\",\"short\":\"[E:tce* man] is a string of data (quote).\",\"gloss\":\"quote\"},\"flan\":{\"id\":\"cjj2u7h6ir\",\"family\":\"R\",\"short\":\"[E:tce* man] is a human being.\",\"gloss\":\"human\"},\"fuli\":{\"id\":\"r8ezp2roox\",\"family\":\"R\",\"gloss\":\"sum\",\"tags\":[\"maths\"],\"short\":\"[E:tce gan] is the sum of numbers in list [A:blu tce gan].\"},\"fulu\":{\"id\":\"pd94naqm1w\",\"family\":\"R\",\"gloss\":\"product\",\"tags\":[\"maths\"],\"short\":\"[E:tce gan] is the product of numbers in list [A:blu tce gan].\"},\"koro\":{\"id\":\"iophfsuxgp\",\"family\":\"R\",\"gloss\":\"number pred\",\"short\":\"[E:(tce gan,tce gan)] is a predicate of the form: [E:tce gan] is [number]\\\\ntimes [A:tce gan] (default: 1).\\\\n\",\"notes\":\"Allows to check a predicate behaves like a number made from TI (+ jie), or\\\\nother number predicates of the same form. Can be used to define math\\\\nequations with the unknown being such a predicate, allowing to chain multiple\\\\nthe unknown for multiplication.\\\\n\\\\nExample: {poi ga \\\\\\\\[ge be\\\\\\\\] fuli \\\\\\\\[vi koro ge\\\\\\\\] \\\\\\\\[fa te bu, ta ge bu, to ge ge\\\\\\\\] \\\\\\\\[fe ti\\\\\\\\]}\\\\\\\\\\\\nQuestion \\\\\"ga\\\\\": What is some number x such that 1 + 2x + 3x² = 0 ?\\\\n\"},\"bire\":{\"id\":\"peug1pbvxf\",\"family\":\"R\",\"gloss\":\"year\",\"short\":\"[E:tce gan] is 1 year times [A:tce gan] (default: 1).\",\"tags\":[\"time\",\"unit\"],\"notes\":\"Since years don\\'t all have the same duration (leap years and leap seconds),\\\\nand we\\'re not speaking about a specific year in a calendar, [E] is a subset\\\\nof all possible durations of a year.\\\\n\\\\nTODO: Define which kind of year? Calendar year? Which calendar?\\\\n\"},\"gare\":{\"id\":\"q5yr0ta93i\",\"family\":\"R\",\"gloss\":\"month\",\"short\":\"[E:tce gan] is 1 month times [A:tce gan] (default: 1).\",\"tags\":[\"time\",\"unit\"],\"notes\":\"Since months don\\'t all have the same duration (leap years and leap seconds),\\\\nand we\\'re not speaking about a specific month in a calendar, [E] is a subset\\\\nof all possible durations of a month.\\\\n\\\\nTODO: Define which kind of month? Calendar month? Which calendar?\\\\n\"},\"kora\":{\"id\":\"ccfnhkiitg\",\"family\":\"R\",\"gloss\":\"week\",\"short\":\"[E:tce gan] is 1 week (7 days) times [A:tce gan] (default: 1).\",\"tags\":[\"time\",\"unit\"],\"notes\":\"Since weeks don\\'t all have the same duration (leap seconds),\\\\nand we\\'re not speaking about a specific week in a calendar, [E] is a subset\\\\nof all possible durations of a week.\\\\n\"},\"dena\":{\"id\":\"cfjh1v5inn\",\"family\":\"R\",\"gloss\":\"day\",\"short\":\"[E:tce gan] is 1 day times [A:tce gan] (default: 1).\",\"tags\":[\"time\",\"unit\"],\"notes\":\"Since days don\\'t all have the same duration (leap seconds),\\\\nand we\\'re not speaking about a specific week in a calendar, [E] is a subset\\\\nof all possible durations of a day.\\\\n\"},\"sura\":{\"id\":\"7jdojjj4lv\",\"family\":\"R\",\"gloss\":\"hour\",\"short\":\"[E:tce gan] is 1 hour times [A:tce gan] (default: 1).\",\"tags\":[\"time\",\"unit\"]},\"jero\":{\"id\":\"hxbyme2tnh\",\"family\":\"R\",\"gloss\":\"minute\",\"short\":\"[E:tce gan] is 1 minute times [A:tce gan] (default: 1).\",\"tags\":[\"time\",\"unit\"]},\"vola\":{\"id\":\"mhrlcmuwvk\",\"family\":\"R\",\"gloss\":\"second\",\"short\":\"[E:tce gan] is 1 second times [A:tce gan] (default: 1).\",\"tags\":[\"time\",\"unit\"]},\"mula\":{\"id\":\"w93rd5hdrd\",\"family\":\"R\",\"gloss\":\"meter\",\"short\":\"[E:tce gan] is 1 meter times [A:tce gan] (default: 1).\",\"tags\":[\"space\",\"unit\"]},\"gulo\":{\"id\":\"vbit1n0jcf\",\"family\":\"R\",\"gloss\":\"kilogram\",\"short\":\"[E:tce gan] is 1 kilogram times [A:tce gan] (default: 1).\",\"tags\":[\"unit\"]},\"pere\":{\"id\":\"vyzkrgasib\",\"family\":\"R\",\"gloss\":\"ampere\",\"short\":\"[E:tce gan] is 1 ampere times [A:tce gan] (default: 1).\",\"tags\":[\"unit\"]},\"keli\":{\"id\":\"ata2lrtlvb\",\"family\":\"R\",\"gloss\":\"kelvin\",\"short\":\"[E:tce gan] is 1 kelvin times [A:tce gan] (default: 1).\",\"tags\":[\"unit\"]},\"kelu\":{\"id\":\"p6q0cb2cld\",\"family\":\"R\",\"gloss\":\"degree-celcius\",\"short\":\"[E:tce gan] is 1 degree Celcius times [A:tce gan] (default: 1).\",\"tags\":[\"unit\"]},\"saur\":{\"id\":\"qxk4kuezqg\",\"family\":\"R\",\"gloss\":\"candela\",\"short\":\"[E:tce gan] is 1 candela times [A:tce gan] (default: 1).\",\"tags\":[\"unit\"]},\"jmi\":{\"id\":\"ulx09krbl9\",\"family\":\"R\",\"gloss\":\"inverse\",\"short\":\"[E:tce gan] is the inverse (1/x) of [A:tce gan] (default: 1).\",\"tags\":[\"math\",\"unit\"],\"notes\":\"Thanks to the transitivity of all unit predicates and numbers, it is easy to\\\\nspeak about quantities with negative power units.\\\\n\\\\n4 km/h = {to je to jie mual jmi vola}\\\\n\\\\nWhen dealing with multiple negative powers, it is best to group them after\\\\na single {jmi}.\\\\n\\\\n6.674e-11 m3.kg-1.s-2\\\\n= 6.674e-11 m3/(kg.s2)\\\\n= {tia jo tia tio tu jei teo jie mual mual mual jmi gulo vola vola}\\\\n\"},\"zgie\":{\"id\":\"nneh2x85ud\",\"family\":\"R\",\"gloss\":\"width\",\"short\":\"[E:tce gan] (length) is the width of [A:tce pan].\"},\"fniu\":{\"id\":\"fb6aza9xej\",\"family\":\"R\",\"gloss\":\"height\",\"short\":\"[E:tce gan] (length) is the height of [A:tce pan].\"},\"cpea\":{\"id\":\"1p6a8o9nk3\",\"family\":\"R\",\"gloss\":\"area\",\"short\":\"[E:tce gan] (length^2) is the area of [A:tce pan].\"},\"jvao\":{\"id\":\"nd9g9s8u4q\",\"family\":\"R\",\"gloss\":\"volume\",\"short\":\"[E:tce gan] (length^3) is the volume of [A:tce pan].\"},\"ckia\":{\"id\":\"ldcalrk1ii\",\"family\":\"R\",\"gloss\":\"speed\",\"short\":\"[E:tce gan] (length/time) is the instantaneous speed of [A:tce pan].\"},\"djio\":{\"id\":\"r4euhq3iku\",\"family\":\"R\",\"gloss\":\"set-cardinality\",\"short\":\"[E:tce gan] (unitless) is the cardinality/number of members of [A:tce a].\"},\"gzia\":{\"id\":\"uz7xkm5k7x\",\"family\":\"R\",\"gloss\":\"population\",\"short\":\"[E:tce gan] (unitless) is the population/number of inhabitants of [A:tce pan].\"},\"cnei\":{\"id\":\"b0ey5as5c6\",\"family\":\"R\",\"gloss\":\"age\",\"short\":\"[E:tce gan] (time) is the age of [A:tce pan].\"},\"fsau\":{\"id\":\"vrsqhhv0zp\",\"family\":\"R\",\"gloss\":\"wear\",\"short\":\"[E:tce* pan] wears [A:tce* pan].\"},\"gion\":{\"id\":\"l5muhbsrar\",\"family\":\"R\",\"gloss\":\"shirt\",\"short\":\"[E:tce* pan] is a shirt/top.\",\"tags\":[\"clothing\",\"wearable\"]},\"miul\":{\"id\":\"bfcph6juna\",\"family\":\"R\",\"gloss\":\"pants\",\"short\":\"[E:tce* pan] is a pants/shorts/skirt.\",\"tags\":[\"clothing\",\"wearable\"]},\"gial\":{\"id\":\"g4vk2d8xbd\",\"family\":\"R\",\"gloss\":\"undershirt\",\"short\":\"[E:tce* pan] is an undershirt/bra.\",\"tags\":[\"clothing\",\"wearable\"]},\"bior\":{\"id\":\"j7pp7vnyha\",\"family\":\"R\",\"gloss\":\"underwear\",\"short\":\"[E:tce* pan] is an underwear/underpants/panties.\",\"tags\":[\"clothing\",\"wearable\"]},\"padgo\":{\"id\":\"oyemdfrbzy\",\"family\":\"R\",\"gloss\":\"arm\",\"short\":\"[E:tce* pan] is an arm of [A:tce pan].\",\"tags\":[\"body\"]},\"vauno\":{\"id\":\"ypph5jwrme\",\"family\":\"R\",\"gloss\":\"foot\",\"short\":\"[E:tce* pan] is a foot of [A:tce pan].\",\"tags\":[\"body\"]},\"fairo\":{\"id\":\"s4ekzm38rl\",\"family\":\"R\",\"gloss\":\"hand\",\"short\":\"[E:tce* pan] is a hand of [A:tce pan].\",\"tags\":[\"body\"]},\"glehul\":{\"id\":\"uwmxjgjvh7\",\"family\":\"R\",\"gloss\":\"genitals\",\"short\":\"[E:tce* pan] is genitals of [A:tce pan].\",\"tags\":[\"body\"]},\"droni\":{\"id\":\"ja9wfwwifa\",\"family\":\"R\",\"gloss\":\"head\",\"short\":\"[E:tce* pan] is a head of [A:tce pan].\",\"tags\":[\"body\"]},\"kiloi\":{\"id\":\"ioxa2c03t6\",\"family\":\"R\",\"gloss\":\"buttocks\",\"short\":\"[E:tce* pan] is a rear/buttox of [A:tce pan].\",\"tags\":[\"body\"]},\"zvinu\":{\"id\":\"skexhz96gk\",\"family\":\"R\",\"gloss\":\"mouth\",\"short\":\"[E:tce* pan] is a mouth of [A:tce pan].\",\"tags\":[\"body\"]},\"plaro\":{\"id\":\"ompuogjgt7\",\"family\":\"R\",\"gloss\":\"eye\",\"short\":\"[E:tce* pan] is an eye of [A:tce pan].\",\"tags\":[\"body\"]},\"tcila\":{\"id\":\"mqmszfhjbp\",\"family\":\"R\",\"gloss\":\"breast\",\"short\":\"[E:tce* pan] is a breast of [A:tce pan].\",\"tags\":[\"body\"]},\"seriu\":{\"id\":\"fpbl9tm4ul\",\"family\":\"R\",\"gloss\":\"tongue\",\"short\":\"[E:tce* pan] is a tongue of [A:tce pan].\",\"tags\":[\"body\"]},\"buhur\":{\"id\":\"qhoa1afbkl\",\"family\":\"R\",\"gloss\":\"nose\",\"short\":\"[E:tce* pan] is a nose of [A:tce pan].\",\"tags\":[\"body\"]},\"snane\":{\"id\":\"hyptrjozor\",\"family\":\"R\",\"gloss\":\"ear\",\"short\":\"[E:tce* pan] is an ear of [A:tce pan].\",\"tags\":[\"body\"]},\"dogmu\":{\"id\":\"aiczmufvcq\",\"family\":\"R\",\"gloss\":\"governs\",\"short\":\"[E:tce pan] governs people [A:tce* pan].\"},\"glogdu\":{\"id\":\"iwjm1mv0ij\",\"family\":\"R\",\"gloss\":\"tentacle\",\"short\":\"[E:tce* pan] is a tentacle of [A:tce pan]\",\"tags\":[\"body\"]},\"tsir\":{\"id\":\"zkravpgbit\",\"family\":\"R\",\"gloss\":\"bed\",\"short\":\"[E:tce* pan] is a bed.\"},\"gzian\":{\"id\":\"jhnc5nvbrz\",\"family\":\"R\",\"gloss\":\"showers\",\"short\":\"[E:tce* pan] showers in substance [A:tce pan] (default: water).\"},\"snoil\":{\"id\":\"bovvdgkucg\",\"family\":\"R\",\"gloss\":\"monster\",\"short\":\"[E:tce* pan] is a monster.\"},\"zmino\":{\"id\":\"zbbqohy82q\",\"family\":\"R\",\"gloss\":\"picture\",\"short\":\"[E:tce* pan] is a picture depicting [A:()].\",\"notes\":\"[A] occurs at the instant the picture was taken, as is constrainted in space\\\\nas the volume captured by the field of view of the camera.\\\\n\"},\"jalo\":{\"id\":\"6naqo0pjy0\",\"family\":\"R\",\"gloss\":\"with-each-other\",\"short\":\"[E:tce man] satisfy relation [A:(tca man,tca man)] with each other.\",\"notes\":\"Each member of [E] satisfy relation with [A] with every other member of [E].\\\\n\"},\"zole\":{\"id\":\"gbk8uduqqh\",\"family\":\"R\",\"gloss\":\"uses\",\"short\":\"[E:tce man] uses [A:tce* man] (tool) to satisfy [O:(tce man)].\",\"notes\":\"Predicates inside [O] can register tools using {zolen}.\\\\n\"},\"zolen\":{\"id\":\"enzha5idyj\",\"family\":\"R\",\"gloss\":\"register-tool\",\"short\":\"Register tool [E:tce* man] in the context.\",\"notes\":\"Goes in pair with {zole}. If context contains an entry with key {zai zolen},\\\\nthis predicate states that [E] is a subset of the value of this entry. If\\\\nthe context don\\'t contain such entry then nothing is stated.\\\\n\\\\nWrapping with {zole} will setup this entry in the context it provides to its\\\\nO place and find a \\\\\"smallest\\\\\" set that makes O true, and check that its A\\\\nplace is a subset of it.\\\\n\"},\"melu\":{\"id\":\"xpiycy1t59\",\"family\":\"R\",\"gloss\":\"rain\",\"short\":\"[E:tce man] rains.\"},\"jeni\":{\"id\":\"cmjmwddxde\",\"family\":\"R\",\"gloss\":\"range\",\"tags\":[\"number\"],\"short\":\"[E:tce gan] are all numbers in the range from [A:tce gan] - [O:tce gan]\\\\nto [A] + [O].\\\\n\",\"notes\":\"As [A] and [O] are sets it is the union made from all members of [A] with\\\\nall members of [O].\\\\n\"},\"pafkei\":{\"id\":\"ymuvroa9iu\",\"family\":\"R\",\"gloss\":\"potato\",\"short\":\"[E:tce pan] is a potato.\"},\"zmi\":{\"id\":\"cmeot2jbo9\",\"family\":\"R\",\"gloss\":\"color\",\"tags\":[\"color\"],\"short\":\"[E:tce man] is a color of [A:tce pan] perceived by [O:tce pan] (default: speaker).\"},\"zmen\":{\"id\":\"d0l3cp2pwk\",\"family\":\"R\",\"gloss\":\"white\",\"tags\":[\"color\"],\"short\":\"[E:tce pan] is perceived as white/light by [A:tce pan] (default: speaker).\"},\"zman\":{\"id\":\"qxdacbj9pt\",\"family\":\"R\",\"gloss\":\"red\",\"tags\":[\"color\"],\"short\":\"[E:tce pan] is perceived as red by [A:tce pan] (default: speaker).\"},\"zmon\":{\"id\":\"8tl5qke633\",\"family\":\"R\",\"gloss\":\"green\",\"tags\":[\"color\"],\"short\":\"[E:tce pan] is perceived as green by [A:tce pan] (default: speaker).\"},\"zmun\":{\"id\":\"aqb12hf0h5\",\"family\":\"R\",\"gloss\":\"blue\",\"tags\":[\"color\"],\"short\":\"[E:tce pan] is perceived as blue by [A:tce pan] (default: speaker).\"},\"zmer\":{\"id\":\"tfeeujlwxv\",\"family\":\"R\",\"gloss\":\"black\",\"tags\":[\"color\"],\"short\":\"[E:tce pan] is perceived as black/dark by [A:tce pan] (default: speaker).\"},\"zmar\":{\"id\":\"v0880nf0fg\",\"family\":\"R\",\"gloss\":\"cyan\",\"tags\":[\"color\"],\"short\":\"[E:tce pan] is perceived as cyan by [A:tce pan] (default: speaker).\"},\"zmor\":{\"id\":\"v46cs9fs33\",\"family\":\"R\",\"gloss\":\"magenta\",\"tags\":[\"color\"],\"short\":\"[E:tce pan] is perceived as magenta by [A:tce pan] (default: speaker).\"},\"zmur\":{\"id\":\"4p1ty9pgoi\",\"family\":\"R\",\"gloss\":\"yellow\",\"tags\":[\"color\"],\"short\":\"[E:tce pan] is perceived as yellow by [A:tce pan] (default: speaker).\"},\"cekme\":{\"id\":\"rn07g95kw6\",\"family\":\"R\",\"gloss\":\"differs\",\"tags\":[\"color\"],\"short\":\"[E:tce a] differs in what they individually satisfy relation [A:(tca a, b)]\\\\nwith.\\\\n\",\"notes\":\"[E] individually satisfy relation [A] with something (independant of each\\\\nother), but don\\'t all individually satisfy relation [A] with the same thing.\\\\n\",\"definition\":\"po cekme ke ga be\\\\nke\\\\n  ve tce ga\\\\n  bi fi ki be ke tce ga ki\\\\n\"},\"tceo\":{\"id\":\"1ekbkw2s33\",\"family\":\"R\",\"gloss\":\"mutual-1\",\"short\":\"[E:tco a] is a group where every pair of members mutualy satisfy property [A:(tco a)].\"},\"tceu\":{\"id\":\"ho1az3mcl2\",\"family\":\"R\",\"gloss\":\"mutual-2\",\"short\":\"[E:tco a] is a group where every pair of members mutualy satisfy relation [A:(tca a, tca a)].\"},\"jene\":{\"id\":\"gi4jvusxpm\",\"family\":\"R\",\"gloss\":\"big\",\"short\":\"[E:tce* a] are big among all things that satisfy measuring relation [A:(tce gan,tca pan)], with\\\\nstandard deviation [O:tca gan] (default: 1).\\\\n\",\"notes\":\"Each thing in [E] have more than [O] standard deviation(s) from the average size\\\\nof [A].\\\\n\"},\"jere\":{\"id\":\"ik7qjuwuxm\",\"family\":\"R\",\"gloss\":\"small\",\"short\":\"[E:tce* a] are small among all things that satisfy measuring relation [A:(tce gan,tca a)], with\\\\nstandard deviation [O:tca gan] (default: 1).\\\\n\",\"notes\":\"Each thing in [E] have less than [O] standard deviation(s) from the average size\\\\nof [A].\\\\n\"},\"jini\":{\"id\":\"7y4m7u346i\",\"family\":\"R\",\"gloss\":\"increasing-order\",\"short\":\"[E:blu a] is ordered from smallest to largest according to measuring relation [A:(tce gan,tca a)].\\\\n\"},\"jiri\":{\"id\":\"2ivqr4ouem\",\"family\":\"R\",\"gloss\":\"decreasing-order\",\"short\":\"[E:blu a] is ordered from largest to smalest according to measuring relation [A:(tce gan,tca a)].\\\\n\"},\"buran\":{\"id\":\"ndf5i6skum\",\"family\":\"R\",\"gloss\":\"bunny\",\"tags\":[\"animal\"],\"short\":\"[E:tce* pan] is a bunny/rabbit.\"},\"bjaor\":{\"id\":\"o8g2lhe4rd\",\"family\":\"R\",\"gloss\":\"elephant\",\"tags\":[\"animal\"],\"short\":\"[E:tce* pan] is an elephant.\"},\"coriu\":{\"id\":\"zas8minuik\",\"family\":\"R\",\"gloss\":\"owned-by\",\"short\":\"[E:tce* man] is possessed/owned by [A:tce man].\"},\"sifpa\":{\"id\":\"5kgq6jl1at\",\"family\":\"R\",\"gloss\":\"asserts\",\"short\":\"[E:tce pan] asserts that [A:()] is true.\",\"notes\":\"{pa X} can be modeled as being syntaxic sugar for {po P be mi sifpa X pu P}.\\\\nP is an unnamable predicate used solely for this purpose.\\\\n\"},\"sifpoi\":{\"id\":\"b0c73ecend\",\"family\":\"R\",\"gloss\":\"asks\",\"short\":\"[E:tce pan] asks question represented by predicate [A:a] to addressee [O:tce man].\",\"notes\":\"{poi X (be) Y} can be modeled as being syntaxic sugar for\\\\n{poe X be Y po P be mi sifpoi X pu P}. is an unnamable predicate used solely\\\\nfor this purpose.\\\\n\"},\"e tsae ban\":{\"id\":\"wf13qtgrwk\",\"family\":\"C2\",\"gloss\":\"conlang\",\"short\":\"[E:tce* ban] is a constructed language/conlang.\"},\"e ber ban\":{\"id\":\"l3hopxljdm\",\"family\":\"C2\",\"gloss\":\"eberban\",\"tags\":[\"cultural\"],\"short\":\"[E:tca ban] is the eberban language.\"},\"e ujbo ban\":{\"id\":\"ngdssrwkz9\",\"family\":\"C2\",\"gloss\":\"lojban\",\"tags\":[\"cultural\"],\"short\":\"[E:tca ban] is the lojban language.\"},\"e ufranse ban\":{\"id\":\"prqgtxzvj7\",\"family\":\"C2\",\"gloss\":\"french language\",\"tags\":[\"cultural\"],\"short\":\"[E:tca ban] is the french language.\"},\"e ufranse stan\":{\"id\":\"ql0k4zdkcv\",\"family\":\"C2\",\"gloss\":\"France\",\"tags\":[\"cultural\"],\"short\":\"[E:tca stan] is France.\"},\"e uinglic ban\":{\"id\":\"funyada7wl\",\"family\":\"C2\",\"gloss\":\"english language\",\"tags\":[\"cultural\"],\"short\":\"[E:tca ban] is the english language.\"},\"e unihon ban\":{\"id\":\"1x7rqmd7o9\",\"family\":\"C2\",\"gloss\":\"japanese language\",\"tags\":[\"cultural\"],\"short\":\"[E:tca ban] is the japanese language.\"},\"e unihon stan\":{\"id\":\"mpd6xpvqnk\",\"family\":\"C2\",\"gloss\":\"Japan\",\"tags\":[\"cultural\"],\"short\":\"[E:tca stan] is Japan.\"},\"e udjonguo ban\":{\"id\":\"6b3k4qzh5t\",\"family\":\"C2\",\"gloss\":\"chinese language\",\"tags\":[\"cultural\"],\"short\":\"[E:tca ban] is chinese language.\"},\"e udjonguo stan\":{\"id\":\"umjwjoi13h\",\"family\":\"C2\",\"gloss\":\"China\",\"tags\":[\"cultural\"],\"short\":\"[E:tca stan] is China.\"},\"e udoitce ban\":{\"id\":\"ro6uq1ihpz\",\"family\":\"C2\",\"gloss\":\"german language\",\"tags\":[\"cultural\"],\"short\":\"[E:tca ban] is german language.\"},\"e udoitce stan\":{\"id\":\"wrjrg2gvav\",\"family\":\"C2\",\"gloss\":\"Germany\",\"tags\":[\"cultural\"],\"short\":\"[E:tca stan] is Germany.\"},\"e umiser stan\":{\"id\":\"vrbsurc6ev\",\"family\":\"C2\",\"gloss\":\"Egypt\",\"tags\":[\"cultural\"],\"short\":\"[E:tca stan] is Egypt.\"},\"e uhangu ban\":{\"id\":\"hsclm6vdb3\",\"family\":\"C2\",\"gloss\":\"south korean language\",\"tags\":[\"cultural\"],\"short\":\"[E:tca ban] is south korean language.\"},\"e uhangu stan\":{\"id\":\"j5qgrzg33d\",\"family\":\"C2\",\"gloss\":\"South Korea\",\"tags\":[\"cultural\"],\"short\":\"[E:tca stan] is South Korea.\"},\"e utcoson ban\":{\"id\":\"xapwbat5r8\",\"family\":\"C2\",\"gloss\":\"north korean language\",\"tags\":[\"cultural\"],\"short\":\"[E:tca ban] is north korean language.\"},\"e utcoson stan\":{\"id\":\"m9uia2qvmv\",\"family\":\"C2\",\"gloss\":\"North Korea\",\"tags\":[\"cultural\"],\"short\":\"[E:tca stan] is North Korea.\"},\"e utoan ban\":{\"id\":\"c8xqa37om4\",\"family\":\"C2\",\"gloss\":\"Toaq language\",\"tags\":[\"cultural\"],\"short\":\"[E:tca ban] is the Toaq language.\"},\"e kre vire\":{\"id\":\"t1wi0cej5p\",\"family\":\"C2\",\"gloss\":\"guided visit\",\"short\":\"[E:tce* pan] visits [A:tce* pan] with guide [O:tce* pan].\"},\"e spi toril\":{\"id\":\"z6av1nqtuf\",\"family\":\"C2\",\"gloss\":\"parrot\",\"tags\":[\"animal\"],\"short\":\"[E:tce* pan] is a parrot.\"},\"e pu zoi\":{\"id\":\"sw1lnyrbpe\",\"family\":\"C2\",\"gloss\":\"paragraph\",\"short\":\"[E:tce* man] is a paragraph.\",\"notes\":\"TODO: See {cei} notes.\\\\n\"},\"e bino cnue\":{\"id\":\"o5vxdoahhm\",\"family\":\"C2\",\"gloss\":\"symptom\",\"short\":\"[E:tce* man] [ill/sickness] is characterized by symptom [A:tce* man].\"},\"e spua teran\":{\"id\":\"umamaeu1na\",\"family\":\"C2\",\"gloss\":\"home planet\",\"short\":\"[E:tca pan] is the home planet of species [A:tce* man] (default: {flan}/humans).\"},\"e spua soran\":{\"id\":\"732rregyg8\",\"family\":\"C2\",\"gloss\":\"home star\",\"short\":\"[E:tca pan] is the home star of species [A:tce* man] (default: {flan}/humans).\"},\"e jveno kena\":{\"id\":\"wvg2ebwap5\",\"family\":\"C2\",\"gloss\":\"hugs\",\"short\":\"[E:tce* pan] hugs [A:tce* pan].\"},\"e kini bun\":{\"id\":\"o9bwkmfwvs\",\"family\":\"C2\",\"short\":\"[E:tce* man] is a course teaching about subject [A:tce* man].\",\"gloss\":\"course\",\"definition\":\"po ekinibun ke ka pi ke bun gla kini via seru ka\"},\"a cen po bu\":{\"id\":\"jpvb7ytjfg\",\"family\":\"C3\",\"gloss\":\"dictionary\",\"short\":\"[E:tce* man] is a dictionary.\"}}');\n\n//# sourceURL=webpack://bundle/../dictionary/en.yaml?");

/***/ }),

/***/ "./src/dictionary.js":
/*!***************************!*\
  !*** ./src/dictionary.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports.dictionary_en = __webpack_require__(/*! ../../dictionary/en.yaml */ \"../dictionary/en.yaml\");\n\nconst alphabet = 'hnlrmpbfvtdszcjkgieaou';\n\nlet symbol_indices = {};\n\nfor (i = 0; i < alphabet.length; i++) {\n    symbol_indices[alphabet[i]] = i;\n}\n\nconsole.log({symbol_indices});\n\nfunction compare_words(x, y) {\n    if (x == y) {\n        return 0;\n    }\n\n    for(i = 0; i < x.length; i++) {\n        if (i >= y.length) {\n            return 1; // y is shorter and \n        }\n\n        let sx = symbol_indices[x[i]];\n        let sy = symbol_indices[y[i]];\n\n        // earlier in the alphabet => first to appear\n        if (sx < sy) {\n            return -1;\n        } else if (sx > sy) {\n            return 1;\n        }\n    }\n}\n\nmodule.exports.compare_words = compare_words;\n\n//# sourceURL=webpack://bundle/./src/dictionary.js?");

/***/ }),

/***/ "./src/process_parse_tree.js":
/*!***********************************!*\
  !*** ./src/process_parse_tree.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n * CAMXES.JS POSTPROCESSOR\n * \n * Entry point: camxes_postprocessing(input, mode)\n * \n * Arguments:\n *    • input: [array]  Camxes' parse tree output.\n *          OR [string] JSON stringified parse tree.\n *    • mode:  [string] Parse tree processing option list (each option is\n *                      symbolized by a letter). See below for details.\n *          OR [number] (Deprecated) Older options representation encoded as\n *                      bit flags on a number.\n * \n * Return value:\n *       [string] postprocessed version of camxes' output\n * \n * Details for the `mode´ arguent's values:\n * \n * The mode argument can be any letter string, each letter stands for a specific\n * option. Here is the list of possible letters and their associated meaning:\n *    'J' -> JSON output format\n *    'I' -> Indented JSON output format\n *    'M' -> Keep morphology\n *    'S' -> Show spaces\n *    'T' -> Show terminators\n *    'C' -> Show word classes (selmaho)\n *    'R' -> Raw output, do not trim the parse tree. If this option isn't set,\n *           all the nodes (with the exception of those saved if the 'N' option\n *           is set) are pruned from the tree.\n *    'N' -> Show main node labels\n *    'G' -> Show glosses instead of Lojban\n */\n\n/*\n * Function list:\n *   -- camxes_postprocessing(text, mode)\n *   -- newer_postprocessor(parse_tree, with_morphology, with_spaces,\n *                          with_terminators, with_trimming, with_selmaho,\n *                          with_nodes_labels)\n *   -- process_parse_tree(parse_tree, value_substitution_map,\n *                         name_substitution_map, node_action_for,\n *                         must_prefix_leaf_labels)\n *   -- among(v, s)\n *   -- is_family(v)\n *   -- prettify_brackets(str)\n *   -- str_print_uint(val, charset)\n *   -- str_replace(str, pos, len, sub)\n *   -- is_string(v)\n *   -- is_array(v)\n *   -- is_number(v)\n */\n\n// var glosser = require('../gismudata.js');\n\nif (typeof alert !== 'function') alert = console.log; // For Node.js\n\nconst { is_array, is_family, is_string, is_number, SPECIAL_FAMILIES } = __webpack_require__(/*! ./util */ \"./src/util.js\");\n\n/*\n * Main function.\n */\nfunction camxes_postprocessing(input, mode) {\n\t/* Checking the input */\n\tif (is_string(input)) input = JSON.parse(input);\n\tif (!is_array(input))\n\t\treturn (\n\t\t\t'Postprocessor error: invalid input type for the first argument. ' +\n\t\t\t'It should be either an array or a JSON stringified array, but ' +\n\t\t\t\"the argument given is of type '\" +\n\t\t\ttypeof input +\n\t\t\t\"'.\"\n\t\t);\n\t/* Reading the options */\n\tif (is_number(mode)) mode = mode_from_number_code(mode);\n\tif (is_string(mode)) {\n\t\tvar with_spaces = among('S', mode);\n\t\tvar with_morphology = among('M', mode);\n\t\tvar with_terminators = among('T', mode);\n\t\tvar with_trimming = !among('R', mode);\n\t\tvar with_selmaho = among('C', mode);\n\t\tvar with_nodes_labels = among('N', mode);\n\t\tvar with_json_format = among('J', mode);\n\t\tvar with_indented_json = among('I', mode);\n\t\tvar without_leaf_prefix = among('!', mode);\n\t\tvar with_glossing = among('G', mode);\n\t} else throw 'camxes_postprocessing(): Invalid mode argument type!';\n\t/* Calling the postprocessor */\n\tvar output = newer_postprocessor(\n\t\tinput,\n\t\twith_morphology,\n\t\twith_spaces,\n\t\twith_terminators,\n\t\twith_trimming,\n\t\twith_selmaho,\n\t\twith_nodes_labels,\n\t\twithout_leaf_prefix,\n\t\twith_glossing\n\t);\n\tif (output === null) output = [];\n\t/* Converting the parse tree into JSON format */\n\toutput = JSON.stringify(output, undefined, with_indented_json ? 2 : 0);\n\tif (with_json_format || with_indented_json) return output;\n\t/* Getting rid of ⟨\"⟩ and ⟨,⟩ characters */\n\toutput = output.replace(/\\\"/gm, '');\n\tif (with_selmaho) output = output.replace(/\\[([a-zA-Z0-9_-]+),\\[/gm, '[$1: [');\n\toutput = output.replace(/,/gm, ' ');\n\t/* Bracket prettification */\n\treturn prettify_brackets(output);\n}\n\n/* Function for translating the legacy option encoding to the new format. */\n/* For backward compatibility. */\nfunction mode_from_number_code(legacy_mode) {\n\tvar mode = '';\n\tif (legacy_mode & 8) mode += 'S';\n\tif (legacy_mode & 16) mode += 'M';\n\tlegacy_mode = legacy_mode % 8;\n\tif (legacy_mode == 0) mode += 'I';\n\tif (legacy_mode == 1) mode += 'J';\n\tif (legacy_mode <= 1) mode += 'R';\n\tif (legacy_mode > 2 && legacy_mode != 5) mode += 'C';\n\tif (legacy_mode == 4 || legacy_mode == 7) mode += 'N';\n\tif (legacy_mode < 5) mode += 'T';\n\treturn mode;\n}\n\n// ========================================================================== //\n\n/*\n * This function adapts the options passed as arguments into a format adapted\n * to the more generalized 'process_parse_tree' function, and then calls this\n * latter.\n */\nfunction newer_postprocessor(\n\tparse_tree,\n\twith_morphology,\n\twith_spaces,\n\twith_terminators,\n\twith_trimming,\n\twith_selmaho,\n\twith_nodes_labels,\n\twithout_leaf_prefix,\n\twith_glossing\n) {\n\tif (!is_array(parse_tree)) return null;\n\t/* Building a map of node names to node value replacements */\n\tif (with_spaces) var value_substitution_map = { spaces: '_', initial_spaces: '_' };\n\telse var value_substitution_map = {};\n\t/* Building a map of node names to name replacements */\n\tvar name_substitution_map = {\n\t\t// \"cmene\": \"C\", \"cmevla\": \"C\", \"gismu\": \"G\", \"lujvo\": \"L\",\n\t\t// \"fuhivla\": \"Z\", \"prenex\": \"PRENEX\", \"sentence\": \"BRIDI\",\n\t\t// \"selbri\": \"SELBRI\", \"sumti\": \"SUMTI\"\n\t\troot: 'R',\n\t\tfreeform_content: 'F'\n\t};\n\n\tif (!with_trimming) name_substitution_map = {};\n\t/** Building a node_action_for() function from the selected options **/\n\tif (with_morphology)\n\t\tvar is_flattening_target = function(tree) {\n\t\t\treturn false;\n\t\t};\n\telse\n\t\tvar is_flattening_target = function(tree) {\n\t\t\tvar targets = SPECIAL_FAMILIES;\n\t\t\treturn among(tree[0], targets) || is_family(tree[0]);\n\t\t};\n\tvar is_branch_removal_target = function(tree) {\n\t\tif (!with_spaces && among(tree[0], [ 'spaces', 'initial_spaces' ])) return true;\n\t\treturn !with_terminators && is_family(tree[0]) && tree.length == 1;\n\t};\n\tvar whitelist = [];\n\tif (with_selmaho) whitelist = whitelist.concat(SPECIAL_FAMILIES);\n\t// if (with_nodes_labels)\n\t//     whitelist = whitelist.concat([\"prenex\", \"sentence\", \"selbri\", \"sumti\"]);\n\tvar is_node_trimming_target = function(tree) {\n\t\tif (!with_trimming) return false;\n\t\tif (with_terminators && is_family(tree[0]) && tree.length == 1) return false;\n\t\tif (with_selmaho && is_family(tree[0])) return false;\n\t\treturn !among(tree[0], whitelist);\n\t};\n\tvar node_action_for = function(node) {\n\t\tif (is_branch_removal_target(node)) return 'DEL';\n\t\tvar ft = is_flattening_target(node);\n\t\tvar tt = is_node_trimming_target(node);\n\t\tif (ft && tt) return 'TRIMFLAT';\n\t\tif (ft) return 'FLAT';\n\t\tif (tt) return 'TRIM';\n\t\tif (with_trimming && node.length == 1) return 'UNBOX';\n\t\treturn 'PASS';\n\t};\n\t/* Calling process_parse_tree() with the arguments we've built for it */\n\treturn process_parse_tree(\n\t\tparse_tree,\n\t\tvalue_substitution_map,\n\t\tname_substitution_map,\n\t\tnode_action_for,\n\t\t(with_nodes_labels || with_selmaho) && !without_leaf_prefix,\n\t\twith_glossing\n\t);\n}\n\n/*\n * Recursive function for editing a parse tree. Performs a broad range of\n * editions depending on the given arguments. Returns the edited parse tree.\n * \n * • value_substitution_map [Map]:\n *     A map of node names to node value replacements. Used to override the\n *     content of specific leaf nodes.\n * • name_substitution_map [Map]:\n *     A map of node names to node name replacements. Used to rename specific\n *     nodes.\n * • node_action_for [Function: Array -> String]:\n *     A function for deriving the appropriate edition action for the argument\n *     parse tree node; returns an action name, whose possible values are:\n *     • 'DEL':  Triggers deletion of the current tree branch.\n *     • 'TRIM': Triggers pruning of the current node; the node name is erased\n *               and if it has only one child node, this child node replaces it.\n *     • 'FLAT': Triggers flattening of the current tree branch; all its\n *               terminal leaves values are concatenated and the concatenation\n *               results replaces the content of the branch.\n *     • 'TRIMFLAT': Same as 'FLAT' but also removes the current node.\n *     • 'UNBOX':    If the current node contains only one element, this element\n *                   replaces the current node.\n *     • 'PASS':     Does nothing.\n * • must_prefix_leaf_labels [Boolean]:\n *     If true, remaining node names get a colon appended to them, and if they\n *     contain a single leaf value, they get concatenated with their value, and\n *     the concatenation result would replace the node itself.\n *     For example, a terminal node [\"UI\",\"ui\"] would become \"UI:ui\" (note that\n *     the brackets disappeared).\n */\nfunction process_parse_tree(\n\tparse_tree,\n\tvalue_substitution_map,\n\tname_substitution_map,\n\tnode_action_for,\n\tmust_prefix_leaf_labels,\n\twith_glossing\n) {\n\tif (parse_tree.length == 0) return null;\n\tvar action = node_action_for(parse_tree);\n\tif (action == 'DEL') return null; // Deleting the current branch.\n\tvar has_name = is_string(parse_tree[0]);\n\t// Getting the value replacement for this node, if any.\n\tvar substitution_value = has_name ? value_substitution_map[parse_tree[0]] : undefined;\n\tif (has_name) {\n\t\tif (action == 'TRIM') {\n\t\t\t/* If there's a value replacement for this node, we return it\n               instead of the node's content. */\n\t\t\tif (typeof substitution_value !== 'undefined') return substitution_value;\n\t\t\t/* Otherwise the first step of a trim action is to remove the node\n               name. */\n\t\t\tparse_tree.splice(0, 1);\n\t\t\thas_name = false;\n\t\t} else {\n\t\t\t/* No trimming, so let's see if the node name is in the renaming\n               list. If so, let's rename it accordingly. */\n\t\t\tvar v = name_substitution_map[parse_tree[0]];\n\t\t\tif (typeof v !== 'undefined') parse_tree[0] = v;\n\t\t\t/* If there's a value replacement for this node, it becomes the\n               unique value for the node. */\n\t\t\tif (typeof substitution_value !== 'undefined') return [ parse_tree[0], substitution_value ];\n\t\t}\n\t}\n\tif (action == 'FLAT') {\n\t\t/* Flattening action. All the terminal nodes of the branch are\n           concatenated, and the concatenation result replaces the branch's\n           content, alongside the node name if any. If the concatenation\n           result is empty, the branch becomes empty. */\n\t\tvar r = join_expr(parse_tree);\n\t\tif (has_name && r != '') {\n\t\t\tif (must_prefix_leaf_labels) return parse_tree[0] + ':' + r;\n\t\t\telse return [ parse_tree[0], r ];\n\t\t} else if (has_name) return parse_tree[0];\n\t\telse return r;\n\t} else if (action == 'TRIMFLAT') return join_expr(parse_tree);\n\t/* Now we'll iterate over all the other elements of the current node. */\n\tvar i = has_name ? 1 : 0;\n\twhile (i < parse_tree.length) {\n\t\tif (is_array(parse_tree[i])) {\n\t\t\t/* Recursion */\n\t\t\tparse_tree[i] = process_parse_tree(\n\t\t\t\tparse_tree[i],\n\t\t\t\tvalue_substitution_map,\n\t\t\t\tname_substitution_map,\n\t\t\t\tnode_action_for,\n\t\t\t\tmust_prefix_leaf_labels,\n\t\t\t\twith_glossing\n\t\t\t);\n\t\t}\n\t\t/* The recursion call on the current element might have set it to null\n           as a request for deletion. */\n\t\tif (parse_tree[i] === null) parse_tree.splice(i, 1);\n\t\telse i++; // No deletion, so let's go to the next element.\n\t}\n\t/* Now we've finished iterating over the node elements. Let's proceed to\n       the final steps. */\n\t/* If 'must_prefix_leaf_labels' is set and the node has a name and contains\n       at least one other element, we append ':' to its name. */\n\t//    if (has_name && parse_tree.length >= 2 && must_prefix_leaf_labels) {\n\t//        parse_tree[0] += ':';\n\t//    }\n\t/* If the node is empty, we return null as a signal for deletion. */\n\tif (i == 0) return null;\n\telse if (i == 1 && action != 'PASS') {\n\t\t/* If the node contains only one element and we want to trim the node,\n       it gets replaced by its content. */\n\n\t\t// if (with_glossing && glosser.words[parse_tree[0]]) {\n\t\t// \tparse_tree[0] = \"'\" + glosser.words[parse_tree[0]].short + \"'\";\n\t\t// }\n\t\treturn parse_tree[0];\n\t} else if (must_prefix_leaf_labels && i == 2 && has_name && is_string(parse_tree[1])) {\n\t\t/* If 'must_prefix_leaf_labels' is set and the node is a pair of string,\n       we return the concatenation of both strings separated with a colon. */\n\t\tif (!parse_tree[1].includes(':')) return parse_tree[0] + ':' + parse_tree[1];\n\t\telse parse_tree[0] += ':';\n\t}\n\treturn parse_tree;\n}\n\n// ========================================================================== //\n\n/* This function returns the string resulting from the recursive concatenation\n * of all the leaf elements of the parse tree argument (except node names). */\n// \"join_leaves\" or \"flatten_tree\" might be better names.\nfunction join_expr(n) {\n\tif (n.length < 1) return '';\n\tvar s = '';\n\tvar i = is_array(n[0]) ? 0 : 1;\n\twhile (i < n.length) {\n\t\ts += is_string(n[i]) ? n[i] : join_expr(n[i]);\n\t\ti++;\n\t}\n\treturn s;\n}\n\nfunction among(v, s) {\n\tvar i = 0;\n\twhile (i < s.length) if (s[i++] == v) return true;\n\treturn false;\n}\n\n// function is_family(v) {\n// \tif (!is_string(v)) return false;\n// \t// return v.startsWith(\"p_\");\n// \treturn 0 == v.search(/^[BCDFGJKLMNPRSTVXZ]?([AEIOUQH])+$/g);\n// }\n\n// ========================================================================== //\n\n/*\n * Bracket prettification for textual rendering of parse trees.\n */\nfunction prettify_brackets(str) {\n\tvar open_brackets = [ '(', '[', '{', '<' ];\n\tvar close_brackets = [ ')', ']', '}', '>' ];\n\tvar brackets_number = 4;\n\t//\tvar numset = ['0','1','2','3','4','5','6','7','8','9'];\n\tvar numset = [ '\\u2070', '\\u00b9', '\\u00b2', '\\u00b3', '\\u2074', '\\u2075', '\\u2076', '\\u2077', '\\u2078', '\\u2079' ];\n\tvar i = 0;\n\tvar floor = 0;\n\twhile (i < str.length) {\n\t\tif (str[i] == '[') {\n\t\t\tvar n = floor % brackets_number;\n\t\t\tvar num = floor && !n ? str_print_uint(floor / brackets_number, numset) : '';\n\t\t\tstr = str_replace(str, i, 1, open_brackets[n] + num);\n\t\t\tfloor++;\n\t\t} else if (str[i] == ']') {\n\t\t\tfloor--;\n\t\t\tvar n = floor % brackets_number;\n\t\t\tvar num = floor && !n ? str_print_uint(floor / brackets_number, numset) : '';\n\t\t\tstr = str_replace(str, i, 1, num + close_brackets[n]);\n\t\t}\n\t\ti++;\n\t}\n\treturn str;\n}\n\n/* ================== */\n/* ===  Routines  === */\n/* ================== */\n\nfunction str_print_uint(val, charset) {\n\t// 'charset' must be a character array.\n\tvar radix = charset.length;\n\tvar str = '';\n\tval -= val % 1; // No float allowed\n\twhile (val >= 1) {\n\t\tstr = charset[val % radix] + str;\n\t\tval /= radix;\n\t\tval -= val % 1;\n\t}\n\treturn str;\n}\n\nfunction str_replace(str, pos, len, sub) {\n\tif (pos < str.length) {\n\t\tif (pos + len >= str.length) len -= pos + len - str.length;\n\t\treturn str.substring(0, pos) + sub + str.substring(pos + len);\n\t} else return str;\n}\n\nmodule.exports.postprocessing = camxes_postprocessing;\nmodule.exports.postprocess = camxes_postprocessing; // Alias\nmodule.exports.process_parse_tree = process_parse_tree;\nmodule.exports.prettify_brackets = prettify_brackets;\n\n//# sourceURL=webpack://bundle/./src/process_parse_tree.js?");

/***/ }),

/***/ "./src/simplify_tree.js":
/*!******************************!*\
  !*** ./src/simplify_tree.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { is_string } = __webpack_require__(/*! ./util */ \"./src/util.js\");\n\n// List of important types in eberban that we want to show up in the simplified\n// tree.\nconst important_types = [\n\t// text\n\t[ 'text', 'text' ],\n\t[ 'paragraph', 'paragraph' ],\n\t[ 'paragraph_unit', 'paragraph unit' ],\n\t[ 'paragraph_unit_erased', 'erased' ],\n\t[ 'definition', 'definition' ],\n\t[ 'sentence', 'sentence' ],\n\t[ 'axiom', 'axiom' ],\n\t[ 'default', 'default' ],\n\n\t// scope\t\n\t[ 'scope', 'scope' ],\n\t[ 'scope_sequence', 'sequence' ],\n\t[ 'scope_sequence_item', 'sequence item' ],\n\t[ 'chaining', 'chaining' ],\n\t[ 'chaining_neg', 'chaining negation' ],\n\t[ 'chaining_unit', 'chaining unit' ],\n\t[ 'vi_scope', 'VI-scope' ],\n\t[ 'vi_scope_first', 'explicit bind' ],\n\t[ 'vi_scope_next', 'explicit bind' ],\n\t[ 'arguments_list', 'arguments' ],\n\n\t// predicates\n\t[ 'predicate', 'predicate' ],\n\t[ 'compound', 'compound' ],\n\t[ 'borrowing_group', 'borrowing group' ],\n\t[ 'borrowing', 'borrowing' ],\n\t[ 'freeform_variable', 'freeform variable'],\n\t[ 'freeform_content', 'freeform' ],\n\t[ 'grammatical_quote', 'quote' ],\n\t[ 'one_word_quote', 'word quote' ],\n\t[ 'foreign_quote', 'foreign quote' ],\n\t[ 'foreign_quote_content', 'foreign quote content' ],\n\t[ 'foreign_quote_open', 'foreign quote delimiter' ],\n\t[ 'foreign_quote_close', 'foreign quote delimiter' ],\n\t[ 'unit_number', 'number' ],\n\t[ 'predicate_scope', 'predicate scope' ],\n\n\t// free\n\t[ 'free_metadata', 'metadata' ],\n\t[ 'free_interjection', 'interjection' ],\n\t[ 'free_parenthetical', 'parenthetical' ],\n\t[ 'free_subscript', 'subscript' ],\n\n\t// morphology\n\t[ 'particle_form', 'particle' ],\n\t[ 'root_form', 'root' ]\n];\n\n// List of simplifying functions.\nvar simplifyFunctions = {};\n\n// Fills the simplify functions list with important types.\nfor (let replace of important_types) {\n\tsimplifyFunctions[replace[0]] = function(parse) {\n\t\treturn {\n\t\t\ttype: replace[1],\n\t\t\tchildren: simplifyArrayOfTrees(parse.slice(1))\n\t\t};\n\t};\n}\n\nsimplifyFunctions['foreign_quote_content'] = function(parse) {\n\tlet text = '';\n\n\tparse.slice(1).forEach(x => {\n\t\ttext += x[0];\n\t})\n\n\treturn {\n\t\ttype: 'foreign quote content',\n\t\tword: text,\n\t}\n}\n\nvar importantTypesMap = {};\n\n// Convert important types array to map.\nfor (let type of important_types) {\n\timportantTypesMap[type[0]] = type[1];\n}\n\n\n/**\n * This file contains functions that simplify the parse tree returned by camxes.js.\n * \n * The original parse tree has the following structure:\n * [\n *   \"...\",   // the type\n *   ...      // children as array elements\n * ]\n * Here, the first element of every array indicates the type of the object parsed, and the\n * next objects are the children of the element.\n * \n * The simplified parse tree has quite another structure:\n * [\n *   {\n *     type: \"...\",\n *     children: [ ... ],   // only one of children and word\n *     word: \"...\",\n *     ...: ...             // other optional elements\n *   }\n * ]\n * Here, type gives the type. For non-terminals, children is an array containing the children.\n * For terminals, word contains the actual word parsed. (Of course, one cannot have both\n * children and word.) Furthermore, there can be more elements added to this structure to add\n * additional information as needed.\n */\n\n/**\n * Simplifies the given parse tree. Returns an array.\n */\nfunction simplifyTree(parse) {\n\t// if it is a terminal, just return that\n\tif (parse.length == 2 && is_string(parse[0]) && is_string(parse[1])) {\n\t\tlet type = parse[0];\n\n\t\tif (importantTypesMap[type] != undefined)\n\t\t\ttype = importantTypesMap[type];\n\n\t\treturn [\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tword: parse[1]\n\t\t\t}\n\t\t];\n\t}\n\n\tvar f = simplifyFunctions[parse[0]];\n\n\t// if there is a simplification function, apply it\n\tif (f) {\n\t\treturn [ f(parse) ];\n\t}\n\n\t// else, we recursively search the children for things we do have a simplification function for\n\tvar result;\n\tif (is_string(parse[0])) {\n\t\tresult = simplifyArrayOfTrees(parse.slice(1));\n\t} else {\n\t\tresult = simplifyArrayOfTrees(parse);\n\t}\n\n\treturn result;\n}\n\n/**\n * Simplifies an array of trees.\n */\nfunction simplifyArrayOfTrees(parse) {\n\tvar result = [];\n\n\tfor (var i in parse) {\n\t\tresult = result.concat(simplifyTree(parse[i]));\n\t}\n\n\treturn result;\n}\n\nmodule.exports.simplifyTree = simplifyTree;\n\n//# sourceURL=webpack://bundle/./src/simplify_tree.js?");

/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/***/ ((module) => {

eval("function remove_spaces(tree) {\n    if (tree.length > 0 && among(tree[0], [\"spaces\", \"initial_spaces\"])) return null;\n    var i = 0;\n    while (i < tree.length) {\n        if (is_array(tree[i])) {\n            tree[i] = remove_spaces(tree[i]);\n            if (tree[i] === null) tree.splice(i--, 1);\n        }\n        i++;\n    }\n    return tree;\n}\n\n/*\n * EXAMPLE OF PARSE TREE PRUNING PROCEDURE\n * \n * remove_morphology(parse_tree)\n * \n * This function takes a parse tree, and joins the expressions of the following\n * nodes:\n * \"cmevla\", \"gismu_2\", \"lujvo\", \"fuhivla\", \"spaces\"\n * as well as any selmaho node (e.g. \"KOhA\").\n * \n */\n\nfunction remove_morphology(pt) {\n    if (pt.length < 1) return [];\n    var i;\n    /* Sometimes nodes have no label and have instead an array as their first\n       element. */\n    if (is_array(pt[0])) i = 0;\n    else { // The first element is a label (node name).\n        // Let's check if this node is a candidate for our pruning.\n        if (is_target_node(pt)) {\n            /* We join recursively all the terminal elements (letters) in this\n             * node and its child nodes, and put the resulting string in the #1\n             * slot of the array; afterwards we delete all the remaining elements\n             * (their terminal values have been concatenated into pt[1]). */\n            pt[1] = join_expr(pt);\n            // If pt[1] contains an empty string, let's delete it as well:\n            pt.splice((pt[1] == \"\") ? 1 : 2);\n            return pt;\n        }\n        i = 1;\n    }\n    /* If we've reached here, then this node is not a target for pruning, so let's\n       do recursion into its child nodes. */\n    while (i < pt.length) {\n        if (is_array(pt[i])) remove_morphology(pt[i]);\n        i++;\n    }\n    return pt;\n}\n\n/* This function returns the string resulting from the recursive concatenation of\n * all the leaf elements of the parse tree argument (except node names). */\nfunction join_expr(n) {\n    if (n.length < 1) return \"\";\n    var s = \"\";\n    var i = is_array(n[0]) ? 0 : 1;\n    while (i < n.length) {\n        s += is_string(n[i]) ? n[i] : join_expr(n[i]);\n        i++;\n    }\n    return s;\n}\n\n/* Checks whether the argument node is a target for pruning. */\nfunction is_target_node(n) {\n    return (among(n[0], SPECIAL_FAMILIES) || is_family(n[0]));\n}\n\nconst SPECIAL_FAMILIES = [\n    \"particle_form\",\n    \"root_form\",\n    \"borrowing\",\n    \"freeform_variable\",\n    \"foreign_quote_content\",\n    \"foreign_quote_open\",\n    \"foreign_quote_close\",\n];\n\nfunction among(v, s) {\n    var i = 0;\n    while (i < s.length) if (s[i++] == v) return true;\n    return false;\n}\n\nfunction is_family(v) {\n    if (!is_string(v)) return false;\n    return 0 == v.search(/^[BCDFGJKLMNPRSTVXZ]?([AEIOUH])+$/g);\n}\n\nfunction is_string(v) {\n    return Object.prototype.toString.call(v) === '[object String]';\n}\n\nfunction is_array(v) {\n    return Object.prototype.toString.call(v) === '[object Array]';\n}\n\nfunction is_number(v) {\n\treturn Object.prototype.toString.call(v) === '[object Number]';\n}\n\nmodule.exports.remove_spaces = remove_spaces;\nmodule.exports.remove_morphology = remove_morphology;\nmodule.exports.join_expr = join_expr;\nmodule.exports.is_target_node = is_target_node;\nmodule.exports.among = among;\nmodule.exports.is_family = is_family;\nmodule.exports.is_string = is_string;\nmodule.exports.is_array = is_array;\nmodule.exports.is_number = is_number;\nmodule.exports.SPECIAL_FAMILIES = SPECIAL_FAMILIES;\n\n//# sourceURL=webpack://bundle/./src/util.js?");

/***/ }),

/***/ "./webpack/parser.js":
/*!***************************!*\
  !*** ./webpack/parser.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"camxes\": () => (/* binding */ camxes),\n/* harmony export */   \"postprocessing\": () => (/* binding */ postprocessing),\n/* harmony export */   \"parse\": () => (/* binding */ parse)\n/* harmony export */ });\nconst { camxes } = __webpack_require__(/*! ../grammar/eberban */ \"./grammar/eberban.js\");\nconst { remove_morphology, remove_spaces } = __webpack_require__(/*! ../src/util */ \"./src/util.js\");\nconst { simplifyTree } = __webpack_require__(/*! ../src/simplify_tree */ \"./src/simplify_tree.js\");\nconst { postprocessing } = __webpack_require__(/*! ../src/process_parse_tree */ \"./src/process_parse_tree.js\");\n\nconst { dictionary_en: dictionary } = __webpack_require__(/*! ../src/dictionary */ \"./src/dictionary.js\");\n\nconst hideTitleList = [\n\t'paragraph',\n\t'paragraph unit',\n\t'sentence',\n\t'axiom',\n\t'definition',\n\t'scope',\n\t'sequence item',\n\t'predicate',\n\t'chaining unit',\n\t'chaining negation',\n\t'VI-scope',\n\t'borrowing group',\n\t'erased',\n\t'default'\n];\n\nconst hideFamily = [\n\t'a',\n\t'e',\n\t'i',\n\t'o',\n\t'u',\n\t'freeform_content',\n\t'foreign quote content',\n\t'foreign quote delimiter',\n]\n\n// List of types with their associated CSS classes.\nconst boxClassForTypeMap = new Map([\n\t// text\n\t[ 'paragraph', 'box box-paragraph' ],\n\t[ 'paragraph unit', 'box box-paragraph-unit' ],\n\t[ 'erased', 'erased' ],\n\t[ 'default', 'box box-sentence' ],\n\t[ 'sentence', 'box box-sentence' ],\n\t[ 'definition', 'box box-sentence' ],\n\t[ 'axiom', 'box box-sentence' ],\n\t[ 'arguments', 'box box-arguments' ],\n\t[ 'defined predicate', 'box box-arguments' ],\n\n\t// scope\n\t[ 'scope', 'box box-scope' ],\n\t[ 'sequence item', 'box box-scope-highlight' ],\n\t[ 'chaining unit', 'box box-chaining-unit' ],\n\t[ 'chaining negation', 'box box-chaining-neg' ],\n\t[ 'VI-scope', 'box box-vi-scope' ],\n\n\t// units\n\t[ 'predicate', 'box box-predicate' ],\n\t[ 'quote', 'box box-predicate' ],\n\t[ 'word quote', 'box box-predicate' ],\n\t[ 'foreign quote', 'box box-borrowing foreign-quote' ],\n\t[ 'compound', 'box box-compound' ],\n\t[ 'number', 'box box-number' ],\n\t[ 'letters', 'box box-letters' ],\n\t[ 'subscope', 'box box-subscope' ],\n\t[ 'borrowing group', 'box box-borrowing' ],\n\t[ 'foreign quote content', 'box box-not-shown foreign-quote-content'],\n\n\t// free\n\t[ 'metadata', 'box box-metadata' ],\n\t[ 'interjection', 'box box-note' ],\n\t[ 'parenthetical', 'box box-note' ],\n]);\n\nfunction boxClassForType(parse) {\n\tlet boxClass = boxClassForTypeMap.get(parse.type);\n\treturn boxClass || 'box box-not-shown';\n}\n\nfunction escapeHtml(str) {\n\tvar p = document.createElement('p');\n\tp.appendChild(document.createTextNode(str));\n\treturn p.innerHTML;\n}\n\n/**\n * Launches the parsing process by calling the parser with the data entered in the interface,\n * and processing the results.\n */\nfunction parse() {\n\tvar textToParse = $('#input_textarea').val();\n\t$('#result-row').slideDown();\n\n\tif(textToParse.length == 0) {\n\t\t$('#parse-result-raw').html(\"\");\n\t\t$('#parse-result-tree').html(\"\");\n\t\t$('#parse-result-simplified').html(\"\");\n\t\t$('#parse-result-boxes').html(\"\");\n\t\t$('#parse-result-glossing').html(\"\");\n\t\treturn;\n\t}\n\n\ttry {\n\t\tvar start = new Date().getTime();\n\t\ttextToParse = ' ' + textToParse; // add initial space to help parser\n\t\tvar parse = camxes.parse(textToParse);\n\t\tvar end = new Date().getTime();\n\t\t$('#time-label').html('(parsing took ' + (end - start) + ' ms)');\n\t\tparse = remove_morphology(parse);\n\t\tparse = remove_spaces(parse);\n\t\tvar simplified = simplifyTree(parse);\n\n\t\tif (parse) {\n\t\t\tvar tokens = [];\n\t\t\tfindTokens(parse, tokens);\n\n\t\t\t// var $parseResultHighlighted = $('#parse-result-highlighted');\n\t\t\t// showHighlighting(simplified[0], tokens, $parseResultHighlighted);\n\n\t\t\tvar $parseResultRaw = $('#parse-result-raw');\n\t\t\tshowRawTree(parse, $parseResultRaw);\n\n\t\t\tvar $parseResultTree = $('#parse-result-tree');\n\t\t\tshowParseTree(parse, $parseResultTree);\n\n\t\t\tvar $parseResultSimplified = $('#parse-result-simplified');\n\t\t\tshowSimplifiedTree(simplified, $parseResultSimplified);\n\n\t\t\tvar $parseResultBoxes = $('#parse-result-boxes');\n\t\t\tshowBoxes(simplified, $parseResultBoxes);\n\n\t\t\tvar $parseResultGlossing = $('#parse-result-glossing');\n\t\t\tshowGlossing(tokens, $parseResultGlossing);\n\t\t}\n\t\t// $('#parse-result-highlighted-tab').html('Highlighted');\n\t\t$('#parse-result-tree-tab').html('Parse tree');\n\t\t$('#parse-result-raw-tab').html('Raw tree');\n\t\t$('#parse-result-simplified-tab').html('Simplified tree');\n\t\t$('#parse-result-boxes-tab').html('Boxes');\n\t\t$('#parse-result-glossing-tab').html('Glosses');\n\t} catch (e) {\n\t\tif (e.name && e.name === 'SyntaxError') {\n\t\t\t// $('#parse-result-highlighted-tab').html('<span class=\"muted\">Highlighted</span>');\n\t\t\t// showSyntaxError(e, textToParse, $('#parse-result-highlighted'));\n\t\t\t$('#parse-result-raw-tab').html('<span class=\"muted\">Raw tree</span>');\n\t\t\tshowSyntaxError(e, textToParse, $('#parse-result-raw'));\n\t\t\t$('#parse-result-simplified-tab').html('<span class=\"muted\">Simplified tree</span>');\n\t\t\tshowSyntaxError(e, textToParse, $('#parse-result-simplified'));\n\t\t\t$('#parse-result-tree-tab').html('<span class=\"muted\">Parse tree</span>');\n\t\t\tshowSyntaxError(e, textToParse, $('#parse-result-tree'));\n\t\t\t$('#parse-result-boxes-tab').html('<span class=\"muted\">Boxes</span>');\n\t\t\tshowSyntaxError(e, textToParse, $('#parse-result-boxes'));\n\t\t\t$('#parse-result-glossing-tab').html('<span class=\"muted\">Glosses</span>');\n\t\t\tshowSyntaxError(e, textToParse, $('#parse-result-glossing'));\n\t\t} else {\n\t\t\tthrow e;\n\t\t}\n\t}\n}\n\n/**\n * Finds all tokens in the resulting parse tree, and puts them in the tokens array.\n */\nfunction findTokens(parse, tokens) {\n\tif (parse instanceof Array) {\n\t\tif (parse.length == 2 && isString(parse[0]) && isString(parse[1])) {\n\t\t\ttokens.push(parse[1]);\n\t\t} else {\n\t\t\tfor (var child in parse) {\n\t\t\t\tfindTokens(parse[child], tokens);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Shows the parse result in the interface.\n */\nfunction showRawTree(parse, $element) {\n\t$element.html('<pre>' + JSON.stringify(parse, undefined, 2) + '</pre>');\n}\n\n/**\n * Shows the parse result in the interface.\n */\nfunction showParseTree(parse, $element) {\n\t$element.html(constructParseTreeOutput(parse, 0));\n}\n\nfunction constructParseTreeOutput(parse, depth) {\n\t// precaution against infinite recursion; this should not actually happen of course\n\tif (depth > 50) {\n\t\treturn '<b>too much recursion :-(</b>';\n\t}\n\n\t// if we get null, just print that\n\tif (parse === null) {\n\t\treturn '<i>(none?)</i>';\n\t}\n\n\t// if we get undefined, just print that\n\tif (!parse) {\n\t\treturn '<i>(undefined?)</i>';\n\t}\n\n\tif (parse instanceof Array) {\n\t\tif (parse.length == 0) {\n\t\t\treturn '<i>(empty array?)</i>';\n\t\t}\n\n\t\tvar output = '';\n\n\t\t// what is the type of parse[0]?\n\t\tif (isString(parse[0])) {\n\t\t\t// it is the type\n\t\t\toutput += parse[0] + ':';\n\n\t\t\tif (isString(parse[1])) {\n\t\t\t\t// a literal\n\t\t\t\toutput += ' <b>[' + parse[1] + ']</b>';\n\t\t\t\tif (dictionary[parse[1]]) {\n\t\t\t\t\toutput += ' <span class=\"translation\">' + dictionary[parse[1]].gloss + '</span>';\n\t\t\t\t}\n\t\t\t\treturn output;\n\t\t\t}\n\n\t\t\toutput += '<ul>';\n\t\t\tfor (var child in parse) {\n\t\t\t\tif (child !== '0') {\n\t\t\t\t\toutput += '<li>' + constructParseTreeOutput(parse[child], depth + 1) + '</li>';\n\t\t\t\t}\n\t\t\t}\n\t\t\toutput += '</ul>';\n\t\t\treturn output;\n\t\t} else {\n\t\t\toutput += '<i>a list:</i>';\n\t\t\toutput += '<ol>';\n\t\t\tfor (var child in parse) {\n\t\t\t\toutput += '<li>' + constructParseTreeOutput(parse[child], depth + 1) + '</li>';\n\t\t\t}\n\t\t\toutput += '</ol>';\n\t\t\treturn output;\n\t\t}\n\t}\n\n\treturn '<i>(huh? ' + parse + ')</i>';\n}\n\n/**\n * Shows the simplified parse tree in the interface.\n */\nfunction showSimplifiedTree(simplified, $element) {\n\t$element.html(constructSimplifiedTreeOutput(simplified[0], 0));\n}\n\nfunction constructSimplifiedTreeOutput(parse, depth) {\n\t// precaution against infinite recursion; this should not actually happen of course\n\tif (depth > 50) {\n\t\treturn '<b>too much recursion :-(</b>';\n\t}\n\n\t// if we get null, just print that\n\tif (parse === null) {\n\t\treturn '<i>(none?)</i>';\n\t}\n\n\t// if we get undefined, just print that\n\tif (!parse) {\n\t\treturn '<i>(undefined?)</i>';\n\t}\n\n\tvar output = parse.type;\n\n\tif (parse.word) {\n\t\t// we have a terminal\n\t\tif (parse.type == 'foreign quote content') {\n\t\t\toutput += ' <b>[<span class=\"foreign-quote-content\">' + escapeHtml(parse.word) + '</span>]</b>';\n\t\t} else {\n\t\t\toutput += ' <b>[' + parse.word + ']</b>';\n\t\t}\n\t\tif (dictionary[parse.word]) {\n\t\t\toutput += ' <span class=\"translation\">' + dictionary[parse.word].gloss + '</span>';\n\t\t}\n\t} else {\n\t\t// we have a non-terminal\n\n\t\toutput += '<ul>';\n\n\t\tfor (var child in parse.children) {\n\t\t\toutput += '<li>';\n\t\t\toutput += constructSimplifiedTreeOutput(parse.children[child], depth + 1);\n\t\t\toutput += '</li>';\n\t\t}\n\n\t\toutput += '</ul>';\n\t}\n\n\treturn output;\n}\n\n/**\n * Shows the boxes in the interface.\n */\nfunction showBoxes(simplified, $element) {\n\tvar output = '';\n\n\toutput += constructBoxesOutput(simplified[0], 0);\n\n\t/*output += \"<p>Legend: \";\n\tvar types = [\"sentence\", \"prenex\", \"selbri\", \"sumti\"];\n\tfor (var type in types) {\n\t\toutput += \"<div class=\\\"\" + boxClassForType({ type: types[type] }) + \"\\\">\" + types[type] + \"</div>\";\n\t}\n\toutput += \"</p>\";*/\n\n\t$element.html(output);\n}\n\nfunction constructBoxesOutput(parse, depth) {\n\t// precaution against infinite recursion; this should not actually happen of course\n\tif (depth > 50) {\n\t\treturn '<b>too much recursion :-(</b>';\n\t}\n\n\t// if we get null, just print that\n\tif (parse === null) {\n\t\treturn '<i>(none?)</i>';\n\t}\n\n\t// if we get undefined, just print that\n\tif (!parse) {\n\t\treturn '<i>(undefined?)</i>';\n\t}\n\n\tvar output = '';\n\n\tif (parse.word) {\n\t\toutput += '<div class=\"box box-terminal';\n\t\t\n\t\tif (parse.css_classes != undefined) {\n\t\t\toutput += ` ${parse.css_classes}`;\n\t\t}\n\n\t\tif (parse.type == 'foreign quote content') {\n\t\t\toutput += \" foreign-quote-content\";\n\t\t}\n\t\t\n\t\toutput += '\">';\n\n\t\t// we have a terminal\n\t\toutput += '&nbsp;<div class=\"tip\">' + escapeHtml(parse.word);\n\n\t\tif (hideFamily.includes(parse.type)) {\n\t\t\toutput += '</div>&nbsp;<br></div>';\n\t\t\treturn output;\n\t\t}\n\n\t\tif (dictionary[parse.word] && dictionary[parse.word].short) {\n\t\t\toutput += '<div class=\"tiptext\">' + escapeHtml(dictionary[parse.word].short) + '</div>';\n\t\t}\n\n\t\toutput += '</div>&nbsp;<br>&nbsp;' + parse.type + '&nbsp;<br>';\n\t\t// escapeHtml(words[text[j]].short)\n\n\t\tif (dictionary[parse.word]) {\n\t\t\tlet short = dictionary[parse.word].gloss;\n\t\t\tif (short) {\n\t\t\t\toutput += '<span class=\"translation\">&nbsp;' + escapeHtml(short) + '&nbsp;</span>';\n\t\t\t}\n\t\t} else if (['KI', 'GI', 'borrowing', \"freeform variable\"].includes(parse.type)) {\n\t\t\toutput += '';\n\t\t} else {\n\t\t\toutput += '...';\n\t\t}\n\n\t\toutput += '</div>';\n\t} else {\n\t\t// we have a non-terminal\n\n\t\toutput += '<div class=\"' + boxClassForType(parse);\n\n\t\tif (parse.css_classes != undefined) {\n\t\t\toutput += ` ${parse.css_classes}`;\n\t\t}\n\n\t\toutput += '\">';\n\n\t\t// handle erased scope sequence elements\n\t\tif (parse.type === 'sequence')  {\n\t\t\tfor (var child in parse.children) {\n\t\t\t\tif (parse.children[child].word == 'buhu') {\n\t\t\t\t\tparse.children[child].css_classes = 'erased';\n\t\t\t\t\tparse.children[child-1].css_classes = 'erased';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var child in parse.children) {\n\t\t\toutput += constructBoxesOutput(parse.children[child], depth + 1);\n\t\t}\n\n\t\tif (boxClassForType(parse) !== 'box box-not-shown') {\n\t\t\tif (!hideTitleList.includes(parse.type)) {\n\t\t\t\tif (parse.type === 'compound') {\n\t\t\t\t\tlet compound_text = [];\n\t\t\t\t\tlet compound = '';\n\n\t\t\t\t\tfor (var child in parse.children) {\n\t\t\t\t\t\tif (parse.children[child].word) {\n\t\t\t\t\t\t\tcompound_text.push(parse.children[child].word);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (compound_text[0] == 'e') {\n\t\t\t\t\t\tcompound = 'e' + extractCanonicalCompound(compound_text, 1, 2).compound;\n\t\t\t\t\t} else if (compound_text[0] == 'a') {\n\t\t\t\t\t\tcompound += 'a' + extractCanonicalCompound(compound_text, 1, 3).compound;\n\t\t\t\t\t} else if (compound_text[0] == 'o') {\n\t\t\t\t\t\tcompound += 'o' + extractCanonicalCompound(compound_text, 1, -1).compound;\n\t\t\t\t\t}\n\n\t\t\t\t\toutput += '<br><b>' + compound + '</b>';\n\n\t\t\t\t\tif (dictionary[compound]) {\n\t\t\t\t\t\toutput += ' = <div class=\"tip translation\">' + dictionary[compound].gloss;\n\n\t\t\t\t\t\tif (dictionary[compound].short) {\n\t\t\t\t\t\t\toutput += '<div class=\"tiptext\">' + escapeHtml(dictionary[compound].short) + '</div>';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toutput += '&nbsp;</div>';\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput += ' = <div class=\"tip translation\">???</div>';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput += '<br>' + parse.type;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\toutput += '</div>';\n\t}\n\n\treturn output;\n}\n\n/**\n * Shows a syntax error in the interface.\n */\nfunction showSyntaxError(e, textToParse, $element) {\n\tvar output =\n\t\t'<div class=\"alert\">' +\n\t\t'<p><b>Syntax error</b> on line <b>' +\n\t\te.line +\n\t\t'</b>, at column <b>' +\n\t\te.column +\n\t\t'</b>: ' +\n\t\te.message +\n\t\t'</p>' +\n\t\t'<p class=\"error-sentence\">' +\n\t\tgenerateErrorPosition(e, textToParse) +\n\t\t'</p>' +\n\t\tgenerateFixes(e) +\n\t\t'</div>';\n\n\t$element.html(output);\n}\n\n/**\n * Generates the text sample that shows the error position.\n */\nfunction generateErrorPosition(e, textToParse) {\n\t//\"mi vau <span class=\\\"error-marker\\\">&#9652;</span> do cusku ...\" +\n\n\tvar before = textToParse.substring(e.offset - 20, e.offset);\n\n\tvar after = textToParse.substring(e.offset + 0, e.offset + 20);\n\n\tif (e.offset > 20) {\n\t\tbefore = '...' + before;\n\t}\n\tif (e.offset < textToParse.length - 20) {\n\t\tafter = after + '...';\n\t}\n\n\treturn before + '<span class=\"error-marker\">&#9652;</span>' + after;\n}\n\nfunction generateFixes(e) {\n\tif (!e.fix) {\n\t\t//return \"<p><i>No quick fixes available.</i></p>\";\n\t\treturn '';\n\t}\n\n\tvar fixes = '<p>Quick fixes:<ul>';\n\n\tfor (var f in e.fix) {\n\t\tvar fix = e.fix[f];\n\t\tfixes += '<li>';\n\n\t\tif (fix.fixFunction) {\n\t\t\tfixes += '<a>';\n\t\t\tfixes += fix.name;\n\t\t\tfixes += '</a>';\n\t\t} else {\n\t\t\tfixes += fix.name;\n\t\t}\n\n\t\tfixes += '</li>';\n\t}\n\n\tfixes += '</ul></p>';\n\n\treturn fixes;\n}\n\n/**\n * Shows the highlighting in the interface.\n */\nfunction showHighlighting(simplified, tokens, $element) {\n\tvar output = '';\n\n\tvar mode = 1;\n\tvar classString = 'latin-highlighting';\n\n\t// if ($('#latin-button').hasClass('active')) {\n\t// \tvar mode = 1;\n\t// \tvar classString = 'latin-highlighting';\n\t// } else if ($('#cyrillic-button').hasClass('active')) {\n\t// \tvar mode = 2;\n\t// \tvar classString = 'cyrillic-highlighting';\n\t// } else if ($('#tengwar-button').hasClass('active')) {\n\t// \tvar mode = 3;\n\t// \tvar classString = 'tengwar-highlighting';\n\t// } else if ($('#hiragana-button').hasClass('active')) {\n\t// \tvar mode = 4;\n\t// \tvar classString = 'hiragana-highlighting';\n\t// }\n\n\toutput += '<span class=\"highlighting ' + classString + '\"><big>';\n\toutput += markupHighlighting(simplified, mode);\n\toutput += '</big></span>';\n\n\t$element.html(output);\n}\n\nfunction markupHighlighting(simplified, mode) {\n\tvar output = '';\n\tvar beforeOutput = '';\n\tvar afterOutput = ' ';\n\n\tif (simplified.type === 'selbri') {\n\t\tbeforeOutput += '<span class=\"lojban-selbri\">';\n\t\tafterOutput = '</span> ';\n\t} else if (simplified.type === 'modal sumti') {\n\t\tbeforeOutput += '<span class=\"lojban-modal\"><sup>m</sup>';\n\t\tafterOutput = '</span> ';\n\t} else if (simplified.type === 'sumti x') {\n\t\tif (simplified.sumtiPlace > 5) {\n\t\t\tbeforeOutput += '<span class=\"lojban-sumti6\"><sup>' + simplified.sumtiPlace + '</sup>';\n\t\t\tafterOutput = '</span> ';\n\t\t} else {\n\t\t\tbeforeOutput +=\n\t\t\t\t'<span class=\"lojban-sumti' + simplified.sumtiPlace + '\"><sup>' + simplified.sumtiPlace + '</sup>';\n\t\t\tafterOutput = '</span> ';\n\t\t}\n\t} else if (simplified.type === 'prenex') {\n\t\tbeforeOutput += '<span class=\"lojban-prenex\"><sup>p</sup>';\n\t\tafterOutput = '</span> ';\n\t} else if (simplified.type === 'free') {\n\t\tbeforeOutput += '<span class=\"lojban-vocative\"><sup>v</sup>';\n\t\tafterOutput = '</span> ';\n\t}\n\n\tif (simplified.word) {\n\t\toutput += simplified.word;\n\t} else {\n\t\tif (beforeOutput === '') {\n\t\t\tfor (child in simplified.children) {\n\t\t\t\toutput += markupHighlighting(simplified.children[child], mode);\n\t\t\t}\n\t\t} else {\n\t\t\toutput += '<span class=\"lojban-nesting\">' + enumerateTokens(simplified, mode) + '</span>';\n\t\t}\n\t}\n\n\treturn beforeOutput + output + afterOutput;\n}\n\nfunction enumerateTokens(simplified, mode) {\n\tvar output = '';\n\n\tif (simplified.word) {\n\t\toutput += simplified.word;\n\t} else {\n\t\tfor (child in simplified.children) {\n\t\t\tvar textToAdd = enumerateTokens(simplified.children[child], mode);\n\t\t\tif (textToAdd) {\n\t\t\t\toutput += textToAdd + ' ';\n\t\t\t}\n\t\t}\n\t}\n\n\tif (endsWith(output, ' ')) {\n\t\toutput = output.substring(0, output.length - 1);\n\t}\n\n\treturn output;\n}\n\n/**\n * Shows the glossing in the interface.\n */\nfunction showGlossing(text, $element) {\n\tvar output = '<dl class=\"glosser-definition dl-horizontal\">';\n\n\tlet skip_compound = 0;\n\tvar definitions = {};\n\n\tfor (var j = 0; j < text.length; j++) {\n\t\tlet word = text[j];\n\n\t\tif (skip_compound == 0) {\n\t\t\tlet compound = '';\n\n\t\t\tif (word == 'e') {\n\t\t\t\t({ compound, skip_compound } = extractCanonicalCompound(text, j + 1, 2));\n\t\t\t} else if (word == 'a') {\n\t\t\t\t({ compound, skip_compound } = extractCanonicalCompound(text, j + 1, 3));\n\t\t\t} else if (word == 'o') {\n\t\t\t\t({ compound, skip_compound } = extractCanonicalCompound(text, j + 1, -1));\n\t\t\t}\n\n\t\t\tword += compound;\n\t\t} else {\n\t\t\tskip_compound--;\n\t\t}\n\n\t\tif (word == 'u') {\n\t\t\t// skip next word which is the borrowing content\n\t\t\tj++;\n\t\t} else if (word != 'o' && dictionary[word]) {\n\t\t\tif (!definitions[word]) {\n\t\t\t\tdefinitions[word] = [\n\t\t\t\t\tdictionary[word].family,\n\t\t\t\t\tdictionary[word].short ? escapeHtml(dictionary[word].short) : dictionary[word].gloss\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\t}\n\n\tdefinitions = sortMapByKey(definitions);\n\n\tfor (var key in definitions) {\n\t\toutput += '<dt>' + key + '</dt>';\n\t\toutput += '<dd><span class=\"gloss-family\">' + definitions[key][0] + '</span>' + definitions[key][1] + '</dd>';\n\t}\n\n\toutput += '</dl>';\n\n\t$element.html(output);\n}\n\nfunction sortMapByKey(map) {\n\tvar tupleArray = [];\n\tfor (var key in map) tupleArray.push([ key, map[key] ]);\n\ttupleArray.sort(function(a, b) {\n\t\treturn a[0] > b[0];\n\t});\n\tvar sortedMap = {};\n\ttupleArray.forEach(function(el) {\n\t\tsortedMap[el[0]] = el[1];\n\t});\n\treturn sortedMap;\n}\n\nfunction extractCanonicalCompound(text, startIndex, length) {\n\tlet offset = 0;\n\tlet compound = '';\n\n\tif (text[startIndex] == 'i') {\n\t\tcompound += 'i';\n\t\toffset++;\n\t}\n\n\twhile (length != 0) {\n\t\tlet item = text[startIndex + offset];\n\n\t\t// o terminator\n\t\tif (item == 'o') {\n\t\t\tcompound += ' o';\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (item == 'u') {\n\t\t\tcompound += ' ' + item + text[startIndex + offset + 1];\n\t\t\toffset++;\n\t\t} else {\n\t\t\tcompound += ' ' + item;\n\t\t}\n\n\t\toffset++;\n\t\tlength--;\n\t}\n\n\treturn { compound, offset };\n}\n\n/**\n * Shows the translation in the interface.\n */\nfunction showTranslation(parse, text, $element) {\n\tvar output =\n\t\t'<p class=\"muted\">This translation feature tries to give an approximate translation of the Lojban text into English. However, it does only work for a few sentences as of now. (Try [mi gleki] or something simple like that...)</p>';\n\n\t//var translation = translate(parse);\n\tvar translation = 'Sorry! Translation is switched off at the moment, to prevent crashes in the other parts :-(';\n\toutput += '<center><big>' + translation + '</big></center>';\n\n\t$element.html(output);\n}\n\n// Auxiliary\n\nfunction isString(s) {\n\treturn typeof s === 'string' || s instanceof String;\n}\n\nfunction endsWith(str, suffix) {\n\treturn str.indexOf(suffix, str.length - suffix.length) !== -1;\n}\n\n\n//# sourceURL=webpack://bundle/./webpack/parser.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./webpack/parser.js");
/******/ 	bundle = __webpack_exports__;
/******/ 	
/******/ })()
;