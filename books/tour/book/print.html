<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A tour of Eberban</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="res/leipzig.min.css">
        <link rel="stylesheet" href="res/style.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Morphonology</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="morphonology/morphology.html"><strong aria-hidden="true">2.1.</strong> Morphology</a></li><li class="chapter-item expanded "><a href="morphonology/phonology.html"><strong aria-hidden="true">2.2.</strong> Phonology</a></li></ol></li><li class="chapter-item expanded "><a href="logic/intro.html"><strong aria-hidden="true">3.</strong> Logic framework</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="logic/chaining.html"><strong aria-hidden="true">3.1.</strong> Chaining</a></li><li class="chapter-item expanded "><a href="logic/explicit_binding.html"><strong aria-hidden="true">3.2.</strong> Explicit binding (VI/FI/SI)</a></li><li class="chapter-item expanded "><a href="logic/sentences.html"><strong aria-hidden="true">3.3.</strong> Sentences (p-)</a></li><li class="chapter-item expanded "><a href="logic/primitives.html"><strong aria-hidden="true">3.4.</strong> Logical primitives (MI)</a></li><li class="chapter-item expanded "><a href="logic/transformations.html"><strong aria-hidden="true">3.5.</strong> Predicate transformations (ZI)</a></li><li class="chapter-item expanded "><a href="logic/default.html"><strong aria-hidden="true">3.6.</strong> Default arguments</a></li></ol></li><li class="chapter-item expanded "><a href="dictionary_conventions.html"><strong aria-hidden="true">4.</strong> Dictionary conventions</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Additional grammar</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="grammar/discourse.html"><strong aria-hidden="true">5.1.</strong> Discourse predicates (MI)</a></li><li class="chapter-item expanded "><a href="grammar/borrowings.html"><strong aria-hidden="true">5.2.</strong> Borrowings (u-)</a></li><li class="chapter-item expanded "><a href="grammar/compounds.html"><strong aria-hidden="true">5.3.</strong> Compounds</a></li><li class="chapter-item expanded "><a href="grammar/quotes.html"><strong aria-hidden="true">5.4.</strong> Quotes (c-)</a></li><li class="chapter-item expanded "><a href="grammar/lists.html"><strong aria-hidden="true">5.5.</strong> Lists (BU)</a></li><li class="chapter-item expanded "><a href="grammar/numbers.html"><strong aria-hidden="true">5.6.</strong> Numbers (TI/j-)</a></li><li class="chapter-item expanded "><a href="grammar/annotations.html"><strong aria-hidden="true">5.7.</strong> Annotations (d-)</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Important concepts</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Data structures</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.1.</strong> Sets</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.2.</strong> Maps</div></li></ol></li><li class="chapter-item expanded "><a href="concepts/time.html"><strong aria-hidden="true">6.2.</strong> Time</a></li></ol></li><li class="chapter-item expanded "><a href="writing/intro.html"><strong aria-hidden="true">7.</strong> Writing systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing/linear.html"><strong aria-hidden="true">7.1.</strong> Linear writing system</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.2.</strong> Planar writing system</div></li></ol></li><li class="chapter-item expanded "><a href="from_scratch/intro.html"><strong aria-hidden="true">8.</strong> Eberban from scratch</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="from_scratch/step1.html"><strong aria-hidden="true">8.1.</strong> Core grammar</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> Core vocabulary</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="from_scratch/step2/simple.html"><strong aria-hidden="true">8.2.1.</strong> Few simple predicates</a></li><li class="chapter-item expanded "><a href="from_scratch/step2/sets.html"><strong aria-hidden="true">8.2.2.</strong> Sets</a></li><li class="chapter-item expanded "><a href="from_scratch/step2/pairs.html"><strong aria-hidden="true">8.2.3.</strong> Pairs</a></li><li class="chapter-item expanded "><a href="from_scratch/step2/idents.html"><strong aria-hidden="true">8.2.4.</strong> Identifiers</a></li><li class="chapter-item expanded "><a href="from_scratch/step2/lists.html"><strong aria-hidden="true">8.2.5.</strong> Lists</a></li><li class="chapter-item expanded "><a href="from_scratch/step2/maps.html"><strong aria-hidden="true">8.2.6.</strong> Maps</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.7.</strong> Natural numbers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.8.</strong> Integer numbers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.9.</strong> Real numbers</div></li><li class="chapter-item expanded "><a href="from_scratch/step2/time.html"><strong aria-hidden="true">8.2.10.</strong> Time</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.11.</strong> Letters and words</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> Extended vocabulary</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">A tour of Eberban</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>Eberban</strong> is a <a href="https://en.wikipedia.org/wiki/Engineered_language#Logical_languages">logical</a> <a href="https://en.wikipedia.org/wiki/Constructed_language">constructed language</a> aimed to satisfy the
following goals :</p>
<ul>
<li><strong>being simple :</strong> the Eberban grammar allows to manipulate predicates with
particles in a way that is close to the <a href="https://en.wikipedia.org/wiki/Higher-order_logic">higher-order logic</a> it
translates into, while abstracting away the verbosity of explicitely
providing variables as arguments of predicates.</li>
<li><strong>being regular :</strong> valid sentences are syntaxicaly unambiguous. Most grammar
rules rely on particles which are organised in families, each starting with
a unique prefix. Many additional patterns are shared between particles and
predicate words to help learning groups of related words.</li>
<li><strong>being expressive :</strong> the grammar and core vocabulary focus on providing a
simple framework, on top of which can be built abstractions, complex concepts
and tools. Since those are built in Eberban itself, users can create their own
tools and abstractions to express entirely new concepts.</li>
</ul>
<p><strong>Eberban</strong> take inspirations from <a href="https://mw.lojban.org/papri/Lojban">Lojban</a> and other logical languages, but try
novel approaches to satisfy the above goals.</p>
<p>Most resources are hosted on <a href="https://eberban.github.io/eberban/">GitHub pages</a>, such as :</p>
<ul>
<li>parsers, which transform text into a tree structure, that can also be
visualized as nested boxes.</li>
<li>a dictionnary allowing to search words and their definitions.</li>
<li>learning resources to discover the language grammar and concepts.</li>
</ul>
<p>If you would like to get involved, please also consider joining our
<a href="https://discord.com/invite/KKB79RwWUc">Discord server</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="morphology"><a class="header" href="#morphology">Morphology</a></h1>
<p>The morphology of Eberban is composed of 16 consonants (<strong>n, r, l, m, p, b, f,
v, t, d, s, z, c, j, g, k</strong>), 5 vowels (<strong>i, e, a, o, u</strong>) and finally the
letter <strong>h</strong>, for a total of 22 letters. Among the consonants, <strong>n</strong>, <strong>r</strong> and
<strong>l</strong> are designated as (alveolar) <strong>sonorants</strong>, and play an important role in
Eberban's morphology. The alphabetical order is <code>hnlrmpbfvtdszcjkgieaou</code>.
The same letter appearing multiple times in a row is considered identical to the
letter not being repeated, but can informally be used in written media to convey
length of sounds in speech.</p>
<p>Words are usually written separated by spaces, however this is not mandatory.
While removing spaces, however, it might be required to add the <strong>word boundary
marker</strong> symbol <strong>'</strong> in some places. More than one marker in a row is not
allowed. Letters are chained one after the other without spaces to form
<strong>words</strong> which are divided into multiple categories based on their structure.</p>
<p>Eberban text is usually written all lowercase (outside of foreign text quotes),
but uppercase can informally be used in written media to convey volume (such as
yelling). Outside of <strong>'</strong> no punctuation symbol is used, and any other
character is considered a space, but informally punctuation from other languages
can be used (for exemple by writing <code>&quot;</code> around quotes, or ending sentences with
<code>.</code>).</p>
<h2 id="word-types"><a class="header" href="#word-types">Word types</a></h2>
<h3 id="particles"><a class="header" href="#particles">Particles</a></h3>
<p><strong>Particles</strong> are words exerting grammatical functions. They start with a single
<em>non-sonorant consonant</em>, followed only by <em>vowels</em> and <em>h</em>, like <strong>pa</strong>,
<strong>mio</strong> or <strong>tiho</strong>. Particles are themselves categorized into <strong>families</strong>
having identical grammar but different meanings. Those families are usually
designated using a particle in capital letters (like <strong>MI</strong> or <strong>VEI</strong>), which
is by convention the first particle in this family in alphabetical order.</p>
<p>All other words are <strong>predicate words</strong> and express intrinsic meanings such as
&quot;cat&quot;, &quot;language&quot; or &quot;teach&quot;. They are grouped into the following categories :</p>
<h3 id="roots"><a class="header" href="#roots">Roots</a></h3>
<p><strong>Roots</strong> are the building blocks of the language and express meanings that
would be hard or too long to convey otherwise. They can either :</p>
<ul>
<li>start with a single <em>non-sonorant consonant</em> followed by a mix of <em>vowels</em> and
at least one <em>sonorant</em> or <em>medial consonant pair</em>, like <strong>ban</strong>, <strong>mana</strong>,
<strong>cuina</strong> or <strong>marne</strong>.</li>
<li>start with a valid <em>initial consonant pair</em> followed by a mix of <em>vowels</em> and
any number of <em>sonorants</em> or <em>medial consonant pairs</em> (even none), like
<strong>bju</strong>, <strong>cpena</strong> or <strong>djin</strong>.</li>
</ul>
<p>A <em>sonorant</em> can appear only between 2 <em>vowels</em> or at the end of the root, while
a medial pair can appear only between 2 <em>vowels</em>, but not at the end.</p>
<p>The following chart shows <strong>initial pairs</strong> in light blue, <strong>medial pairs</strong> in
pink, and invalid pairs in dark gray (with a short explanation for why they are
invalid):</p>
<p><img src="morphonology/chart-pairs.png" alt="Chart of valid initial and medial pairs" /></p>
<h3 id="borrowings"><a class="header" href="#borrowings">Borrowings</a></h3>
<p><strong>Borrowings</strong> allow importing foreign words or names. They are prefixed by the
vowel <strong>u</strong>, and have more relaxed rules about consonants than native eberban
words. Mainly, they can contain consonant triplets which must obey the following
rules: </p>
<ul>
<li>Consonant pairs must either be <em>initial pairs</em>, <em>medial pairs</em> or <em>sonorant</em>
<ul>
<li><em>consonant</em>.</li>
</ul>
</li>
<li>Consonant triplets C1C2C3 are valid if C1C2 is a medial pair <strong>and</strong> C2C3 is
an initial pair.</li>
<li>Alternatively, consonant triplets can be a <em>sonorant</em> followed by an <em>initial
pair</em>.</li>
</ul>
<p>After the <strong>u</strong>  prefix the borrowing can start by a vowel, a single consonant,
a initial or medial consonant pair, a consonant triplet or <strong>h</strong> If this first
letter is an <strong>u</strong> it must be prefixed with a <strong>'</strong> to separate it from the the
prefix.</p>
<p>Borrowings must end with a <em>vowel</em>, or a <em>vowel</em> followed by a single
<em>consonant</em> (not only <em>sonorants</em>). In written media, borrowings must be
followed by either spaces or a word boundary marker, which is realized in speech
by pausing after the borrowing to properly separate it from the following word.</p>
<p>Similarly, the initial <strong>u</strong> must be either preceded by spaces or a word
boundary marker, and realized orally as either a pause or a glottal stop.</p>
<h3 id="freeform-variables"><a class="header" href="#freeform-variables">Freeform variables</a></h3>
<p><strong>Freeform variables</strong> allow defining predicates with a custom name. They follow
the same morphology as <em>borrowings</em> but use the <strong>i</strong> prefix instead of <strong>u</strong>.</p>
<h3 id="compounds"><a class="header" href="#compounds">Compounds</a></h3>
<p><strong>Compounds</strong> allow making new words from multiple other kind of words. They
start by either <strong>e</strong>, <strong>a</strong> or <strong>o</strong> and follow the same rule as the <strong>u</strong> of
borrowings. Their structure will be detailed later in this book.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>With spaces : <em>pa za umia tsen eberban</em><br />
Without spaces : <em>paza'umia'tsen'eberban</em></p>
<p>Particles : <em>pa</em>, <em>za</em><br />
Borrowing : <em>umia</em><br />
Freeform variable: <em>ibar</em><br />
Root : <em>tsen</em><br />
Compound : <em>eberban</em></p>
<h3 id="reasoning"><a class="header" href="#reasoning">Reasoning</a></h3>
<p>Outside of borrowings and assignable names, encountering a <em>non-sonorant
consonant</em> or a word boundary marker means it is the start of a new word; unless
it the first letter of a <em>medial consonant pair</em> which cannot be misunderstood
for the start of a new word. Word boundary markers or spaces allow to prevent
them from &quot;merging&quot; into adjacent words.</p>
<p>These simple rules prevent any ambiguity of word boundaries, which is called a
<strong>Self-Segregating Morphology</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="phonology"><a class="header" href="#phonology">Phonology</a></h1>
<table><thead><tr><th>Letter</th><th>IPA</th><th>Description</th></tr></thead><tbody>
<tr><td>h</td><td>[h]</td><td>a glottal aspirant</td></tr>
<tr><td>n</td><td>[n], [ŋ]</td><td>a dental or velar nasal</td></tr>
<tr><td>r</td><td>[r], [ɹ], [ɾ], [ʀ], [ʁ]</td><td>a rhotic sound</td></tr>
<tr><td>l</td><td>[l]</td><td>a lateral approximant</td></tr>
<tr><td> </td><td></td><td></td></tr>
<tr><td>m</td><td>[m]</td><td>a bilabial nasal</td></tr>
<tr><td>p</td><td>[p]</td><td>an unvoiced bilabial stop</td></tr>
<tr><td>b</td><td>[b]</td><td>a voiced bilabial stop</td></tr>
<tr><td>f</td><td>[f]</td><td>an unvoiced labiodental fricative</td></tr>
<tr><td>v</td><td>[v]</td><td>a voiced labiodental fricative</td></tr>
<tr><td>t</td><td>[t]</td><td>an unvoiced dental/alveolar stop</td></tr>
<tr><td>d</td><td>[d]</td><td>a voiced dental/alveolar stop</td></tr>
<tr><td>s</td><td>[s]</td><td>an unvoiced alveolar sibilant</td></tr>
<tr><td>z</td><td>[z]</td><td>a voiced alveolar sibilant</td></tr>
<tr><td>c</td><td>[ʃ], [ʂ]</td><td>an unvoiced coronal sibilant</td></tr>
<tr><td>j</td><td>[ʒ], [ʐ]</td><td>a voiced coronal sibilant</td></tr>
<tr><td>k</td><td>[k]</td><td>an unvoiced velar stop</td></tr>
<tr><td>g</td><td>[ɡ]</td><td>a voiced velar stop</td></tr>
<tr><td> </td><td></td><td></td></tr>
<tr><td>i</td><td>[i]</td><td>a front close vowel</td></tr>
<tr><td>e</td><td>[ɛ], [e]</td><td>a front mid vowel</td></tr>
<tr><td>a</td><td>[a], [ɑ]</td><td>an open vowel</td></tr>
<tr><td>o</td><td>[o], [ɔ]</td><td>a back mid vowel</td></tr>
<tr><td>u</td><td>[u]</td><td>a back close vowel</td></tr>
</tbody></table>
<p>The word boundary marker <strong>'</strong> is usually realized as a pause. However before a
vowel-initial word (borrowings, freeform variables and compounds) it can be
realized as a glottal stop [ʔ] instead.</p>
<p>Consecutive vowels are separated by hiatuses, but glides like [j] and [w]
are allowed respectively alongside or instead of [i] and [u].</p>
<p>Where spaces are allowed, a speaker or writter can express hesitation by using
one or more of the letter <strong>n</strong> surrounded by spaces, which is realized as [n̩].</p>
<p>In speech, the schwa sound [ə] can be used in between consonants of a pair if
the speaker has trouble uttering the pair as-is. It has no written equivalent.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>Sentence : <em>pa za umia tsae eberban</em><br />
Pronounciation : [pa za ʔumi.a tsa.e ʔeberban]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logic-framework"><a class="header" href="#logic-framework">Logic framework</a></h1>
<p>Eberban is based on a custom <strong><a href="https://en.wikipedia.org/wiki/Higher-order_logic">Higher-order Logic (HOL)</a></strong> and tries to stay
pretty close to expressions in such logic while being targeted for human speech.</p>
<p>Eberban grammar allow the speaker to manipulate <strong>predicates</strong>. They are
functions that take <strong>arguments</strong> as inputs and outputs a <strong>truth value</strong> which
can be <strong>true</strong>, <strong>false</strong> or <strong>unknown/undefined</strong>. They are introduced by
<strong>predicate words</strong> or created from other predicates using Eberban grammar.</p>
<p>Arguments are not filled using <strong>predicate words</strong> directly and there is no
words that directly represents them. Instead some <strong>particles</strong> allows to select
which arguments are going to be used for various operations on <strong>predicates</strong>
such as connecting them with each other. Arguments are typed, and can either
represent <strong>predicates</strong> or non-predicates which are called <strong>atoms</strong>.</p>
<p>The first of those arguments is handled automatically by the grammar and is
called the <strong>context argument</strong>. It is used to carry information between
predicates without verbosity for speakers to implement things such as tenses.</p>
<p>Other arguments are represented using the vowels <strong>e, a, o, u</strong> in this order.
They are used in definitions but also in some families of particles related to
argument selection. They are called <strong>explicit arguments</strong> (to exclude the
<em>implicit</em> context argument), and we call <strong>arity</strong> (N-ary) the number of
<strong>explicit arguments</strong>.</p>
<p>Here is an exemple of a simple predicate :</p>
<blockquote>
<p><strong>mian</strong></p>
<p>\[ \text{mian}(c,e) = \text{[$e$ is a cat in context $c$]} \]</p>
<p>Given $(c), $(e):<br />
$(e) is a cat in context $(c).</p>
<p>$(c) and $(e) are argument that will be provided when used in a sentence.</p>
</blockquote>
<blockquote>
<p>In future explanations we'll omit the context argument outside of logical
notation to be shorter, unless the context argument is the focus of the
explanation.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chaining"><a class="header" href="#chaining">Chaining</a></h1>
<p>When 2 predicates are strung one after the other they form a new predicate,
which has the same arguments as the left predicate.</p>
<p>Every predicate has a default <strong>chaining behavior</strong> which dictates how 2
predicates are connected together. If the left predicate has <strong>intransitive
behavior</strong> then its <strong>E</strong> place will interact with the right predicate.
Otherwise if the left predicate has <strong>transitive behavior</strong> then the <strong>A</strong>
place is used.</p>
<blockquote>
<p>For <strong>root words</strong>, they have <strong>transitive behavior</strong> if they end with a
<strong>vowel</strong>, while they have <strong>intransitive behavior</strong> if they end with <strong>n, r
or l</strong>.</p>
<p>Particles acting as predicates have different rules which will be explained
later.</p>
<p>When chaining predicates the new predicate inherits the <strong>chaining behavior</strong>
of the left predicate.</p>
</blockquote>
<h2 id="atom-argument-chaining"><a class="header" href="#atom-argument-chaining">Atom argument chaining</a></h2>
<p>If the chaining argument is an <strong>atom</strong> argument, then the variable filling this
argument also fills the <strong>E</strong> argument of the right predicate. The
<strong>context argument</strong> is automatically shared between left and right predicates.</p>
<blockquote>
<p><strong>mian blan</strong></p>
<p>\[ \begin{align}
\text{mian}(c,e)   &amp;= \text{[$e$ is a cat]} \\
\text{blan}(c,e)   &amp;= \text{[$e$ is beautiful]} \\
\ \\
\text{blan}_1(c,e) &amp;= \text{blan}(c,e) \\
\ \\
\text{mian}_1(c,e) &amp;= \text{mian}(c,e) \wedge \text{blan}_1(c,\color{magenta}{e})
\end{align} \]</p>
<p>Given $(c),$(e):<br />
$(e) is a cat and is beautiful.</p>
</blockquote>
<p>If the right predicate has more than one explicit argument then it is wrapped
in a predicate having only one explicit argument, and every other arguments are
filled with <strong>existential variables</strong>. The process of wrapping the predicate and
creating <strong>existential variables</strong> to have the correct arity is called the
<strong>arity mismatch resolution</strong>, and is a key aspect of Eberban grammar to reduce
verbosity in simple cases.</p>
<blockquote>
<p><strong>mian buri</strong></p>
<p>\[ \begin{align}
\text{buri}(c,e,a)                    &amp;= \text{[$e$ eats $a$]} \\
\ \\
\text{buri}_1(c,e,a)                  &amp;= \text{buri}(c,e,a) \\
\color{magenta}{\text{buri}^w_1(c,e)} &amp;= \color{magenta}{\exists a. \text{buri}_1(c,e,a)} \\
\ \\
\text{mian}_1(c,e) &amp;= \text{mian}(c,e) \wedge \text{buri}^w_1(c,e)
\end{align} \]</p>
<p>Given $(c),$(e):<br />
$(e) is a cat and there exist an $(a) such that $(e) eats $(a).<br />
$(e) is a cat that eats something.</p>
</blockquote>
<h2 id="predicate-argument-chaining"><a class="header" href="#predicate-argument-chaining">Predicate argument chaining</a></h2>
<p>If the chaining argument is a <strong>predicate argument</strong>, then the right predicate
is stated to be equivalent to the predicate represented by the argument. If the
<strong>predicate argument</strong> and right predicate don't match in arity then the
<strong>arity mismatch resolution</strong> is performed. The right predicate is not stated
as is, and will be <em>instanciated</em> by the left predicate (according to its
definition). The left predicate will be able to <em>instanciated</em> multiple times
and with any (correctly typed) arguments, including the <em>context argument</em>.</p>
<blockquote>
<p><strong>tce mian</strong></p>
<p>\[ \begin{align}
\text{tce}(c,e,A)   &amp;= \text{[$e$ is a set of things that satisfies $A$ (1-ary)]} \\
\ \\
\text{mian}_1(c,e)  &amp;= \text{mian}(c,e) \\
\ \\
\text{tce}_1(c,e,A) &amp;= tce(c,e,A) \color{magenta}{\wedge A \Leftrightarrow \text{mian}_1}
\end{align} \]</p>
<p>Given $(c), $(e), $(A):<br />
$(e) is a set of things that satisfies $(A), and $(A) is equivalent to
<em>mian</em>.<br />
$(e) is a set/group of cats.</p>
</blockquote>
<blockquote>
<p><strong>gli mian</strong></p>
<p>\[ \begin{align}
\text{gli}(c,e,A)   &amp;= \text{[$e$ is happy about $A$ (0-ary) being true]} \\
\ \\
\text{mian}_1(c,e)  &amp;= \text{mian}(c,e) \\
\text{mian}^w_1(c)  &amp;= \exists e. \text{mian}_1(c,e) \\
\ \\
\text{gli}_1(c,e,A) &amp;= gli(c,e,A) \wedge A \Leftrightarrow \text{mian}^w_1
\end{align} \]</p>
<p>Given $(c), $(e), $(A):<br />
$(e) is happy about $(A) being true, and $(A) is equivalent to
\(\text{mian}^w_1\).<br />
$(e) is happy that there exist a cat.</p>
</blockquote>
<h2 id="longer-chains"><a class="header" href="#longer-chains">Longer chains</a></h2>
<p>When more than 2 predicates are strung one after the other they are chained in
right-grouping order (<code>A (B (C D))</code>).</p>
<blockquote>
<p><strong>mi dona tcu mian</strong></p>
<p>\[ \begin{align}
\text{mi}(c,e)       &amp;= \text{[$e$ is a speaker]} \\
\text{dona}(c,e,a)   &amp;= \text{[$e$ likes $a$]} \\
\text{tcu}(c,e,A)    &amp;= \text{[$e$ is the set of all things that satisfy $A$ (1-ary)]} \\
\ \\
\text{mian}_1(c,e)   &amp;= \text{mian}(c,e) \\
\ \\
\text{tcu}_1(c,e,A)  &amp;= \text{tcu}(c,e,A) \wedge A \Leftrightarrow \text{mian}_1 \\
\text{tcu}^w_1(c,e)  &amp;= \exists A. \text{tcu}_1(c,e,A) \\
\ \\
\text{dona}_1(c,e,a) &amp;= \text{dona}(c,e,a) \wedge \text{tcu}^w_1(c,a) \\
\text{dona}^w_1(c,e) &amp;= \exists a. \text{dona}_1(c,e,a) \\
\ \\
\text{mi}_1(c,e)     &amp;= \text{mi}(c,e) \wedge \text{dona}^w_1(c,e)
\end{align} \]</p>
<p>Given $(c), $(e):<br />
$(e) is a speaker that likes all cats.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="explicit-binding-vifisi"><a class="header" href="#explicit-binding-vifisi">Explicit binding (VI/FI/SI)</a></h1>
<h2 id="left-atom-place-selection"><a class="header" href="#left-atom-place-selection">Left atom place selection</a></h2>
<p>When the speaker wants to interact with an argument that normal chaining doesn't
select (due to transitivity, or to interact with O or U arguments), it is
possible to attach additional bindings using the <strong>VI</strong> family of particles
after a predicate, followed by another (chain of) predicate(s), which is closed
by the <strong>vei</strong> particle to return to the previously seen chaining behavior.</p>
<blockquote>
<p><strong>vei</strong> is the only member of family <strong>VEI</strong>, and not a member of <strong>VI</strong>.</p>
</blockquote>
<p><strong>ve, va, vo, vu</strong> allow binding atom (or generic) arguments :</p>
<blockquote>
<p><strong>mi duna [vo mo vei] meon</strong></p>
<p>\[ \begin{align}
\text{mi}(c,e)         &amp;= \text{[$e$ is a speaker]} \\
\text{duna}(c,e,a,o)   &amp;= \text{[$e$ gives $a$ to $o$]} \\
\text{mo}(c,e)         &amp;= \text{[$e$ is a listener]} \\
\text{meon}(c,e)       &amp;= \text{[$e$ is an apple]} \\
\ \\
\text{mo}_1(c,e)       &amp;= \text{mo}(c,e) \\
\text{meon}_1(c,e)     &amp;= \text{meon}(c,e) \\
\ \\
\text{duna}_1(c,e,a,o) &amp;= \text{duna}(c,e,a,o) \color{magenta}{\wedge \text{mo}_1(c,o)} \wedge \text{meon}_1(c,a) \\
\text{duna}^w_1(c,e)   &amp;= \exists a \exists o. \text{duna}_1(c,e,a,o) \\
\ \\
\text{mi}_1(c,e)       &amp;= \text{mi}(c,e) \wedge \text{duna}^w_1(c,e) \\
\end{align} \]</p>
<p>Given $(c), $(e):<br />
$(e) is a speaker which gives an apple to a listener.</p>
</blockquote>
<p>To bind more than one argument of the same predicate we have to use the <strong>FI</strong>
family, which interact with the same predicate as the last non-closed <strong>VI</strong>.
The <strong>FI</strong> family follows the same pattern of vowels as <strong>VI</strong>.
The above sentence can thus be rewritten as <code>duna [ve mi, fo mo vei] meon</code> or
even as <code>duna [ve mi, fo mo, fa meon vei]</code>.</p>
<p>In the last version it is possible to omit the final <strong>vei</strong>. It is however not
possible to do so in the previous exemples as we would get the chain <code>mo meon</code>
which is not what we want.</p>
<h2 id="arguments-list"><a class="header" href="#arguments-list">Arguments list</a></h2>
<p>Between <strong>VI/FI</strong> and the inner predicate an <strong>arguments list</strong> can be provided
by having 0 or more <strong>KI/GI</strong> terminated with <strong>be</strong>, in which case the bindings
will occur with those arguments instead of the arguments of the predicate after
<strong>be</strong>.</p>
<p><strong>KI</strong> (all particles starting with <em>k-</em>) represent an atom or generic argument
$(x) and have meaning \(ki(c,e) = [\text{$e$ is variable $x$}]\).</p>
<p><strong>GI</strong> (all particles starting with <em>g-</em>) however represents a predicate whose
arity and type will be infered from its usage in the sentence. All <strong>GI</strong>
starting with <strong>gi-</strong> have <strong>intransitive behavior</strong>, while the others starting
with <strong>ge/ga/go/gu-</strong> have <strong>transitive behavior</strong>.</p>
<blockquote>
<p><strong>mi dona [va ke be: mian buri ke]</strong></p>
<p>\[ \begin{align}
\text{mian}(c,e)       &amp;= \text{[$e$ is a cat]} \\
\text{buri}(c,e,a)     &amp;= \text{[$e$ eats $a$]} \\
\ \\
\text{buri}_1(c,e,a)   &amp;= \text{buri}(c,e,a) \wedge \color{magenta}{\text{ke}_1(c,e)} \\
\text{buri}^w_1(c,e)   &amp;= \exists a. \text{buri}_1(c,e,a) \\
\ \\
\text{mian}_1(c,e)     &amp;= \text{mian}(c,e) \wedge \text{buri}^w_1(c,e) \\
\ \\
\text{va}_1(c,e)       &amp;= \color{magenta}{\text{ke}_1(c,e)} \wedge \text{mian}_1(c,e) \\
\ \\
\text{dona}_1(c,e,a)   &amp;= \text{dona}(c,e,a) \wedge \text{va}_1(c,a) \\
\text{dona}^w_1(c,e)   &amp;= \exists a. \text{dona}_1(c,e,a) \\
\ \\
\text{mi}_1(c,e)       &amp;= \text{mi}(c,e) \wedge \text{dona}^w_1(c,e) \\
\end{align} \]</p>
<p>Given $(c), $(e):<br />
$(e) is a speaker which likes [something eaten by a cat].</p>
</blockquote>
<p>If an argument in the list is used only once it can be replaced with <strong>ba</strong>,
which adds an argument at the end of the list and use it directly. The above
example can thus be shortened as <em>mi dona [va be mian buri <strong>ba</strong>]</em>.</p>
<h2 id="right-place-and-chaining-selection"><a class="header" href="#right-place-and-chaining-selection">Right place and chaining selection</a></h2>
<p>When it is only needed to bind one or 2 places of a predicate, using <strong>VI/FI</strong>
and arguments lists is quickly verbose. For that reason, predicates can be
prefixed with particles of familly <strong>SI</strong> (all particles starting with <em>s-</em>),
which overrides the chaining behavior.</p>
<p><strong>se, sa, so, su</strong> select the place corresponding to its vowel both for the
argument bound with a predicate on its right, and for which single argument is
exposed in the combined predicate.</p>
<blockquote>
<p><strong>mian se buri blan</strong></p>
<p>\[ \begin{align}
\text{blan}(c,e)                       &amp;= \text{[$e$ is beautiful]} \\
\ \\
\text{blan}_1(c,e)                     &amp;= \text{blan}(c,e) \\
\ \\
\text{buri}_1(c,e,a)                   &amp;= \text{buri}(c,e,a) \wedge \text{blan}_1(c,\color{magenta}{e}) \\
\text{buri}^w_1(c,\color{magenta}{e})  &amp;= \exists a. \text{buri}_1(c,e,a) \\
\ \\
\text{mian}_1(c,e)                     &amp;= \text{mian}(c,e) \wedge \text{buri}^w_1(c,e) \\
\end{align} \]</p>
<p>Given $(c), $(e):<br />
$(e) is is cat that eats something, and $(e) is beautiful.</p>
</blockquote>
<p><strong>SI</strong> particles with 2 vowels allow to select both individually.</p>
<blockquote>
<p><strong>meon sae buri mian</strong></p>
<p>\[ \begin{align}
\text{mian}_1(c,e)                    &amp;= \text{mian}(c,e) \\
\ \\
\text{buri}_1(c,e,a)                  &amp;= \text{buri}(c,e,a) \wedge \text{mian}_1(c,\color{magenta}{e}) \\
\text{buri}^w_1(c,\color{magenta}{a}) &amp;= \exists e. \text{buri}_1(c,e,a) \\
\ \\
\text{meon}_1(c,e)                    &amp;= \text{meon}(c,e) \wedge \text{buri}^w_1(c,e) \\
\end{align} \]</p>
<p>Given $(c), $(e):<br />
$(e) is an apple which is eaten by a cat.</p>
</blockquote>
<h2 id="left-predicate-place-selection"><a class="header" href="#left-predicate-place-selection">Left predicate place selection</a></h2>
<p>Using <strong>ve, va, vo, vu</strong> on a predicate argument will not provide its
definition but instead share it like an atom argument with the following
predicate. The bound place must have the same predicate argument type however.
To provide a definition of the predicate argument the particles <strong>vie, via, vio,
viu</strong> (and <strong>FI</strong> equivalents) must be used.</p>
<p>If we take the example <code>tce mian</code> from the previous chapter it is equivalent to
<code>tce vie mian</code>. Sharing with <strong>ve, va, ...</strong> can be used like so:</p>
<blockquote>
<p><strong>mi fule [va sae tuli mo]</strong></p>
<p>\[ \begin{align}
\text{fule}(c,e,A)                &amp;= \text{[$e$ knows that $A$ (0-ary) is true]} \\
\text{tuli}(c,e,A)                &amp;= \text{[$e$ needs $A$ (0-ary) to be true]} \\
\text{mo}(c,e)                    &amp;= \text{[$e$ is a listener]} \\
\ \\
\text{mo}_1(c,e)                  &amp;= \text{mo}(c,e) \\
\ \\
\text{tuli}_1(c,e,A)              &amp;= \text{tuli}(c,e,A) \wedge \text{mo}_1(c,e) \\
\text{tuli}^w_1(c,A)              &amp;= \exists e. \text{tuli}_1(c,e,A) \\
\ \\
\text{fule}_1(c,e,A)              &amp;= \text{fule}(c,e,A) \color{magenta}{\wedge \text{tuli}^w_1(c,A)} \\
\text{fule}^w_1(c,e)              &amp;= \exists A. \text{fule}_1(c,e,A) \\
\ \\
\text{mi}_1(c,e)                  &amp;= \text{mi}(c,e) \wedge \text{fule}^w_1(c,e) \\
\end{align} \]</p>
<p>Given $(c), $(e):<br />
$(e) is a speaker which knowns some truth which is needed by a listener.</p>
</blockquote>
<p>While using <strong>via</strong> it has a different meaning :</p>
<blockquote>
<p><strong>mi fule [via sae tuli mo]</strong></p>
<p>\[ \begin{align}
\text{mo}_1(c,e)                  &amp;= \text{mo}(c,e) \\
\ \\
\text{tuli}_1(c,e,A)              &amp;= \text{tuli}(c,e,A) \wedge \text{mo}_1(c,e) \\
\text{tuli}^w_1(c)                &amp;= \exists e. \exists A. \text{tuli}_1(c,e,A) \\
\ \\
\text{fule}_1(c,e,A)              &amp;= \text{fule}(c,e,A) \color{magenta}{\wedge A \Leftrightarrow \text{tuli}^w_1} \\
\text{fule}^w_1(c,e)              &amp;= \exists A. \text{fule}_1(c,e,A) \\
\ \\
\text{mi}_1(c,e)                  &amp;= \text{mi}(c,e) \wedge \text{fule}^w_1(c,e) \\
\end{align} \]</p>
<p>Given $(c), $(e):<br />
$(e) is a speaker which knowns that [Some truth is needed by a listener] is true.</p>
</blockquote>
<h2 id="brackets"><a class="header" href="#brackets">Brackets</a></h2>
<p><strong>pe</strong> and <strong>pei</strong> are like spoken brackets that wraps a predicate or chain of
predicate to define a new one, and have higher priority than chaining : <code>A B pe C D pei E F</code> will be chained in order <code>A (B ([C D] (E F)))</code> instead of <code>A (B (C (D (E F))))</code>. <strong>pe</strong> can also be followed by an argument list to define the
arguments of this new predicate.</p>
<p>Using <strong>VI/FI/SI</strong> is often prefered and more simple than using <strong>pe</strong> and
<strong>pei</strong>, but in some cases it is not possible. Those cases will be presented in
later chapters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sentences-p-"><a class="header" href="#sentences-p-">Sentences (p-)</a></h1>
<p>Eberban has multiple kind of sentences, which all begins with particles starting
with <strong>p-</strong>, grouped into the following families :</p>
<ul>
<li><strong>PA</strong> (all starting with <em>pa-</em>): The particle is followed by a predicate or
chain of predicates.</li>
<li><strong>PO</strong> (<em>po-</em>): The particle is followed by a <strong>defined</strong>
predicate word, <strong>GI</strong> or freeform variable (word starting with
_i-); then followed by a definition as a predicate or chain of predicates.</li>
<li><strong>PU</strong> (<em>pu-</em>): The particle is followed only by a sigle predicate word,
<strong>KI/GI</strong> variable or freeform variable.</li>
</ul>
<p>In all cases the predicate or chain of predicates can be prefixed by an
<strong>argument list</strong> if necessary.</p>
<h2 id="assertion-pa"><a class="header" href="#assertion-pa">Assertion (pa)</a></h2>
<p><strong>pa</strong> allows the speaker to make an assertion. It is followed by a wrapped
0-ary predicate, thus creating existential variables for all arguments of
the predicate.</p>
<p>If the first sentence of a text is an assertion than the initial <strong>pa</strong>
can be omitted.</p>
<blockquote>
<p>Until now we gave translations for chaining only. From now on we'll consider
above omition and exemples as complete sentences.</p>
</blockquote>
<h2 id="context-update-pae"><a class="header" href="#context-update-pae">Context update (pae)</a></h2>
<p>The context argument of the predicate wrapped with <strong>pa</strong> is filled with a
globally managed context variable that can be updated using <strong>pae</strong>.
<strong>pae</strong> wraps a 1-ary predicate that takes as parameter the new context, which
can thus be constrainted in terms of the current implicit context argument.
The vocabulary contains many predicates designed to easily be used with <strong>pae</strong>
to provide many import concepts such as tenses.</p>
<h2 id="repeated-context-update-pahe"><a class="header" href="#repeated-context-update-pahe">Repeated context update (pahe)</a></h2>
<p><strong>pahe</strong> wraps a 1-ary like <strong>pae</strong>, which describe how the context is updated
after each <strong>pa</strong> sentence ends. It is currently unknown if it will be used
significatively by casual speakers, but its existence is necessary to implement
things like the &quot;present&quot; going forward in time after each sentence.</p>
<h2 id="sentence-wrapper-pahi"><a class="header" href="#sentence-wrapper-pahi">Sentence wrapper (pahi)</a></h2>
<p><strong>pahi</strong> wraps a 1-ary predicate that will take every sentence expressed with
<strong>pa</strong> as argument, which is mainly used to configure correctly the context
for some features to work. Will likely not be used by casual speakers.</p>
<h2 id="definition-po"><a class="header" href="#definition-po">Definition (po)</a></h2>
<p><strong>po</strong> allows to assign a definition to a word, and is an important tool to
create the vocabulary of Eberban and avoid repetitions.</p>
<p>It can also be used by speakers to simplify complex sentences by defining part
of it using <strong>po</strong>, then using the defined predicate(s) into a <strong>pa</strong> sentence.</p>
<p>Note that the definition don't use the global context argument, and instead
will use the context argument provided by the sentence using this predicate.
<strong>poe</strong> can be used to <strong>capture</strong> the current global context instead, and the
defined predicate will thus ignore the context argument provided by a sentence
using it.</p>
<h2 id="questions-poi"><a class="header" href="#questions-poi">Questions (poi)</a></h2>
<p><strong>poi</strong> allow to ask a question by defining a predicate to be used by the
listener. Defining a 0-ary predicate asks the listener to say if it is false
or not (by using it with or without a negation), while higher arities asks the
listener to provide arguments that makes the predicate true.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logical-primitives-mi"><a class="header" href="#logical-primitives-mi">Logical primitives (MI)</a></h1>
<p>Particles of family <strong>MI</strong> (all particles starting with <em>m-</em>) acts as predicate
words, and some of them are defined directly in logical notation with the goal
to express logical primitives that the grammar itself don't cover.</p>
<p>\[ \begin{align}
\text{ma}(c,e)      &amp;= \text{is-atom}(e) \\
\text{mai}(c,e)     &amp;= \top \\
\text{mae}(c,E)     &amp;= \forall x. \ E(c,x) \\
\text{mao}(c,E,A)   &amp;= \forall x_0 \dots \forall x_n. \ E(c,x_0,\dots,x_n) \Rightarrow A(c,x_0,\dots,x_n) \\
\text{mui}(c,E)     &amp;= \text{is-unknown}(E) \\
\text{mue}(c,E)     &amp;= E(c,c) \\
\text{mua}(c,E,a)   &amp;= E(a) \\
\end{align} \]</p>
<p><strong>ma</strong> wraps the primitive concept of its argument being an atom.</p>
<p><strong>mai</strong> puts no constraint on its argument, and is true for any possible $(e).
However to be used $(e) must exist (at some point an existential variable must
be created), and for some definitions expressing this existence and nothing
more is useful.</p>
<p><strong>mae</strong> simply wraps <strong>universal quantification</strong> \(\forall\), and allow to
express something that is true for all possible values. Note that it is then
possible to use logical implication (\(P \Rightarrow G\) / \((\neg P) \wedge
Q\)) to only speak about a subset of values (the ones satisfying \(P\)).</p>
<p><strong>mao</strong> allows to express the concept that $(E) is a subset of $(A), in the
sense that any list of arguments that satisfy $(E) also satisfy $(A). It is
useful as it doesn't require the language itself to support variable amount of
arguments. Instead both $(E) and $(A) are just considered predicates of
possibly unknown arity and only the implication is relevant. $(E) and $(A)
can be of different arities, in which can <strong>arity mismatch resolution</strong> can
be used to give them identical arity. This word can be useful for some
definitions, or to express that a predicate $(E) represents multiple
combinaisons of values that make $(A) true, that answers a question represented
by $(A).</p>
<p><strong>mui</strong> allows to interact directly with the trivalent truth values of Eberban
logic, and is only true if the provided predicate $(E) is neither true or false.
It is not possible to define this predicate from logical operators as they
are defined with trivalent truth tables. Here is the truth table of the
<strong>AND</strong> (\(\wedge\)) operator :</p>
<table><thead><tr><th style="text-align: center">\(A \wedge B\)</th><th style="text-align: center">\(B = F\)</th><th style="text-align: center">\(B = U\)</th><th style="text-align: center">\(B = T\)</th></tr></thead><tbody>
<tr><td style="text-align: center">\(A = F\)</td><td style="text-align: center">\(F\)</td><td style="text-align: center">\(F\)</td><td style="text-align: center">\(F\)</td></tr>
<tr><td style="text-align: center">\(A = U\)</td><td style="text-align: center">\(F\)</td><td style="text-align: center">\(U\)</td><td style="text-align: center">\(U\)</td></tr>
<tr><td style="text-align: center">\(A = T\)</td><td style="text-align: center">\(F\)</td><td style="text-align: center">\(U\)</td><td style="text-align: center">\(T\)</td></tr>
</tbody></table>
<p><strong>mue</strong> and <strong>mua</strong> allows to interact with the usually hidden context argument.
<strong>mue</strong> accepts a 1-ary predicate that is true when provided the context as an
<strong>explicit argument</strong>, while <strong>mua</strong> takes a proposition $(E) and an atom $(a)
such that $(E) is true when $(a) is provided as the hidden context argument.
Those 2 predicate words are what allows the context argument to be really
useful: the grammar forwards automatically the context parameter for the
speaker, which can then be used by predicates.</p>
<p>Other <strong>MI</strong> particles are not logical wrapper and are simply root words
included in <strong>MI</strong> for convinience, and will be explained in a later chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predicate-transformations-zi"><a class="header" href="#predicate-transformations-zi">Predicate transformations (ZI)</a></h1>
<p>Particles of the__ZI__ family (all particles starting with <em>z-</em>) allow
transforming the immediatly following predicate, before chaining or explicit
bindings are performed.</p>
<blockquote>
<p>To use a <strong>ZI</strong> on more than one predicate word it should be wrapped in
brackets <strong>pe ... pei</strong>, which itself will be prefixed with <strong>ZI</strong>.</p>
</blockquote>
<h2 id="negations"><a class="header" href="#negations">Negations</a></h2>
<p><strong>zi</strong> allows to negate the predicate being prefixed. However it doesn't
negate any existential variables created when performing <strong>arity mismatch
resolution</strong> or other predicates in the chain or explicit bindings. <strong>zi</strong>
is called the <strong>short scope negation</strong>.</p>
<blockquote>
<p><strong>mi zi buri meon</strong></p>
<p>\[ \begin{align}
\text{mi}(c,e)       &amp;= \text{[$e$ is a speaker]} \\
\text{buri}(c,e,a)   &amp;= \text{[$e$ eats $a$]} \\
\text{meon}(c,e)     &amp;= \text{[$e$ is an apple]} \\
\ \\
\text{meon}_1(c,e)   &amp;= \text{meon}(c,e) \\
\ \\
\text{buri}_1(c,e,a) &amp;= \color{magenta}{(\neg \text{buri}(c,e,a))} \wedge \text{meon}_1(c,e) \\
\text{buri}^w_1(c,e) &amp;= \exists a. \text{buri}_1(c,e,a) \\
\ \\
\text{mi}_1(c,e)     &amp;= \text{mi}(c,e) \wedge \text{buri}^w_1(c,e) \\
\text{mi}^w_1(c)     &amp;= \exists e. \text{mi}_1(c,e)
\end{align} \]</p>
<p>Assertion given $(c):<br />
I and an apple exists but I don't eat it.<br />
Would be false if no apple existed.</p>
</blockquote>
<p>There exist also a <strong>long scope negation</strong> with particle <strong>bi</strong>, which negates
also existential variables introduced by the arity mismatch resultion and other
predicates in the chain or explicit bindings.</p>
<blockquote>
<p><strong>mi bi buri meon</strong></p>
<p>\[ \begin{align}
\text{buri}_1(c,e,a) &amp;= \text{buri}(c,e,a) \wedge \text{meon}(c,e) \\
\text{buri}^w_1(c,e) &amp;= \color{magenta}{\neg (\exists a. \text{buri}_1(c,e,a))} \\
\ \\
\text{mi}_1(c,e)     &amp;= \text{mi}(c,e) \wedge \text{buri}^w_1(c,e) \\
\text{mi}^w_1(c)     &amp;= \exists e. \text{mi}_1(c,e)
\end{align} \]</p>
<p>Assertion given $(c):<br />
I exist and it is false that I eat an apple.<br />
It doesn't imply the existence of an apple.</p>
</blockquote>
<blockquote>
<p><strong>bi</strong> is in its own family <strong>BI</strong> as it transforms more than just the prefixed
predicate.</p>
</blockquote>
<h2 id="names"><a class="header" href="#names">Names</a></h2>
<p>Prefixing a 1-ary predicate with <strong>za</strong> transforms it into a name:
\([\text{$e$ is named with property $P$} by $a$]\). <strong>SI</strong> can be added between
<strong>za</strong> and the predicate to select which argument is used for the property.
<strong>za</strong> is intransitive as it is most of the time not needed to define who named
$e$ like that.</p>
<p>To speak about the name itself <strong>zai</strong> must be used itself:
\([\text{$e$ is the name corresponding to property $P$}]\).</p>
<blockquote>
<p>Many things can have the same name, but the name itself is unique.</p>
</blockquote>
<h2 id="reference"><a class="header" href="#reference">Reference</a></h2>
<p><strong>ze</strong> allows to refer to the latest <strong>non-wrapped</strong> instance of the prefixed
predicate instead of creating a new instance. Arguments provided to this
reference predicate (ignoring the implicit context argument) are stated to be
equal to the onces the instance had.</p>
<blockquote>
<p><strong>mian buri
pa mi dona ze mian</strong></p>
<p>\[ \begin{align}
\text{mian}(c,e)                         &amp;= \text{[$e$ is a cat]} \\
\text{dona}(c,e,a)                       &amp;= \text{[$e$ likes $a$]} \\
\ \\
\text{buri}_1(c,e,a)                     &amp;= \text{buri}(c,e,a) \\
\text{buri}^w_1(c,e)                     &amp;= \exists a. \text{buri}_1(c,e,a) \\
\ \\
\color{magenta}{\text{mian}_1(c,e_1)}    &amp;= \text{mian}(c,e_1) \wedge \text{buri}^w_1(c,e_1) \\
\text{mian}^w_1(c)                       &amp;= \exists e. \text{mian}_1(c,e) \\
\ \\
\color{magenta}{\text{ze-mian}_1(c,e)}   &amp;= \color{magenta}{e = e_1} \\
\text{dona}_1(c,e_2,a_2)                 &amp;= \text{dona}(c,e_2,a_2) \wedge \color{magenta}{\text{ze-mian}_1(c,a)} \\
\text{dona}^w_1(c,e)                     &amp;= \exists a. \text{dona}_1(c,e,a) \\
\ \\
\text{mi}_1(c,e)                         &amp;= \text{mi}(c,e) \wedge \text{dona}^w_1(c,e) \\
\text{mi}^w_1(c)                         &amp;= \exists e. \text{mi}_1(c,e) \\
\end{align} \]</p>
<p>Assertion given $(c): A cat eats something.<br />
Assertion given $(c): I like <strong>this cat</strong>.</p>
</blockquote>
<p>When prefixing a compound, <strong>ze</strong> will refer the lastest instance of that
exact compound. To make sentences shorter, <strong>zei</strong> can be used before a
predicate word to refer the latest compound containing this word.</p>
<blockquote>
<p><code>ze eberban</code> will refer to the latest <code>eberban</code> instance, while <code>zei ban</code> will
refer to the latest compound containing <code>ban</code>, for exemple <code>eberban</code>.</p>
</blockquote>
<p>Which is the <strong>latest instance</strong> is determined by word order in the text, and
using a predicate defined using this word doesn't make it the <strong>latest</strong> again.
Thus in</p>
<p><em>po gia mian blan pa <strong>mian</strong> buri pa gia dona ze mian</em>,</p>
<p><em>ze mian</em> refers to the <strong>mian</strong> in bold in the <strong>pa</strong> sentence, and not the
<strong>mian</strong> in <strong>gia</strong>'s definition.</p>
<p>However if the last instance of the word is indeed in a definition (or in some
predicate that can be used multiple times), then <strong>ze</strong> refer to the last time
it has been used. Thus in</p>
<p><em>po gia <strong>mian</strong> blan pa gia dona ze mian</em>,</p>
<p><em>ze mian</em> refers to the <strong>mian</strong> inside <strong>gia</strong>'s definition, which is last
used in the <strong>pa</strong> sentence. The text can thus be translated as
&quot;A beautiful cat which likes itself&quot;.</p>
<p>With some predicates such as sets (<strong>tcu</strong> and other <strong>tc-</strong> initials) the
order in which the predicate is used is not defined. In this case <strong>ze</strong> refers
arbitrarily to one of them (which hypotetically would be the &quot;last one&quot;). Thus
in</p>
<p><em>pa meon sae buri tce <strong>mian</strong> pa mi dona ze mian</em></p>
<p>can be translated as &quot;An apple is eaten by some cats. I like one of those
cats.&quot; It is however prefered to not refer to such unordered instance, and
instead refer to a clearly ordered word such as <strong>tce</strong>, for which we can speak
about one of its members with <strong>tci</strong> (is a member of) :</p>
<p><em>pa meon sae buri <strong>tce</strong> mian pa mi dona tci ze tce</em></p>
<blockquote>
<p>A related concept is <strong>forethought references</strong>, which consist of using a
assignable variable <strong>KI/GI</strong> prefixed with <strong>bo</strong>, which creates a new
variable that can be referenced by the same <strong>KI/GI</strong> without <strong>bo</strong>, like
<strong>ze</strong> followed by a predicate word allows to reference the latest instance of
this predicate word. <strong>KI</strong> used like can be used similarely to pronouns
in other languages. <strong>bo GI</strong> is a bit more complex to use but is necessary
to define some concepts of Eberban's vocabulary.</p>
</blockquote>
<h1 id="instanciation"><a class="header" href="#instanciation">Instanciation</a></h1>
<p><strong>zu/zui</strong> allows to instanciate an argument of some predicate, which is
particularly useful when a predicate is shared using <strong>VI/FI</strong> or a <strong>KI</strong>
variable or argument and we want to use it with some arguments. <strong>GI</strong> variables
could be replaced with <strong>KI</strong> variables that are then used in chaining with
<strong>zu/zui</strong>. <strong>zu</strong> instanciate the predicate with <strong>transitive</strong> behavior while
<strong>zui</strong> is <strong>intransitive</strong>.</p>
<h2 id="other"><a class="header" href="#other">Other</a></h2>
<p><strong>zue</strong> allow to transform a predicate having a <strong>A</strong> 0-ary predicate place a
predicate having a <strong>A</strong> 1-ary predicate place which is satisfied by the <strong>E</strong>
argument.</p>
<p><strong>mi jine mi jvin</strong> (I want that [I dance]) can thus be replaced by <strong>mi zue
jine jvin</strong> (I want to dance).</p>
<p>Note that they are not exactly equivalent, as in the first example the 2 <strong>mi</strong>
might not refer to the same individual(s) (if there are multiple speakers),
while in the second example it is necessarily the same. Aside from this slight
difference both examples are here the same length and thus might seem a bit
overkill, but it is more usefull if the thing being repeated is longer than one
syllable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-arguments"><a class="header" href="#default-arguments">Default arguments</a></h1>
<p>Some predicates are often used with the same arguments. While it can be
possible to define new predicates that wraps them and provide this argument,
thus would lead to multiple words for the same concepts, and might not be
practical for predicates made with some grammar rules such as numbers. Also,
those common arguments might be specific to some text or speech.</p>
<p>To address the above, Eberban allows the management of <strong>default arguments</strong>,
which are properties that some arguments must satisfy <strong>only when there are no
explicit bounds on them</strong>.</p>
<p>Let's take as exemple the predicate <strong>espuateran</strong>, which means</p>
<p>\[\text{espuateran}(c,e,a) = [\text{$e$ is the home planet of species $a$}]\]</p>
<p>We could want that <strong>A</strong> are humans by default so that we don't have to always
specify it is the home planet of humans/Earth nor have to define another
separate predicate.</p>
<p>To do that, we can use the <strong>poie/poia/poio/poiu</strong> serie in <strong>PO</strong> to define
what is this default property: <code>poia espuateran flan</code> defines that by default
the <strong>A</strong> place of <strong>espuateran</strong> satisfy the property <strong>flan</strong> (being a human).
The <strong>E</strong> place don't have a default bind, which can be seen as having the
default bind of satisfying <strong>mai</strong> (exists).</p>
<blockquote>
<p><code>poia espuateran mai</code> can thus be used to &quot;remove&quot; the default human bind.</p>
</blockquote>
<p>This default property can be used with the <strong>zoie/zoia/zoio/zoiu</strong> serie
in <strong>ZI</strong>: <code>zoia espuateran</code> is thus equivalent to <code>flan</code> in this case.</p>
<p>Any argument that is not re-exported as an argument of the wrapping predicate and
not bound with chaining or explicit binding automatically have the default bound.</p>
<p>If an argument is re-exported by the wrapping predicate, the default bound is
not used, however the wrapped predicate inherits of it (as if <strong>poie/etc</strong> was
used on them too). This also applies with <strong>PO</strong> definitions, such as if we
define a predicate with <code>po ga espuateran</code> then the <strong>A</strong> argument of <strong>ga</strong>
also defaults to <em>flan</em>, and <em>ga</em> can be used in place of <em>espuateran</em>.</p>
<blockquote>
<p>Note that after defining <em>ga</em>, changing a default bind on <em>espuateran</em> will
not modify the one of <em>ga</em>. <code>poia ga ...</code> will thus be required instead.</p>
</blockquote>
<p>Here is an example with all default bindings added: </p>
<blockquote>
<p><strong>mi dona espuateran</strong></p>
<p>\[ \begin{align}
\text{mi}(c,e)                &amp;= \text{[$e$ is a speaker]} \\
\text{dona}(c,e,a)            &amp;= \text{[$e$ likes $a$]} \\
\ \\
\text{espuateran}_1(c,e,a)    &amp;= \text{espuateran}(c,e,a) \\
\text{zoia-espuateran}_1(c,e) &amp;= \text{zoia-espuateran}(c,e) \\
\text{espuateran}^w_1(c,e)    &amp;= \exists a. \text{espuateran}_1(c,e,a) \color{magenta}{\wedge \text{zoia-espuateran}_1(c,a)} \\
\ \\
\text{dona}_1(c,e,a)          &amp;= \text{dona}(c,e,a) \wedge \text{espuateran}^w_1(c,e) \\
\text{zoia-dona}_1(c,e)       &amp;= \text{zoia-dona}(c,e) \\
\text{dona}^w_1(c,e)          &amp;= \exists a. \text{dona}_1(c,e,a) \color{magenta}{\wedge \text{zoia-dona}_1(c,a)} \\
\ \\
\text{mi}_1(c,e)              &amp;= \text{mi}(c,e) \wedge \text{dona}^w_1(c,e) \\
\text{mi}^w_1(c)              &amp;= \exists e. \text{mi}_1(c,e) \\
\end{align} \]</p>
<p>I like the home planet of humans (Earth, until humans start to live on other planets).</p>
</blockquote>
<p>Manually binding the argument will prevent the default bind to be added:</p>
<blockquote>
<p><strong>mi dona espuateran va mian</strong></p>
<p>\[ \begin{align}
\text{mi}(c,e)                &amp;= \text{[$e$ is a speaker]} \\
\text{dona}(c,e,a)            &amp;= \text{[$e$ likes $a$]} \\
\text{mian}(c,e)              &amp;= \text{[$e$ is a cat]} \\
\ \\
\text{mian}_1(c,e)            &amp;= \text{mian}(c,e) \\
\ \\
\text{espuateran}_1(c,e,a)    &amp;= \text{espuateran}(c,e,a) \color{magenta}{\wedge \text{mian}_1(c,e)}\\
\text{espuateran}^w_1(c,e)    &amp;= \exists a. \text{espuateran}_1(c,e,a) \\
\ \\
\text{dona}_1(c,e,a)          &amp;= \text{dona}(c,e,a) \wedge \text{espuateran}^w_1(c,e) \\
\text{zoia-dona}_1(c,e)       &amp;= \text{zoia-dona}(c,e) \\
\text{dona}^w_1(c,e)          &amp;= \exists a. \text{dona}_1(c,e,a) \color{magenta}{\wedge \text{zoia-dona}_1(c,a)} \\
\ \\
\text{mi}_1(c,e)              &amp;= \text{mi}(c,e) \wedge \text{dona}^w_1(c,e) \\
\text{mi}^w_1(c)              &amp;= \exists e. \text{mi}_1(c,e) \\
\end{align} \]</p>
<p>I like the home planet of cats (still Earth, unless we find or bring cats on other planets).</p>
</blockquote>
<blockquote>
<p>Other chapters will omit default binds unless they are important to reduce
verbosity.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dictionary-conventions"><a class="header" href="#dictionary-conventions">Dictionary conventions</a></h1>
<h2 id="notation"><a class="header" href="#notation">Notation</a></h2>
<p>In the dictionary words meaning are given in english with arguments being
represented by vowels in brackets <code>[]</code>. The first time the vowel is used it is
followed by an annotation about its type and constraints.</p>
<p>Parenthesis <code>()</code> represents predicate arguments, where each argument constraint
is listen in between, separate by commas.</p>
<p>Otherwise the vowel can be followed by one or many eberban words, in which can
the place is constrained to satisfy the expressed property. Single letters like
<code>a</code> can be used to represent <strong>generic types</strong>. In a definition the same letter
used in multiple places means the arguments share the same type.</p>
<blockquote>
<p>Exemples of definitions:</p>
<ul>
<li><code>mi: [E:tce* man] is I/me/a speaker/author.</code></li>
<li><code>buri: [E:tce* den] eats [A:tce* den].</code></li>
<li><code>meon: [E:tce* den] is an apple.</code></li>
<li><code>[E:tcei a] is a (non-empty) set of some things that individualy satisfy [A:(tca a)].</code></li>
<li><code>mue: True if property [E:(ma)] is true with the context provided as argument.</code></li>
<li><code>mua: True if context [E:ma] makes [A:()] true.</code></li>
</ul>
</blockquote>
<h2 id="set-arguments"><a class="header" href="#set-arguments">Set arguments</a></h2>
<p>Many predicates expects their arguments to be <strong>sets</strong>, which is expressed in
Eberban by the roots starting with <em>tc-</em>. <strong>tce</strong> in particular states that it
is a non-empty set. In definitions a star <code>*</code> is added next to it when the
predicate use this set in a <strong>distributive</strong> way, which means that the predicate
is also true if we provide a subset. Otherwise it is said to be <strong>collective</strong>,
and a set satisfying the predicate don't necessarily imply that a subset of
it will also satisfying the predicate.</p>
<p>Having mainly set arguments like so means that unless specified the amount of
members of the set is left vague. Thus, the sentence <em>mi buri meon</em> could
equally mean the following :</p>
<ul>
<li><strong>I</strong> eat <strong>one apple</strong>.</li>
<li><strong>We</strong> eat <strong>one apple</strong>.</li>
<li><strong>I</strong> eat <strong>multiple apples</strong>.</li>
<li><strong>We</strong> eat <strong>multiple apples</strong>.</li>
</ul>
<p>It also doesn't specify which one the apples everyone is eating: <strong>buri</strong> is
satisfied if everyone eats at least one of the apples, and every apple is eaten
by at least one.</p>
<p>This allows to be vague by default, which can be made more precise by adding
more words.</p>
<blockquote>
<p>For simplicity translations will be written with singular unless it is
important to make the distinction.</p>
</blockquote>
<!-- ## Map arguments and context

Another kind of data structure used in eberban is a __map__ or __dictionary__,
which consist of a set of __keys__ each assiocated with a __value__. This allow
to "store" multiple information into a single atom. Since the context argument
is used to implement many features, it is thus using maps.

Definitions might refer to entries of such maps using the `@` symbol followed
by the name of the key. If `@` is used just after a vowel then it means the
vowel argument is map and the definition is refering to an entry of such map.
If there are no vowel before, it refers to an entry of the context argument.

Exemples will be given in later chapters when explaining concepts using contexts
or maps. --><div style="break-before: page; page-break-before: always;"></div><h1 id="discourse-predicates-mi"><a class="header" href="#discourse-predicates-mi">Discourse predicates (MI)</a></h1>
<p>Discourse predicates are additional <strong>MI</strong> particles that don't wrap logical
primitives, but are instead part of <strong>MI</strong> for historical reasons and are
related to the discourse.</p>
<p><strong>mi</strong> refers to one of the speaker(s) in speech, or narrator(s) in writen media. </p>
<p><strong>mio</strong> refers to a set of individuals which include at least one of the speakers
and at least one of the listener(s)/interlocutor(s), and doesn't include something
that is neither a speaker or listener. It can be seen as an <strong>inclusive we</strong>.</p>
<p><strong>mie</strong> on the other hand refers to a set of individuals which includes at least
one of the speakers and which can include anything that <strong>is not</strong> the speaker.
It can be seen as an <strong>exclusive we</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrowings-u-"><a class="header" href="#borrowings-u-">Borrowings (u-)</a></h1>
<p>Borrowings allow importing words from other languages which would be difficult
or even impossible to translate using root words, such as proper names,
names of species, and some cultural concepts eberban avoids including
in its roots to be more culturally neutral.</p>
<p>Borrowings start with the letter <strong>u</strong>, followed by the borrowed word written
in the phonology and morphology allowed by eberban while trying to stay
close to the original pronounciation.</p>
<p>If the borrowed word starts with <strong>u</strong> then the prefix used is <strong>u'</strong> to avoid
2 consecutive <em>u</em>.</p>
<p>A chain of multiple borrowings will count as only one predicate composed of
multiple parts. To prevent 2 borrowings to fusing into one predicate, you can
separate them with the particle <strong>be</strong> (<strong>be</strong> can optionally appear after
every borrowing group but is only necessary when separating multiple groups).</p>
<p>Its meaning is not defined in eberban, and its truth value is always undefined.
It can be used to import foreign words that interlocutors will collectively
understand, but using non-borrowings is always prefered if possible.
Borrowings can have any number of places, and since it is not defined in eberban
each place is considered to be generic place (no type inference can be
performed). Chaining will always consider it is a generic/atom place (like bound
with ve/va/...), and vie/via/... must be used for predicate equivalence
bindings.</p>
<p>Like roots and compounds, borrowings are transitive if they end with a vowel,
while they are intransitive if they end with a consonant (not only sonorants).</p>
<p>Borrowing can be used to import proper nouns by prefixing them with particle
<strong>za</strong>, which gives it the meaning <code>[tce* man] is named [borrowed word]</code> (a
more complete explanation of <strong>za</strong> will be given a later chapter).</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<div data-gloss>
<p>mi za umia uentropi (be)</p>
<p>mi {za umia uentropi} {(be)}</p>
<p>{E:$(x) is the speaker} {[E:$(x) is named &quot;mia entropi&quot;]} {(end of borrowing)}</p>
<p>I am named &quot;mia entropi&quot;.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compounds-1"><a class="header" href="#compounds-1">Compounds</a></h1>
<p>Providing a root for every concept would be extremely impractical and isn't
great for memorization. Complex concepts are often built upon multiple more
primitive concepts, and compounds are used for this purpose.</p>
<p>Compounds allow the transformation of any string of valid eberban words
(particles, roots and borrowings) into a single unit, <strong>ignoring their
grammatical rules</strong> but should keep (to a certain extent) a related meaning.</p>
<p>A compound is first prefixed by the letter <strong>e, a, o</strong>, respectively starting a
compound composed of 2, 3, or more words. O-compounds stop when a new <strong>o</strong> is
encountered (with a space or word boundary marker before it). Spaces can be
inserted between any of the parts of the compound.</p>
<p>If the first word starts with a vowel (a borrowing) then the pause before this
vowel is optional.</p>
<p>Compounds have <strong>unique and fixed meanings which are defined in the dictionary</strong>,
and while the definition of each one can be arbitrary, they usually provide
places taken from their individual components. Usually, the most important word
is the rightmost one, and additional words are added to the left to help narrow
down the meaning, yielding greater precision.</p>
<p>It is common to lexicalize a borrowing by making a compound with it. Cultural
concepts are borrowed with endonyms, sounding similar to the original word.</p>
<p>A compound follow the same <strong>chaining behavior</strong> as its last/right-most
component. If we want to define a compound with the opposite chaining behavior,
the initial vowel is followed by an <strong>i</strong>.</p>
<blockquote>
<p><strong>e ber ban :</strong> <code>[tca man] is the eberban language.</code></p>
<ul>
<li>ber : <code>[E:tce* man] reflects this language (eberban).</code></li>
<li>ban : <code>[E:tce* man] is a language.</code></li>
</ul>
</blockquote>
<blockquote>
<p><strong>e uinglic ban :</strong> <code>[E:tca ban] is the english language.</code></p>
<ul>
<li>uinglic : borrowing of &quot;english&quot;.</li>
<li>ban : <code>[E:tce* man] is a language.</code></li>
</ul>
</blockquote>
<blockquote>
<p><strong>a cen po bu :</strong> <code>[E:tce* ma] is a dictionary.</code></p>
<ul>
<li>cen : <code>E:tce* man</code></li>
<li>po : Particle starting a definition.</li>
<li>bu : Particle creating lists.</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quotes-c-"><a class="header" href="#quotes-c-">Quotes (c-)</a></h1>
<p><strong>ca</strong> (<strong>CA</strong> family) allow quoting any grammatical eberban text, and is
terminated by <strong>cai</strong> (<strong>CAI</strong>). The text can itself contain inner <strong>ca</strong> quotes
as <strong>cai</strong> will match its opening <strong>ca</strong>. The quote acts as a predicate with
meaning <code>[tca man] is text [text].</code></p>
<p><strong>ce</strong> (<strong>CE</strong>) allows quoting a single eberban word (particle, root, borrowing,
compound), ignoring its grammar. It has the definition <code>[tca man] is word [word].</code></p>
<p><strong>cei</strong> will instead express the family of the word.</p>
<ul>
<li><strong>ce fe</strong> : <code>[tca man] is the word &quot;fe&quot;.</code></li>
<li><strong>cei fe</strong> : <code>[tca man] is word family FE.</code></li>
<li><strong>ce spi</strong>: <code>[tca man] is the word &quot;spi&quot;.</code></li>
<li><strong>cei spi</strong>: <code>[tca man] is the concept of a root word.</code></li>
</ul>
<p><strong>co</strong> (<strong>CO</strong>) allows quoting anything such as foreign text, ungrammatical
eberban text or even arbitrary data. <strong>co</strong> is followed by a single arbitrary
root or particle, which has the role of a delimiter (it is not necessary for it
to be an existing particle or root, only a valid form), followed by a word
boundary marker__. Any following characters (including spaces) are considered
part of the quoted text. The quote ends when this word appears again prefixed by
a <strong>word boundary marker</strong>. The delimiter word prefixed by a word boundary
marker must <strong>NOT</strong> appear in the text, either written with same letters or
pronounced the same way, as it will be considered to be the end of the quote,
and remaining part will leak out of the quote.</p>
<p>This whole block acts as a predicate with the definition <code>[tca man] is foreign text/arbitrary data with content: [content].</code></p>
<p>As the content may be unreadable for the speaker, they can use the single word
<strong>coi</strong> (<strong>COI</strong>) instead of the full quote. Foreign quotes are the canonical
way to embed things such as images or URLs into eberban text. It is recommended
however to provide a description in eberban to help comprehension for all
speakers, listeners or readers.</p>
<div data-gloss>
<p>eberban sae banu [ca mi dona eberban cai] siro [co zao'I like eberban'zao] banu euinglic'ban</p>
<p>eberban sae banu {ca mi dona eberban cai} siro {co zao'I like eberban'zao} banu euinglic'ban</p>
<p>{E:$(x) is the eberban language} {chain A&gt;E} {E:$(y) is expressed in language A:$(x)}
{E:$(y) is text &quot;I like eberban&quot; (in eberban)} {E:$(y) has translation A:$(z)}
{E:$(z) is text &quot;I like eberban&quot; (foreign)} {E:$(z) is expressed in language A:$(w)}
{E:$(w) is the english language}</p>
<p>&quot;mi dona eberban&quot; (in eberban) has translation &quot;I like eberban&quot; (in english).</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lists-bu"><a class="header" href="#lists-bu">Lists (BU)</a></h1>
<p>Making list of things is a very useful concept, and thus gets its own grammar to
make them short to make.</p>
<p>In every place a chain of predicates is allowed, <strong>bu</strong> can be used to mark the
end of an item of the list, and transform the chain into a list of chains.</p>
<p><strong>bli</strong> is a predicate making the connection between sets and lists, and thus
allow to make sets using the list syntax. It has meaning <code>[E:tce a] is a set containing all elements in sequence [A:blu a] (duplicates removed)</code>, <strong>blu</strong>
being the word for a list.</p>
<blockquote>
<p><strong>mi seo spi bli [va [za ualisi] bu [za ubobo]]</strong></p>
<p>I speak (says something) to Alice and Bob.</p>
</blockquote>
<p>Note that <strong>VI/FI/PE</strong> is often required to use <strong>bu</strong>, as <strong>bu</strong> have
lower precedence than chaining.</p>
<blockquote>
<p><strong>[mi seo spi bli za ualisi] bu [za ubobo]</strong></p>
<p>This sentence is nonsence as <strong>bli</strong> expects a <strong>A</strong> list argument but is
provided a name directly.</p>
</blockquote>
<blockquote>
<p><strong>pe ... pei</strong> are particularily useful to make nested lists.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numbers-tij-"><a class="header" href="#numbers-tij-">Numbers (TI/j-)</a></h1>
<p>Numbers are important to communicate and serve many purposes. Eberban numbers
are expressed as a chain of <strong>TI</strong> particles (any particles starting with <em>t-</em>),
which can optionaly contain separators and a terminator starting with <em>j-</em> to
make more advanced numbers.</p>
<h2 id="digits"><a class="header" href="#digits">Digits</a></h2>
<p>Numbers are mainly composed of digits (<strong>TI</strong> family), which are chained one
after the other, starting from the highest significant one to the lowest, and is
by default expressed in base ten.</p>
<table><thead><tr><th style="text-align: center"></th><th style="text-align: center">-i</th><th style="text-align: center">-e</th><th style="text-align: center">-a</th><th style="text-align: center">-o</th><th style="text-align: center">-u</th></tr></thead><tbody>
<tr><td style="text-align: center">t-</td><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">2</td><td style="text-align: center">3</td><td style="text-align: center">4</td></tr>
<tr><td style="text-align: center">ti-</td><td style="text-align: center"></td><td style="text-align: center">5</td><td style="text-align: center">6</td><td style="text-align: center">7</td><td style="text-align: center">8</td></tr>
<tr><td style="text-align: center">te-</td><td style="text-align: center">9</td><td style="text-align: center"></td><td style="text-align: center">A</td><td style="text-align: center">B</td><td style="text-align: center">C</td></tr>
<tr><td style="text-align: center">ta-</td><td style="text-align: center">D</td><td style="text-align: center">E</td><td style="text-align: center"></td><td style="text-align: center">F</td><td style="text-align: center">...</td></tr>
</tbody></table>
<p><strong>te ta</strong> thus means <strong>12</strong> while <strong>tei ti tu</strong> means <strong>904</strong>.</p>
<p>While it is normally not allowed to use a digit higher than the base, it is
allowed if only one digit is used since there is no ambiguity over its value.
<strong>teo</strong> is thus <strong>F/15</strong>, while <strong>teo ti</strong> is not allowed in base ten.</p>
<blockquote>
<p>The serie described in the table is infinite and can be expanded if the
speaker wants to use larger bases, by iterating over the vowels in order and
skipping cases where the same vowel appears multiple times in a row (since
eberban considers multiple identical letters the same as a single one)</p>
<p>ti, ta, ..., tu<br />
tie, tia, ..., tua, tuo<br />
tiei, tiea, ..., tuoa, tuou</p>
</blockquote>
<h2 id="number-syntax"><a class="header" href="#number-syntax">Number syntax</a></h2>
<p>Numbers follow the following syntax:</p>
<p>(<em>base</em> <strong>ju</strong>)? <em>integer-part</em> (<strong>jo</strong> <em>fractional-part</em> (<strong>ja</strong> <em>repeated-part</em>)?)? (<strong>je</strong> <em>magnitude</em>)?</p>
<ol>
<li>Optionaly the <em>base</em> of the number can be expressed by a single <strong>TI</strong>
followed by <strong>ju</strong>. This <strong>TI</strong> is the last digit of the base used, thus
<strong>tei ju</strong> is base ten, <strong>teo ju</strong> is base twelve, and <strong>tao ju</strong> is
hexadecimal.</li>
<li>The <em>integer part</em> of the number, as a string of 0 or more digit <strong>TI</strong>. If
there are 0 digit then a fractional part is mandatory.</li>
<li>This integer part can then optionally be followed by <strong>jo</strong> and a <em>fractional
part</em> which is also a string of 0 or more digits <strong>TI</strong>. <strong>joi</strong> can be used
instead to also make the number negative.</li>
<li>If there is a fractional part it can be followed by <strong>ja</strong> and a <em>repeated
part</em> which is also a string of at least one digit <strong>TI</strong>. The number have
those digits repeated indefinitely.</li>
<li>Regardless of the precense of a fractional part, the number can then contain
<strong>je</strong> followed by a <em>magnitude</em>, which is a string of at least one digit
<strong>TI</strong>. The value expressed is the previous part multiplied by
\(\text{base}^{\text{magnitude}}\). <strong>jei</strong> can be used instead to express
a negative magnitude.</li>
</ol>
<blockquote>
<p>Examples :</p>
<ul>
<li>teo ju tie tia = \(56_{12}\)</li>
<li>tu ta = \(42\)</li>
<li>to jo te tu te tie tei = \(3.14159\)</li>
<li>to jo te ja to = \(3.1\overline{3}\), \(3.1333\dots\)</li>
<li>to jo ja to = \(3.\overline{3}\), \(3.333\dots\)</li>
<li>to joi = \(-3\)</li>
<li>tia jo ti ta ta je ta to = \(6.022 \times 10^{23}\)</li>
<li>tei jo te ti tei jei to te = \(9.109 \times 10^{-31}\)</li>
</ul>
</blockquote>
<h2 id="various-usage-of-numbers"><a class="header" href="#various-usage-of-numbers">Various usage of numbers</a></h2>
<p>Numbers have various usages which require different definitions and arguments.
The wanted definition can be selected by ending the number with a particle of
family <strong>JI</strong> (<strong>jie</strong> is infered if omitted). <strong>jie</strong> is mandatory between
consecutive numbers to tell them apart. Particles other than <strong>jie</strong> must be
non-zero positive integer (no fractional part).</p>
<ul>
<li><strong>ji</strong>: <code>[E:tce* a] is (a group of) [number] things satisfying [A:(tca a)].</code><br />
Speaks about a set of expressed cardinality.</li>
<li><strong>jia</strong>: <code>[E:tce* a] is (a group of) [number] things satisfying [A:(a)].</code><br />
Same but use the raw property variant of sets definitions.</li>
<li><strong>jio</strong>: <code>[E:tcu a] is (a group of) the only [number] things satisfying [A:(tca a)].</code><br />
Those are the only things that satisfy the property. There doesn't exist
something that is not in the set but satisfy A.</li>
<li><strong>jioa</strong>: <code>[E:tcu a] is (a group of) the only [number] things satisfying [A:(a)].</code><br />
Same but use the raw property variant of sets definitions.</li>
<li><strong>jiu</strong>: <code>[E:tca a] is the [number]th member of sequence [A:blu a].</code><br />
Speaks about an element in an ordered list.</li>
<li><strong>jie</strong>: <code>[E:tce gan] is the number [number] times [A:tce gan] (default: 1 unitless).</code><br />
<code>gan</code> is the word for a number, and both arguments are sets of numbers. Those
sets allows to handle many numbers (ranges, approximations, or even
arbitrarily constructed ones), and math operations are also defined using sets
to distributivly operate on each value of the set. The <strong>A</strong> argument allows
to multiply this number with another number such as unit numbers (&quot;1 meter&quot;,
&quot;1 kilogram&quot;, etc). The <strong>A</strong> arguments defaults to <strong>1 unitless</strong>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="annotations-d-"><a class="header" href="#annotations-d-">Annotations (d-)</a></h1>
<p>Annotations are additional grammar that doesn't modify the logical meaning
of the text, and simply add notes or metadata. Those annotations are also
called &quot;free&quot; prefixes and suffixes as they can be added freely before and
after many elements of the grammar.</p>
<h2 id="paragraph-marker-du"><a class="header" href="#paragraph-marker-du">Paragraph marker DU</a></h2>
<p><strong>DU</strong> can be placed before <strong>PE/PA/PO/PU</strong> to mark a change of subject or
new paragraph. If <strong>DU</strong> is not followed by one of them then <strong>pa</strong> is implied.
If multiple prefixes in a row are used it must be the first of them.</p>
<h2 id="free-prefixes-di"><a class="header" href="#free-prefixes-di">Free prefixes DI</a></h2>
<p><strong>DI</strong> contains all particles starting with <em>di-</em> and are prefixes to other
elements of the grammar. They currently contains particles related to &quot;focus&quot;:</p>
<ul>
<li><strong>di</strong>: Attention focus: the listener should be extra attentive to the
following word. Maybe it would be especially prone to confusion? </li>
<li><strong>die</strong>: Contrastive focus: It's that thing and not something else that was
expected. </li>
<li><strong>dia</strong>: Newsworthiness focus: Marks the part of the sentence containing the
most important new information.</li>
</ul>
<h2 id="free-interjection-de-suffix"><a class="header" href="#free-interjection-de-suffix">Free interjection DE (suffix)</a></h2>
<p><strong>DE</strong> contains all particles starting with <em>de-</em> and is a suffix to other
elements of the grammar. It is followed by a single predicate which can be
prefixed by <strong>SI/ZI</strong>. However it doesn't support chains of predicates, unless
they are wrapped in <strong>pe ... pei</strong>.</p>
<p><strong>de</strong> uses this predicate as an interjection. Using a borrowing can be used
to make onomatopoeia, like <code>de uahaha</code> for laughter. Using a predicate word
could be compared to emojis or lojban's attitudinals, like <code>de gli</code> (love/❤️).</p>
<p><strong>dei</strong> uses this predicate as a metadata tag or <em>#hashtag</em>.</p>
<h2 id="free-parenthetical-dadai-suffix"><a class="header" href="#free-parenthetical-dadai-suffix">Free parenthetical DA...DAI (suffix)</a></h2>
<p><strong>DA</strong> allow to start a parenthetical note which is ended by <strong>DAI</strong>.
This note can be any valid eberban text.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time"><a class="header" href="#time">Time</a></h1>
<blockquote>
<p>More complete (and complex) explanations can be found in <a href="concepts/../from_scratch/step2/time.html">the chapter
defining such concepts</a>.</p>
</blockquote>
<h2 id="what-is-the-time-system"><a class="header" href="#what-is-the-time-system">What is the time system?</a></h2>
<p>Time is represented using a graph of instants. It supports multiple possible futures and pasts, parallel and fictional universes. The implicit context argument with some predicates allow to handle time-related stuff behind the scene. Events are defined using <strong>time spans</strong>, which are all instants between a start and end instant, and usually can't be cut into multiple parts. </p>
<h2 id="what-is-the-default-tense-of-a-sentence"><a class="header" href="#what-is-the-default-tense-of-a-sentence">What is the default tense of a sentence?</a></h2>
<p>By default it the present.</p>
<p>It can be set back to any time/tenseless with</p>
<pre><code>pae            sve              mai
update-context set-initial-span true
</code></pre>
<p>The default/initial time span of a sentence can be set to the present with</p>
<pre><code>pae            sve              del
update-context set-initial-span present-span
</code></pre>
<p>(For the following explanations we'll consider it is the present)</p>
<h2 id="how-a-simple-sentence-work"><a class="header" href="#how-a-simple-sentence-work">How a simple sentence work?</a></h2>
<pre><code>mian buri meon
cat  eat  apple
</code></pre>
<p>This sentence is only true if there is an overlap between those 3 events:</p>
<ul>
<li>a cat X exists</li>
<li>an apple Y exists</li>
<li>X eats Y</li>
</ul>
<p>This overlapping time span must itself overlap with the initial time span (present)</p>
<h2 id="possible--necessary"><a class="header" href="#possible--necessary">Possible / Necessary?</a></h2>
<p>Tenses used in sentence each have 2 variants: possible and necessary.</p>
<p>Possible means that there exist at least 1 time line in which the event occurs.</p>
<p>Necessary means that it must occurs in all timelines.</p>
<h2 id="how-to-use-tenses-in-a-sentence"><a class="header" href="#how-to-use-tenses-in-a-sentence">How to use tenses in a sentence?</a></h2>
<p>Tense predicates express that some proposition occurs in relation with the
outer sentence <strong>overlapping span</strong> (the time span that is part of the time
span of all events), that we'll write as C for &quot;context&quot;.</p>
<p>The tenses are:</p>
<ul>
<li><strong>sel/sen</strong>: E meets C (end instant of E = first instant of C)</li>
<li><strong>sal/san</strong>: E starts C  (they share the same start instant)</li>
<li><strong>sol/son</strong>: E finishes C (they share the same end instant)</li>
<li><strong>sul/sun</strong>: E is met by C (end instant of C = first instant of E)</li>
<li><strong>siel/sien</strong>: E is before C</li>
<li><strong>sial/sian</strong>: E contains C</li>
<li><strong>siol/sion</strong>: E contained by C (there is no difference between both variants)</li>
<li><strong>siul/siun</strong>: E is after C</li>
<li><strong>sil/sin</strong>: E overlaps with C</li>
</ul>
<p>The ones ending with <strong>-l</strong> are the <strong>possible</strong> variants, while <strong>-n</strong> are the
<strong>necessary</strong> variants.</p>
<pre><code>mi sni   mo  vi sul             mo  sni   mi
I  greet you &amp;  possible-met-by you greet me
I greet you, which is possibly immediatly followed by you greeting me.
</code></pre>
<p>Which can be drawn as:</p>
<pre><code>--------------------- Time --------------------&gt;

--------- X is me ------------------------------
------------------- Y is you -------------------
   |---- X greets Y ----|
   |-- Sentence span ---|
         |              |--- sul span -----|
         |              |---- Y greets X --|
         |
        |-| Present (initial span)
</code></pre>
<h2 id="detached-time-spans"><a class="header" href="#detached-time-spans">Detached time spans</a></h2>
<ul>
<li><strong>zvi:</strong> <code>[E:dinu]</code> is a time span shared by all events of <code>[A:()]</code>.</li>
<li><strong>zvin:</strong> Time span <code>[E:dinu]</code> contains context time span.</li>
<li><strong>zvil:</strong> <code>[E:dinu]</code> is the context time span.</li>
</ul>
<p>The predicate <strong>zvi</strong> is one of the building blocks of the time system, and
allows to talk about the time span that is shared/common between all time spans
of a proposition. This time span is itself <strong>NOT</strong> stated to be part of an outer
shared/common time span.</p>
<p>Stating that a time span is part of the shared time span is done with <strong>zvin</strong>,
while <strong>zvil</strong> allows to access this shared time span.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-systems"><a class="header" href="#writing-systems">Writing systems</a></h1>
<p>As presented in morphology chapter Eberban can be written using the latin
alphabet. However there is also a custom writing system taking advantage
of words morphology which is usable in a <strong>linear form</strong> similar to how
text is written in latin alphabet or pronounced, and in a <strong>planar form</strong>
which replaces argument binding particles like <strong>VI, FI or SI</strong> by graphical
2D notation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linear-writing-system"><a class="header" href="#linear-writing-system">Linear writing system</a></h1>
<img src="writing/symbols.svg" style="width: 100%" />
<blockquote>
<p>Text on the right is <code>mi ve kali vahul fe buri pcien</code>, which translates to
<em>I drink milk and eat bread</em>.</p>
</blockquote>
<p>The linear writing system is based on a central line called the <strong>stem</strong> on
which vowel symbols are attached, while consonant symbols added near it. Symbols
for consonants are organized in pairs of voiced and unvoiced consonants which
are mirror of each other relative to the stem.</p>
<p>To write text in this script, the stem first start by a dot or circle, which is
necessary to avoid reading direction ambiguity in some cases. This dot or circle
is also used to write world boundary markers.</p>
<p>Then the letters are written following those steps:</p>
<ol>
<li>If any write the consonant symbol on the correct side, or write a dot/circle
if the word starts with a vowel.</li>
<li>If there is a second consonant, write it next next to the consonant, away
from the stem.</li>
<li>Then write the vowel on the other side of the stem. If there are no prior
consonant the side can be arbitrarily choosen.</li>
<li>Finally, if the vowel is followed by a sonorant, write it next to the vowel,
away from the stem.</li>
<li>Then: 
<ul>
<li>If the next letter is consonant, return to step 1.</li>
<li>If the next letter is the initial vowel of the next word, write the
dot/circle on the stem and go to step 3.</li>
<li>If the next letter is a vowel in the same word, move forward along the</li>
<li>stem and write the next vowel symbol on the <strong>same side</strong> as the previous
vowel.</li>
<li>If the next letter is a H, move forward along the stem and write the next
vowel symbol on the <strong>opposite side</strong> of the previous vowel.</li>
</ul>
</li>
</ol>
<p>Since the writing system uses symetry to distinguish letters, it is important
to know if its support medium is mirrored or not (text written on glass readable
from both sides, text seen in a mirror, mirrored picture, etc). For that
purpose, it is recommanded to write near the text the <strong>chirality symbol</strong> for
which it is easy to see if it is mirrored or not.</p>
<p>The stem can twisted/change direction arbitrarily as long as the curves are
smooth and there is no self intersection.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eberban-from-scratch"><a class="header" href="#eberban-from-scratch">Eberban from scratch</a></h1>
<p>One of the long term goal of Eberban is to have its vocabulary entirely defined
in Eberban itself, and not realy on external or <em>opaque</em> predicates.</p>
<p>To achieve such goal Eberban is designed following those 3 steps:</p>
<ol>
<li><strong>Core grammar:</strong> subset of the complete grammar that is enough to define
important concepts. It doesn't include some of the &quot;syntaxic sugar&quot; grammar
that requires concepts from step 2.</li>
<li><strong>Core vocabulary:</strong> vocabulary defined using only the <strong>core grammar</strong>. It
defines many useful concepts such as sets, maps, lists, and numbers. Once the
necessary concepts are defined the grammar can be extended to reduce
verbosity, up to being able to define the <strong>full (extended) grammar</strong>.</li>
<li><strong>Extended vocabulary:</strong> vocabulary that can use the <strong>full grammar</strong>, and
makes what can be considered the &quot;official&quot; dictionary.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-grammar"><a class="header" href="#core-grammar">Core grammar</a></h1>
<p>The core grammar is a subset of the complete grammar that gives a logical base
to define other concepts.</p>
<p>The core grammar contains the following particles:</p>
<ul>
<li><strong>BI</strong>, <strong>BE</strong>, <strong>BA</strong>, and <strong>BO</strong>. <strong>BU</strong> is not included as it allows to
build lists which are not part of the logical framework itself, and itself
will be build on top of it.</li>
<li><strong>DI</strong>, <strong>DE</strong>, <strong>DA</strong>, <strong>DAI</strong> and <strong>DU</strong> particles as they are only metadata
and don't interact with the logical transcription. The full grammar and
vocabulary is allowed inside <strong>DA ... DAI</strong> to allow comments on the design
choices in Eberban.</li>
<li><strong>SI</strong>: chaining selection</li>
<li><strong>zi</strong>, <strong>ze</strong>, <strong>zei</strong>, <strong>zu</strong>, <strong>zoie</strong>, <strong>zoia</strong>, <strong>zoio</strong> and <strong>zoiu</strong> as
they are related to the logical framework. <strong>za</strong> and <strong>zai</strong> are related to
names which require some predicates to define.</li>
<li><strong>VI</strong>, <strong>FI</strong> and <strong>VEI</strong> for explicit bindings</li>
<li><strong>GI</strong> and <strong>KI</strong> for variables</li>
<li><strong>ma</strong>, <strong>mai</strong>, <strong>mae</strong>, <strong>mao</strong>, <strong>mui</strong>, <strong>mue</strong> and <strong>mua</strong>, as they are
wrapper around the underlying logic. Discourse predicates are not included as
we need to be able to model the discourse itself.</li>
<li><strong>PE</strong> and <strong>PEI</strong> as spoken brackets.</li>
<li><strong>pae</strong> and <strong>pahe</strong> to manipulate the context, and <strong>pahi</strong> to register a
sentence wrapper. <strong>pa</strong> itself is not included as it is related to the
discourse, and is an assertion about what the speaker thinks is true.</li>
<li><strong>po</strong> to define new predicates. <strong>poi</strong> is not included as it conveys the
expectation of the speaker for a listener to answer a question.
<strong>poie</strong>, <strong>poia</strong>, <strong>poio</strong> and <strong>poiu</strong> are also included to define defaults
which is part of the logical framework.</li>
<li><strong>PU</strong>: axiom toggle, which is the key component allowing to define new
concepts in the language.</li>
</ul>
<p>Other particles are not allowed and will be syntaxic sugar on top of the <strong>core
grammar</strong> and <strong>core vocabulary</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="few-simple-predicates"><a class="header" href="#few-simple-predicates">Few simple predicates</a></h1>
<p>As a first step, we can define a few useful predicates using the core grammar
that will reduce the verbosity of other definitions. For exemple we can define
predicates for the OR and AND logic gates of 2 propositions.</p>
<blockquote>
<p>vari: True if both <code>[E:()]</code> and <code>[A:()]</code> are true.</p>
<pre><code>po vari ge ga be
ge vi ga
</code></pre>
<p>It is however very common to use the pattern <code>ma vi ... fi ...</code> as it
shorter to use and support an arbitrary amount of propositions by
adding more <code>fi</code>.</p>
</blockquote>
<blockquote>
<p>vare: True if <code>[E:()]</code> or <code>[A:()]</code> or both is true.</p>
<pre><code>po vare ge ga be
bi ma
  vi bi ge
  fi bi ga
</code></pre>
</blockquote>
<p>Another useful tool is conditional claim (if ... then ... else ...), with
default arguments to make it work as logical implication.</p>
<blockquote>
<p>varu: If <code>[E:()]</code> is then <code>[A:()]</code> (default: true) is true, otherwise
<code>[O:()]</code> (default: true) is true.</p>
<pre><code>po varu ge ga be
vare
  va vari
    ve ge
    fa ga
    vei
  fe vari
    ve bi ge
    fa go
poia varu mai
poio varu mai
</code></pre>
</blockquote>
<p>A more advanced but useful predicate is about 2 things E and A satisfying a
relation O transitively: either they satisfy the relation directly or there
exist a chain of things that satisfy the relation to go from E to A. It is used
when there are many of those things in a chain, and also works for a (countable)
infinity of things. It is defined recursively.</p>
<blockquote>
<p>kidvo: <code>[E:a]</code> and <code>[A:a]</code> satisfy relation <code>[O:(a,a)]</code> transitively.</p>
<pre><code>po kidvo ke ka go be
</code></pre>
<p>Either <em>ke</em> and <em>ka</em> satisfy <em>go</em> directly</p>
<pre><code>vare
  vie ke go ka
</code></pre>
<p>Or there exist a <em>ki</em> such that <em>ke</em> and <em>ki</em> satisfy <em>go</em></p>
<pre><code>  fia bo ki
    vi ke go ki
</code></pre>
<p>With <em>ki</em> and <em>ka</em> satisfying <strong>transitively</strong> <em>go</em> (either directly or again
transitively)</p>
<pre><code>    fi ki kidvo
      va ka
      fio go
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sets"><a class="header" href="#sets">Sets</a></h1>
<p>Sets are one of the main building blocks of the vocabulary, and a powerful tool
to define other concepts.</p>
<p>It associates every property (along with the context it is evaluated with) with
a unique atom representing it and all arguments that makes the property true (the
members of the set). The core predicates modeling this are:</p>
<ul>
<li>tcui: <code>[E:ma]</code> is the (non-empty) set of all things that individualy satisfy
<code>[A:(a)]</code>.</li>
<li>tcie: <code>[E:a]</code> is a member of set <code>[A:tcui a]</code>.</li>
</ul>
<h2 id="axiom"><a class="header" href="#axiom">Axiom</a></h2>
<p>Defining sets using only <strong>po</strong> is however not possible, as <strong>tcui</strong> and
<strong>tcie</strong> depends on each other to be defined. Instead we need to define a
proposition stating that thoses predicates exists and satisfy the constraints of
sets and membership, and use <strong>pi</strong> to make this proposition an <strong>axiom</strong>, which
is assumed to be true.</p>
<blockquote>
<p>We first define the proposition of the axiom, which by convention is named
with a compound made from one of the defined predicates and the particle for
axioms <strong>pi</strong>.</p>
<pre><code>po e tcui pi be
</code></pre>
<p>We then state that predicates <strong>tcui</strong> and <strong>tcie</strong> exist:</p>
<pre><code>ma
  vi boi tcui
  fi boi tcie
</code></pre>
<p>Then for every property <strong>gi</strong> (we express it is a property by providing it
one generic argument (mai). However it means that <strong>gi</strong> must be true for at
least one argument. Thus, there will be no concept of an empty set).</p>
<pre><code>  fi mae
    ve gi be varu
      vie gi mai
</code></pre>
<p>Then for every context <strong>ki</strong> (which is a atom)</p>
<pre><code>      fia mae
        ve ki be varu
          vie ki ma
          fie ki mua
</code></pre>
<p>There exist a set <strong>ke</strong> representing this property (with this context)</p>
<pre><code>            ma
              vi bo ke tcui gi
</code></pre>
<p>And for all <strong>ka</strong>, <strong>ka</strong> is a member of set <strong>ke</strong> if and only if <strong>ka</strong>
satisfy <strong>gi</strong></p>
<pre><code>              fi mae
                ve ka be mai
                  vie ka tcie ke
                  fie ka gi
</code></pre>
<p>In the current state the proposition claims that such predicates exists, but
there is no way to prove it (thus the truth value is unknown). It is now time
to use <strong>pi</strong> to make it <strong>axiomatically true</strong>.</p>
<pre><code>pi e tcui pi
</code></pre>
</blockquote>
<h2 id="subsets"><a class="header" href="#subsets">Subsets</a></h2>
<p>We are now able to make sets from properties, and to speak about the members
of those sets. From those we can define a predicate for subsets.</p>
<blockquote>
<p>tcia: <code>[E:tcui a]</code> is a subset of <code>[A:tcui a]</code>.</p>
<pre><code>po tcia ke ka be
</code></pre>
<p>All members of <strong>ke</strong></p>
<pre><code>mae
  ve ki be varu 
    vie ki tcie ke
</code></pre>
<p>Also are members of <strong>ka</strong></p>
<pre><code>    fia ki tcie ka
</code></pre>
</blockquote>
<p>We can also define predicates for various kinds of subsets which can be useful
to define vocabulary.</p>
<blockquote>
<p>tcei: <code>[E:tcui a]</code> is a (non-empty) set of some things that individualy satisfy <code>[A:(a)]</code>.</p>
<pre><code>po tcie ke gia be
</code></pre>
<p><strong>ke</strong> is a subset of the set of all things that satisfy <strong>gia</strong></p>
<pre><code>ke tcia tcui gia
</code></pre>
</blockquote>
<blockquote>
<p>tcai: <code>[E:tcui a]</code> is a set containing exactly one member which satisfy <code>[A:(a)]</code>.</p>
<pre><code>po tcia ke gia be
</code></pre>
<p><strong>ke</strong> is a subset of the set of all things that satisfy <strong>gia</strong></p>
<pre><code>ma
  vi ke tcei gia
</code></pre>
<p>And it false that there exist 2 distinct things that are members of <strong>ke</strong> </p>
<pre><code>  fi bi ma
    vi bo ka tcie ke
    fi bo ko bi ka
    fi ko tcie ke
</code></pre>
</blockquote>
<blockquote>
<p>tcoi: <code>[E:tcui a]</code> is a set of at least 2 things that individualy satisfy <code>[A:(a)]</code>.</p>
<pre><code>po tcia ke gia be
</code></pre>
<p><strong>ke</strong> is a subset of the set of all things that satisfy <strong>gia</strong></p>
<pre><code>ma
  vi ke tcei gia
</code></pre>
<p>And there exist (at least) 2 distinct things that are members of <strong>ke</strong> </p>
<pre><code>  fi bo ka tcie ke
  fi bo ko bi ka
  fi ko tcie ke
</code></pre>
</blockquote>
<h2 id="improved-composability"><a class="header" href="#improved-composability">Improved composability</a></h2>
<p>Most of the vocabulary use set arguments to handle distributive and collective
behavior. However the above predicates use a property over a generic argument
instead of a set, meaning that set-based predicates cannot be used in it
without wrapping this argument into a set. We'll thus define a serie of
predicates that performs this wrapping.</p>
<blockquote>
<p>tca: <code>[E:tcai a]</code> is a set containing exactly one member, and satisfy <code>[A:(tcai a)]</code>.</p>
<pre><code>po tca ke gia be
ke se tcai gia
</code></pre>
</blockquote>
<blockquote>
<p>tcu: <code>[E:tcui a]</code> is the (non-empty) set of all things that individualy satisfy <code>[A:(tca a)]</code>.</p>
<pre><code>po tcu ke gia be
</code></pre>
<p><strong>ke</strong> is the set of all things that are the only member a set satisfying <strong>gia</strong>.</p>
<pre><code>ke tcui
  via be ba tcie tca gia
</code></pre>
</blockquote>
<blockquote>
<p>tce: <code>[E:tcei a]</code> is a (non-empty) set of some things that individualy satisfy <code>[A:(tca a)]</code>.</p>
<pre><code>po tce ke gia be
ke tcei
  via be ba tcie tca gia
</code></pre>
</blockquote>
<blockquote>
<p>tco: <code>[E:tcoi a]</code> is a set of at least 2 things that individualy satisfy <code>[A:(tca a)]</code>.</p>
<pre><code>po tco ke gia be
ke tcoi
  via be ba tcie tca gia
</code></pre>
</blockquote>
<blockquote>
<p>tci: <code>[E:tca a]</code> is a member of set <code>[A:tce a]</code>.</p>
<pre><code>po tci ke ka be
ke tca tcie ka
</code></pre>
</blockquote>
<p>It is thus recommanded to mostly use those &quot;wrapped versions&quot; unless accessing
to the unwrapped members is necessary, which is the case when speaking about
nested sets (sets of sets). </p>
<h2 id="set-operations"><a class="header" href="#set-operations">Set operations</a></h2>
<p>We can also define predicates for the set operations <strong>union</strong>, <strong>intersection</strong>
and <strong>difference</strong>.</p>
<blockquote>
<p>dji: <code>[E:tce a]</code> is the union of sets <code>[A:tce a]</code> and <code>[O:tce a]</code>.</p>
<pre><code>po dji ke ka ko be
ke tcu
  va ki be vare
    ve ki tci ka
    fa ki tci ko
</code></pre>
</blockquote>
<blockquote>
<p>dje: <code>[E:tce a]</code> is the intersection of sets <code>[A:tce a]</code> and <code>[O:tce a]</code>.</p>
<pre><code>po dje ke ka ko be
ke tcu
  va ki be vari
    ve ki tci ka
    fa ki tci ko
</code></pre>
</blockquote>
<blockquote>
<p>dja: <code>[E:tce a]</code> is the difference between sets <code>[A:tce a]</code> and <code>[O:tce a]</code>.</p>
<pre><code>po dja ke ka ko be
ke tcu
  va ki be vari
    ve ki tci ka
    fa bi ki tci ko
</code></pre>
</blockquote>
<p>Another common concept is the largest unique set that satisfy some property.
There doesn't exist another that that contains it and also satisfy the
property.</p>
<blockquote>
<p>djo: <code>[E:tce a]</code> is the locally largest set that satisfy <code>[A:(tce a)]</code>.</p>
<pre><code>po djo ke gia be
ma
  vi ke gia
  fi bi bo ka
    vi ka bi ke
    fi ka gia
    fi ke tcia ka
</code></pre>
</blockquote>
<p>Same with the smallest unique set:</p>
<blockquote>
<p>dju: <code>[E:tce a]</code> is the locally smallest set that satisfy <code>[A:(tce a)]</code>.</p>
<pre><code>po dju ke gia be
ma
  vi ke gia
  fi bi bo ka
    vi ka bi ke
    fi ka gia
    fi ka tcia ke
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pairs"><a class="header" href="#pairs">Pairs</a></h1>
<p>Another important building block is the ability to construct more complex
objects from simple ones. For that we define the concept of a pair, which is an
atom that is associated with a left and right component. We'll use an axiom to
state that there exist an unique atom for every possible pair of left and right
components.</p>
<blockquote>
<p>kin: <code>[E:ma]</code> is a pair made of left component <code>[A:a]</code> and right component <code>[O:o]</code>.</p>
<pre><code>po e kin pi be
ma
  vi boi kin
</code></pre>
<p>For every left and right components <strong>ka</strong> and <strong>ko</strong></p>
<pre><code>  fi mae
    ve ka be mae 
      ve ko be
</code></pre>
<p>There exist an atom <strong>ki</strong> which is a pair of <strong>ka</strong> and <strong>ko</strong>.</p>
<pre><code>      ma
       vi ki be ki ma kin 
         va ka
         fo ko
</code></pre>
<p>And it is false that there exist a different atom than <strong>ki</strong> which is also a
pair of <strong>ka</strong> and <strong>ko</strong> (thus there is a unique symbol for each pair)</p>
<pre><code>         fi bi ma
           ve bi ki
           fe kin
             va ka
             fo ko
</code></pre>
<p>We consider this an axiom.</p>
<pre><code>pi e kin pi
</code></pre>
</blockquote>
<p>By convention we'll prefer nesting pairs only in the right component.</p>
<p>Pairs can be used with left atom component specific to a concept A to make
it distinct from object related to concept B that would share the same kind
of objects. Without the left atom used as an identifier some things related
to concept A might also be considered valid things of concept B while it might
not be wanted. Identifiers are often made using <strong>zai</strong> which will be defined
in the next chapter, and are defined themselves using pairs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h1>
<p>Identifiers are the names themselves, and corresponds the atom predicated by
the particle <strong>zai</strong>. Since names corresponds to a property, we can define
them like to using pairs, where the left component is an atom representing
the concept of identifiers, and the right component is the property.</p>
<blockquote>
<p>ezaipe: <code>[E:ma]</code> is an identifier/name made from property <code>[A:(a)]</code>.</p>
<pre><code>po ezaipe ke gi be
</code></pre>
<p><strong>ke</strong> is a pair with the left component being the identifier made from
property <strong>ezaipe</strong> (it's common to define a predicate using itself for the
identifier)</p>
<pre><code>ma
  vi ke kin 
    va ezaipe ezaipe
</code></pre>
<p>And with right component <strong>gi</strong>.</p>
<pre><code>    fo gi vi
</code></pre>
<p><strong>gi</strong> being a property (even if it false for all possible arguments)</p>
<pre><code>    fi vare
      vie gi mai
      fie bi gi mai
</code></pre>
</blockquote>
<p>We can thus define the grammar <code>zai &lt;predicate&gt;</code> as being equivalent to
<code>pe se ezaipe via &lt;predicate&gt; pei</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lists"><a class="header" href="#lists">Lists</a></h1>
<p>Lists are data structures that contains items in a <strong>specific order</strong>. They
are defined internally with linked lists, as a pair of an item and a list of
the following items (or a sentinel value for an empty list).</p>
<blockquote>
<p>blur: <code>[E:ma]</code> is the empty list.</p>
<pre><code>po blur zai blun
</code></pre>
</blockquote>
<blockquote>
<p>blun: <code>[E:ma]</code> is a list.</p>
<pre><code>po blun ke be
</code></pre>
<p><strong>ke</strong> is either the empty list</p>
<pre><code>vare
  vie ke blur
</code></pre>
<p>Or a pair whose right component is a list.</p>
<pre><code>  fia ke seo kin blun
</code></pre>
</blockquote>
<p>Most of the time we'll deal with list of things of the same type and satisfying
a common property.</p>
<blockquote>
<p>blu: <code>[E:blun]</code> is a list of things all satisfying <code>[A:(a)]</code>.</p>
<pre><code>po blu ke gi be
vare
  vie ke zai blun
  fia ma
    vi ke sea kin gi
    fi ke seo kin blu gi
</code></pre>
</blockquote>
<p>From that definition we can now enable the <strong>bu</strong> list grammar like so</p>
<blockquote>
<p><code>&lt;A&gt; bu &lt;B&gt; bu &lt;C&gt;</code> is equivalent to:</p>
<pre><code>pe se kin
  va &lt;A&gt;
  fo kin
    va &lt;B&gt;
    fo kin
      va &lt;C&gt;
      fo zai blun
pei
</code></pre>
</blockquote>
<p>An important operation on list is called <strong>fold</strong>, which allows to iterate
over the list and evaluate a predicate with a value carried between iterations.</p>
<p>It's arguments are:</p>
<ul>
<li>the list to fold</li>
<li>the initial carry value</li>
<li>the final carry value</li>
<li>the predicate to apply for each element, which takes as arguments:
<ul>
<li>the input carry value</li>
<li>the output carry value</li>
<li>the element of the list</li>
</ul>
</li>
</ul>
<p>The provided predicate is applied for each element, with the output
carry for an element being the input carry for the next element.
For the first item the input is the initial carry, and for the last
item the output is the final carry.</p>
<blockquote>
<p>Since the predicate will be applied with each value of list it adds the
constraint that all the elements of the list have the same type.</p>
</blockquote>
<p>There are 2 variants of <strong>fold</strong>, one which is left-to-right (first to last)
while the other is right-to-left (last to first).</p>
<blockquote>
<p>bla: Left folds list <code>[E:blu a]</code> with initial <code>[A:b]</code> and final <code>[O:b]</code>
carries by applying predicate <code>[U:(b,b,a)]</code> in first to last order.</p>
<pre><code>po bla ke ka ko gu be
</code></pre>
<p>Either <strong>ke</strong> is an empty list, in which can the initial and final carry
values are the same. </p>
<pre><code>vare
  vie ke zai blun
    vi ka ko vei
</code></pre>
<p>Or <strong>ke</strong> is not an empty list with element <strong>x</strong>, in which case there exist
a <strong>ki</strong> such that <strong>gu(ka,ki,x)</strong> and <strong>ki</strong> is the initial value of a left
fold on the rest of the list.</p>
<pre><code>  fie ke zi zai blun
    vi ma
      vi bo ki
      fi ka gu va ki fo sae kin ke vei
      fi bla
        ve soe kin ke
        fa ki
        fo ko
        fu gu
</code></pre>
</blockquote>
<blockquote>
<p>blai: Right folds list <code>[E:blu a]</code> with initial <code>[A:b]</code> and final <code>[O:b]</code>
carries by applying predicate <code>[U:(b,b,a)]</code> in last to first order.</p>
<pre><code>po blai ke ka ko gu be
</code></pre>
<p>Either <strong>ke</strong> is an empty list, in which can the initial and final carry
values are the same. </p>
<pre><code>vare
  vie ke zai blun
    vi ka ko vei
</code></pre>
<p>Or <strong>ke</strong> is not an empty list with element <strong>x</strong>, in which case there exist
a <strong>ki</strong> such that <strong>gu(ki,ko,x)</strong> and <strong>ki</strong> is the final value of a right
fold on the rest of the list.</p>
<pre><code>  fie ke zi zai blun
    vi ma
      vi bo ki
      fi ki gu va ko fo sae kin ke vei
      fi blai
        ve soe kin ke
        fa ka
        fo ki
        fu gu
</code></pre>
</blockquote>
<p>Thanks to those predicates we can easily define list concatenation.</p>
<blockquote>
<p>ble: <code>[E:blu a]</code> is the concatenation of lists <code>[A:blu a]</code> and <code>[O:blu a]</code>.</p>
<pre><code>po ble ke ka ko be
so blai
  ve ka
  fa ko
  fiu kie kia kio be
    kia kin
      ve kio
      fa kie
</code></pre>
</blockquote>
<p>And even inclusion.</p>
<blockquote>
<p>bla: <code>[E:blu a]</code> is included/contained in <code>[A:blu a]</code>.</p>
<pre><code>po bla ke ka be
ka ble
  vo ble
    fa ke
</code></pre>
</blockquote>
<p>Finally, we can allow speakers to quickly define sets using the list grammar
with the following predicate.</p>
<blockquote>
<p>bli: <code>[E:tce a]</code> is the set containing only all the elements in list <code>[A:blu a]</code>.</p>
<p>We first define a predicate ensuring that <strong>ke</strong> is a set containing alls
elements in list <strong>ka</strong>.</p>
<pre><code>po ga ke ka be
ka bla
  va ke
  fiu kie kia kio be
    kio tcie kie
</code></pre>
<p>Then we use it to define <strong>bli</strong> such that <strong>ke</strong> is the <strong>smallest</strong> set
containing all elements in list <strong>ka</strong> (so it can't be any set that contains
them plus additional members that are not in the list).</p>
<pre><code>po bli ke ka be
ma vi ke ga ka
  fi bi ma 
    ve bi ke ga ka
    fe tcia ke   
</code></pre>
</blockquote>
<blockquote>
<p>Example of usage (with full grammar and vocabulary):<br />
<code>mi dona bli va za ualisi bu za ubobo</code><br />
I like Alice and Bob.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maps"><a class="header" href="#maps">Maps</a></h1>
<p><strong>Maps</strong> (also called <strong>dictionaries</strong>) are another important data structure
that contains 0 to many <strong>entries</strong> composed of a <strong>key</strong> and a <strong>value</strong>, with
the additional constraint that there cannot be 2 different entries with the same
key.</p>
<p>Maps are usefull in many cases where many informations must be aggregated into a
single thing and easily accessible (pairs are verbose to use when deeply nested,
and lists requires to associate values to indexes which cannot be skipped). Maps
are an obvious choice for context parameters, as they allow to easily implement
new concepts by storing information in the map with a new dedicated key.</p>
<blockquote>
<p>kcin: <code>[E:ma]</code> is a map.</p>
<pre><code>po kcin ke be
</code></pre>
<p><strong>ke</strong> is either an empty map (represented by <code>zai kcin</code>)</p>
<pre><code>vare
  vie ke zai kcin
</code></pre>
<p>Or a pair with a left identifier</p>
<pre><code>  fia ma
    vi ke sea kin zai kcin
</code></pre>
<p>And as right part a set of pairs with left parts (keys) being symbols</p>
<pre><code>    fi ke seo kin tcei sea kin ma
</code></pre>
<p>And it is false that there are multiple entries with the same key</p>
<pre><code>    fi bi ma
      vi bo ka tcie soe kin ke
      fi bo ko tcie soe kin ke
      fi ka bi ko
      fi ka sea kin sae kin ko
</code></pre>
</blockquote>
<blockquote>
<p>kcil: <code>[E:kcin]</code> is the empty map.</p>
<pre><code>po kcil zai kcin
</code></pre>
</blockquote>
<p>We can then interact more directly with entries using the following:</p>
<blockquote>
<p>kce: <code>[E:a]</code> is the value in map <code>[A:kcin]</code> for key <code>[O:ma]</code>.</p>
<pre><code>po kce ke ka ko be
tcie
  va soe kin ka kcin
  fe kin
    ve ko
    fa ke
</code></pre>
</blockquote>
<p>Finally we set the empty map as the context parameter for future sentences.</p>
<blockquote>
<pre><code>pae kcil
</code></pre>
</blockquote>
<p>We can make a variant of <em>kce</em> to directly access a value stored in the
context.</p>
<blockquote>
<p>kcei: <code>[E:a]</code> is the value in the context map for key <code>[A:ma]</code>.</p>
<pre><code>po kcei ke ka be
mue vie ki be ke kce
  va ki
  fo ka
</code></pre>
</blockquote>
<p>Future predicates will thus be able to modify the context with a specific key
without messing with other predicates relying on the context (by using their own
different key).</p>
<h2 id="map-operations"><a class="header" href="#map-operations">Map operations</a></h2>
<p>It is then useful to be able to make a map from another one with some
modification.</p>
<blockquote>
<p>kcani: <code>[E:kcin]</code> is obtained from <code>[A:kcin]</code> by removing the entry with key
<code>[O:ma]</code>. If <code>[A]</code> don't have entry with key <code>[O]</code> then <code>[E]</code> = <code>[A]</code>.</p>
<pre><code>po kcani ke ka ko be
</code></pre>
<p>The set of entries of <em>ke</em> is the largest subset of the set of entries of <em>ka</em>
that doesn't contain an entry with key <em>ko</em>.</p>
<pre><code>ke kcin seo kin djo
  via ke be ma
    vi ke tcai soe kin ka
    fi bi ke sae tci sae kin ko
</code></pre>
</blockquote>
<blockquote>
<p>kcoi: <code>[E:kcin]</code> is obtained from <code>[A:kcin]</code> by inserting an entry with key
<code>[O:ma]</code> and value <code>[U:ma]</code>. If <code>[A]</code> have an entry with key <code>[O]</code> then it is
removed to insert the entry with key <code>[O]</code> and value <code>[U]</code>. </p>
<pre><code>po kcoi ke ka ko ku be
</code></pre>
<p>Given <em>x</em> the map obtained from <em>ka</em> by removing an entry with key <em>ko</em>, The
set of entries of <em>ke</em> is the smallest superset of <em>x</em> such as <em>ke</em> have as
member an entry with key <em>ko</em> and value <em>ku</em>.</p>
<pre><code>ke kcin seo kin dju
  via ke be kcoi
    va ka
    fo ko
    fe seo kin tcai ke sae tci kin
      ve ko
      fo ku
</code></pre>
</blockquote>
<blockquote>
<p>kcui: <code>[E:kcin]</code> is obtained from <code>[A:kcin]</code> by transforming the value of
entry with key <code>[O:ma]</code> using relation <code>[U:(a,a)]</code>. It implies that <code>[A]</code> must
have an entry with key <code>[O]</code>.</p>
<pre><code>po kcui ke ka ko gu be
ke kcoi
  va ka
  fo ko
  fu gu kce
    va ka
    fo ko
</code></pre>
</blockquote>
<h2 id="ergonomic-map-operations"><a class="header" href="#ergonomic-map-operations">Ergonomic map operations</a></h2>
<p>The above predicates are pretty verbose to use, especially if multiple
operations must be performed in a row. For that reason we're going to define
more ergonomic versions that manage the transformed map using the context. The
predicate <code>kca</code> will take as arguments the input and output maps and <strong>a list of
0-ary predicates</strong>. This list will be folded and evaluated with a modified
context containing the input and output map (at each step of the iteration),
which will be used by predicates taking the other parameters explicitly (key and
value, no need to take input and output as they are retreived from the context).</p>
<blockquote>
<p>kca: <code>[E:kcin]</code> represents a map that can be optained from <code>[A:kcin]</code> by
applying the list of transformations <code>[O:blu ()]</code>.</p>
<pre><code>po kca ke ka ko be
</code></pre>
<p>We fold the list <em>ko</em> with input <em>ke</em>, output <em>ka</em> and predicate
<em>(kie,kia,gia)</em>, <em>kie</em> and <em>kia</em> being the input/intermediary/output maps and
<em>gia</em> being one of the proposition in the list (they are folded in order).</p>
<pre><code>ko bla
  va ke
  fo ka
  fiu kie kia gia be
</code></pre>
<p>We take the current context <em>ki</em></p>
<pre><code>    mue vie ki be   
</code></pre>
<p>And evaluate <em>gia</em> (the proposition in the list) with a context that is
obtained from <em>ki</em> by inserting the pair <em>(kie,kia)</em> at key <em>zai kca</em>.</p>
<pre><code>      mua
        va gia
        fe kcoi
          va ki
          fo zai kca
          fu kin
            va kie
            fo kia
</code></pre>
</blockquote>
<p>We can then write predicates that uses this pair instead of taking arguments.</p>
<blockquote>
<p>kcan: Remove entry with key <code>[E:ma]</code>.</p>
<pre><code>po kcan ke be
ke so kcani
  va sae kin kcei zai kca
  fe soe kin kcei zai kca   
</code></pre>
</blockquote>
<blockquote>
<p>kco: Insert entry with key <code>[E:ma]</code> and value <code>[A:a]</code>.</p>
<pre><code>po kco ke ka be
ke so kcoi
  va sae kin kcei zai kca
  fe soe kin kcei zai kca   
  fo ka
</code></pre>
</blockquote>
<blockquote>
<p>kcu: Transform entry with key <code>[E:ma]</code> with value relation (old,new)
<code>[A:(a,a)]</code>.</p>
<pre><code>po kcu ke ga be
ke so kcui
  va sae kin kcei zai kca
  fe soe kin kcei zai kca   
  fo ga
</code></pre>
</blockquote>
<blockquote>
<p>With these predicates we can write stuff like:</p>
<pre><code>po ga ke ka be
ke kca
  va ka
  fo zai ti kcan
  bu zai te kco ma
  bu zai ta kcu tcia
</code></pre>
<p><em>ka</em> is thus <em>ke</em> with:</p>
<ul>
<li>Key <em>zai ti</em> removed</li>
<li>Key <em>zai te</em> inserted with some atom as value</li>
<li>Key <em>zai ta</em> transformed such that the old value is a subset of the new
value</li>
</ul>
</blockquote>
<p>Since we use maps for context it is fairly common to evaluate a proposition
with a modified context. We can make a predicate make that easier.</p>
<blockquote>
<p>kcar: Transformations <code>[E:blu ()]</code> are applied on the context before it is
used to evaluate <code>[A:()]</code>.</p>
<pre><code>po kcar ke gia be
mue
  ve ki be mua
    va gia
    fe kca
      va ki
      fo ke
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time-1"><a class="header" href="#time-1">Time</a></h1>
<blockquote>
<p><strong>DRAFT</strong>: Time-related concepts and vocabulary are <strong>work in progress</strong> and
might change in the future.</p>
</blockquote>
<p>Design a tense system that is easy to use at high level, but that is defined in
Eberban at low level is a major chalenge, and is the reason for the existence of
some parts of the grammar (even if those parts are more general purposed and
don't depend on the tense system).</p>
<h2 id="representing-time"><a class="header" href="#representing-time">Representing time</a></h2>
<p>First, we want to represent time and the differents states in which the universe
are alongside it. We also want a model that allows us to deal with multiple
possible futures or even parallel or fictional universes.</p>
<p>To do that we'll first define a <strong>node</strong> in a <strong>directed graph</strong> (also called
<strong>digraph</strong>), with (directed) <strong>arcs</strong> representing a transition from a node to
another. Nodes can represent <strong>time instants</strong>, and arcs can represents which
possible state of the universe is immediately following this one. </p>
<blockquote>
<p>Even if nodes and digraphs can be used for more general purposes, we'll use
time related terminology to keep things easier to follow.</p>
</blockquote>
<p>We'll define a node as a pair of an identifier (<code>zai din</code>) and set of nodes that
this node have arcs towards. Note that while sets can't be empty, we want to
support nodes with no arcs, which is done by using a sentinel value instead of
the set (<code>zai din</code> again). </p>
<blockquote>
<p>din: <code>[E:ma]</code> is an instant (digraph node).</p>
<pre><code>po din ke be
ke kin
  va zai din
  fo vare
    ve zai din
    fa tce din
</code></pre>
</blockquote>
<p>We can then define predicates to more easily speak about arcs and paths
(transitive arcs). We'll also call paths <strong>time spans</strong>.</p>
<blockquote>
<p>dini: There exist an arc from node <code>[E:din]</code> to node <code>[A:din]</code>.</p>
<pre><code>po dini ke ka be
ke din kin
  vo sae tci ka din
</code></pre>
</blockquote>
<blockquote>
<p>dinu: There exist an path/span <code>[O:blu din]</code> from node <code>[E:din]</code> to node <code>[A:din]</code>.</p>
<pre><code>po dinu ke ka ko be
</code></pre>
<p>We exclude the final node since we don't want to speak about an arc from it to
another one (since its the last one).</p>
<pre><code>ko ble
  vo ka bu
</code></pre>
<p>The rest of the list contains nodes such that each node have an arc towards
the next node in the list, or the final node for the penultimate node in the
list.</p>
<pre><code>  fa bla
    va ke
    fo ka
</code></pre>
<p>The item is the input carry and have an arc towards the output carry.</p>
<pre><code>    fu kie kia kio be kie kio dini kia
</code></pre>
</blockquote>
<h2 id="present"><a class="header" href="#present">Present</a></h2>
<p>To represent the flow of time with the concept of &quot;present&quot;, we store in the
context a node, and between sentences we update it (thanks to <strong>pahe</strong>) by
taking a node such that there exist a path between the old and the next one (the
new present is in the future of the old one).</p>
<blockquote>
<p>den: <code>[E:()]</code> is evaluated with a more recent present.</p>
<pre><code>po den gie be
kcar
  va gia
  fe zai den kcu dinu
</code></pre>
</blockquote>
<p>We'll define a predicate to help using predicates like <strong>sin</strong> (with a single
proposition argument) with <strong>pae</strong> and <strong>pahe</strong>.</p>
<blockquote>
<p>pane: <code>[E:ma]</code> is the context exposed to a predicate when it evaluated by
<code>[A:(())]</code>.</p>
<pre><code>po pane ke gia be
gia
  via be mue ke
</code></pre>
</blockquote>
<p>We can pick a first present node.</p>
<blockquote>
<pre><code>pae pane
  va gi be kcar
    va gia
    fe zai den kco din
</code></pre>
</blockquote>
<p>And setup the automatic present update. (we also assign it to <em>epahegi</em> so that
it can easily be composed with other future transformations)</p>
<blockquote>
<pre><code>po epahegi pane den 
pahe epahegi
</code></pre>
</blockquote>
<p>We also make a predicate for the time span containing only the present, as it
will be useful later.</p>
<blockquote>
<p>del: <code>[E:dinu]</code> is the present time span.</p>
<pre><code>po del ke be
ke ve kcei zai den bu
</code></pre>
</blockquote>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p>Many predicates represents something that happens in some time span. To make
them composable, they interact with the context, and states that time span in
key <code>zai zvi</code> is part of their time span, which can also be seen as their own
path being a concatenation of a prefix span, <code>zai zvi</code> span and a suffix span
where the prefix and suffix can be empty. The predicate <code>zvi</code> can be used to
setup such entry in the context (and make it the longest possible).</p>
<blockquote>
<p>The provided proposition will be evaluated with a span <em>x</em> such that there
doesn't exist another span <em>y</em> containing <em>x</em> that also make the proposition
true. They might however be multiple possible <em>x</em> that don't contain each
other.</p>
</blockquote>
<blockquote>
<p>zvi: <code>[E:dinu]</code> is a time span shared by all events of <code>[A:()]</code>.<br />
We define a first predicate to evaluate A with a span in the context</p>
<pre><code>po izvi ke gia be
kcar
  va gia
  fe zai zvi kco ke bu
</code></pre>
<p>Then we really define <code>zvi</code> by ensuring this span cannot be made longer by
concatenation.</p>
<pre><code>po zvi ke gia be
ma
  vi ke izvi gia
  fi bi ma
    ve pe ble
      va zi blur
      fo ble
        va ke
        fo zi blur
    pei fe izvi gia
</code></pre>
</blockquote>
<p>A predicate modeling an event can then use the following predicate to state that
the context span is contained into the provided span.</p>
<blockquote>
<p>zvin: Time span <code>[E:dinu]</code> contains context time span.</p>
<pre><code>po zvin
sa bla ve kcei zei zvi
</code></pre>
</blockquote>
<p>In some cases it can be useful to refer to the context time span itself.</p>
<blockquote>
<p>zvil: <code>[E:dinu]</code> is the context time span.</p>
<pre><code>po zvil
kcei zei zvi
</code></pre>
</blockquote>
<h2 id="tenses"><a class="header" href="#tenses">Tenses</a></h2>
<p>Since our model of time allows multiple possible futures of a same instant, we
must distinguish between time span relations that are <strong>possible</strong> and
<strong>necessary</strong>. A relation is <strong>possible</strong> if there exist a time line in which
the relation holds. A relation is <strong>necessary</strong> if in all time lines the
relation hold. To make the tense composable with the context time span, they
express a relation between the context time span and the time span of the
provided proposition.</p>
<p>Let's first start with a simple one: the proposition time span is met by the
context time span, which means that the last instant of the context time
span is the first instant of the proposition time span.</p>
<blockquote>
<p>sul: It is possible that <code>[E:()]</code> is met by time span <code>[A:dinu]</code>
(default: context time span).</p>
<pre><code>po sul gie ka be
ma
</code></pre>
<p><em>ke</em> is a time span of events in <em>gie</em></p>
<pre><code>  vi bo ke zvi gie
</code></pre>
<p><em>ki</em> is the first instant of time span <em>ke</em></p>
<pre><code>  fi pe ke ble
    va bo ki bu
  pei
</code></pre>
<p><em>ki</em> is the last instant of <em>ka</em></p>
<pre><code>  fi ka ble
    vo ki bu

poia sul zvil
</code></pre>
</blockquote>
<p>To make the <strong>necessary</strong> variant we need to check that for all time spans <em>x</em>
that contains the provided time span (often the context time span), either:</p>
<ul>
<li><em>x</em> contains the proposition time span</li>
<li><em>x</em> is contained in a larger time span that itself contains the proposition
time span</li>
</ul>
<blockquote>
<p>This second case allows to handle the time spans that would be &quot;to short&quot; to
contain the proposition time span which will be &quot;further away&quot;.</p>
</blockquote>
<blockquote>
<p>zvan: For all time span <em>x</em> that contains the time span <code>[A:dinu]</code>, either:</p>
<ul>
<li><code>[E:(dinu)]</code> evaluated with <em>x</em> is true</li>
<li><code>[E]</code> is true if evaluated with a time span containing <em>x</em></li>
</ul>
<pre><code>po zvan gie ka be
</code></pre>
<p>For all time span <em>ki</em> that contains <em>ka</em></p>
<pre><code>mae
  vie ki be varu
    vie ki sae bla ka
</code></pre>
<p>It it either a time span that makes <em>gie</em> true</p>
<pre><code>    fia vare
      vie gie ki
</code></pre>
<p>Or this time span is contained in a larger time span <em>ke</em> that makes <em>gie</em>
true</p>
<pre><code>      fia ma
        vi bo ke sae bla ki
        fi gie ke
</code></pre>
</blockquote>
<p>Thanks to this predicate we're able to define:</p>
<blockquote>
<p>sun: It is necessary that <code>[E:()]</code> is met by time span <code>[A:dinu]</code>
(default: context time span).</p>
<pre><code>po sun gie ka be
zvan
  fa ka
  vie ki be sul
    vie gie
</code></pre>
<p><em>ki</em>, which is provided by <em>zvan</em>, must contains the context span</p>
<pre><code>      vi ki sae bla zvil
</code></pre>
</blockquote>
<p>We can define all the following predicates (with A always defaulting to the
context time span) :</p>
<ul>
<li><strong>sel/sen</strong>: E meets A (end instant of E = first instant of A)</li>
<li><strong>sal/san</strong>: E starts A  (they share the same start instant)</li>
<li><strong>sol/son</strong>: E finishes A (they share the same end instant)</li>
<li><strong>sul/sun</strong>: E is met by A (end instant of A = first instant of E)</li>
<li><strong>siel/sien</strong>: E is before A</li>
<li><strong>sial/sian</strong>: E contains A</li>
<li><strong>siol/sion</strong>: E contained by A (there is no difference between both variants)</li>
<li><strong>siul/siun</strong>: E is after A</li>
<li><strong>sil/sin</strong>: E overlaps with A</li>
</ul>
<blockquote>
<p>Their definition is omited here but is similar to the ones of <strong>sul/sun</strong>.</p>
</blockquote>
<p>Aside from those relations with the context span, we can make a tense predicate
related to the present instant instead of the context time span.</p>
<blockquote>
<p>dan: <code>[E:()]</code> presently occurs.</p>
<pre><code>po dan gie be
bla
  ve kcei zai den bu
  fa zvi gie
</code></pre>
</blockquote>
<h2 id="sentence-wrapper"><a class="header" href="#sentence-wrapper">Sentence wrapper</a></h2>
<p>Now that we have tenses that interact with the context time span, we need to
actually setup this time span for all sentences. For that we allow to register
in the context a property describing one or multiple <strong>initial time spans</strong>.</p>
<blockquote>
<p>zve: <code>[E:kcin]</code> is the context after inserting the initial time spans <code>[A:(blu din)]</code>.</p>
<pre><code>po zve ke gia be
kcar
  via mue ke
  fe zai zve kco gia bu
</code></pre>
</blockquote>
<p>Then at the start of each sentence, we can use <em>zvi</em> with a time span that
satisfy this registered property. (we also assign it to <em>epahigi</em> so that it can
easily be composed with other future sentence wrappers).</p>
<blockquote>
<pre><code>po eipahizve gie be
zvi
  via zvin zvi gie
    zvin zu pe kcei zai zve

po epahigi eipahizve
pahi epahigi
</code></pre>
</blockquote>
<p>By default we'll set it to the present (since it's a property it can use the
context to always correspond to the current present instant)</p>
<blockquote>
<pre><code>pae zve del
</code></pre>
</blockquote>
<blockquote>
<p>It could also be set such that it can be any time span, which can be useful
to express a reference event in some alternate or fictional universe, and
then set this event time span as the initial time span.</p>
<pre><code>pae zve mai
</code></pre>
</blockquote>
<hr />
<blockquote>
<p>A later chapter will introduce measurement of durations, which will greatly
increase what can be done with tenses.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="res/leipzig.min.js"></script>
        <script type="text/javascript" src="res/leipzig_apply.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
